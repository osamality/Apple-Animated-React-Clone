{"ast":null,"code":"import { NodeUpdateType } from './constants.js';\nimport { getNodesKeys } from './NodeUtils.js';\nimport { MathUtils } from 'three';\nlet _nodeId = 0;\n\nclass Node {\n  constructor(nodeType = null) {\n    this.nodeType = nodeType;\n    this.updateType = NodeUpdateType.None;\n    this.uuid = MathUtils.generateUUID();\n    Object.defineProperty(this, 'id', {\n      value: _nodeId++\n    });\n  }\n\n  get type() {\n    return this.constructor.name;\n  }\n\n  getHash() {\n    return this.uuid;\n  }\n\n  getUpdateType() {\n    return this.updateType;\n  }\n\n  getNodeType() {\n    return this.nodeType;\n  }\n\n  update() {\n    console.warn('Abstract function.');\n  }\n\n  generate() {\n    console.warn('Abstract function.');\n  }\n\n  analyze(builder) {\n    const hash = this.getHash(builder);\n    const sharedNode = builder.getNodeFromHash(hash);\n\n    if (sharedNode !== undefined && this !== sharedNode) {\n      return sharedNode.analyze(builder);\n    }\n\n    const nodeData = builder.getDataFromNode(this);\n    nodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;\n    const nodeKeys = getNodesKeys(this);\n\n    for (const property of nodeKeys) {\n      this[property].analyze(builder);\n    }\n  }\n\n  build(builder, output = null) {\n    const hash = this.getHash(builder);\n    const sharedNode = builder.getNodeFromHash(hash);\n\n    if (sharedNode !== undefined && this !== sharedNode) {\n      return sharedNode.build(builder, output);\n    }\n\n    builder.addNode(this);\n    builder.addStack(this);\n    const nodeData = builder.getDataFromNode(this);\n    const isGenerateOnce = this.generate.length === 1;\n    let snippet = null;\n\n    if (isGenerateOnce) {\n      const type = this.getNodeType(builder);\n      snippet = nodeData.snippet;\n\n      if (snippet === undefined) {\n        snippet = this.generate(builder) || '';\n        nodeData.snippet = snippet;\n      }\n\n      snippet = builder.format(snippet, type, output);\n    } else {\n      snippet = this.generate(builder, output) || '';\n    }\n\n    builder.removeStack(this);\n    return snippet;\n  }\n\n  serialize(json) {\n    const nodeKeys = getNodesKeys(this);\n\n    if (nodeKeys.length > 0) {\n      const inputNodes = {};\n\n      for (const property of nodeKeys) {\n        inputNodes[property] = this[property].toJSON(json.meta).uuid;\n      }\n\n      json.inputNodes = inputNodes;\n    }\n  }\n\n  deserialize(json) {\n    if (json.inputNodes !== undefined) {\n      const nodes = json.meta.nodes;\n\n      for (const property in json.inputNodes) {\n        const uuid = json.inputNodes[property];\n        this[property] = nodes[uuid];\n      }\n    }\n  }\n\n  toJSON(meta) {\n    const {\n      uuid,\n      type\n    } = this;\n    const isRoot = meta === undefined || typeof meta === 'string';\n\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    } // serialize\n\n\n    let data = meta.nodes[uuid];\n\n    if (data === undefined) {\n      data = {\n        uuid,\n        type,\n        meta,\n        metadata: {\n          version: 4.5,\n          type: 'Node',\n          generator: 'Node.toJSON'\n        }\n      };\n      meta.nodes[data.uuid] = data;\n      this.serialize(data);\n      delete data.meta;\n    } // TODO: Copied from Object3D.toJSON\n\n\n    function extractFromCache(cache) {\n      const values = [];\n\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n\n    return data;\n  }\n\n}\n\nNode.prototype.isNode = true;\nexport default Node;","map":{"version":3,"sources":["/Users/osamakhan/Desktop/Apple-Website-Clone-React-master/node_modules/three-stdlib/nodes/core/Node.js"],"names":["NodeUpdateType","getNodesKeys","MathUtils","_nodeId","Node","constructor","nodeType","updateType","None","uuid","generateUUID","Object","defineProperty","value","type","name","getHash","getUpdateType","getNodeType","update","console","warn","generate","analyze","builder","hash","sharedNode","getNodeFromHash","undefined","nodeData","getDataFromNode","dependenciesCount","nodeKeys","property","build","output","addNode","addStack","isGenerateOnce","length","snippet","format","removeStack","serialize","json","inputNodes","toJSON","meta","deserialize","nodes","isRoot","textures","images","data","metadata","version","generator","extractFromCache","cache","values","key","push","prototype","isNode"],"mappings":"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","sourcesContent":["import { NodeUpdateType } from './constants.js';\nimport { getNodesKeys } from './NodeUtils.js';\nimport { MathUtils } from 'three';\n\nlet _nodeId = 0;\n\nclass Node {\n  constructor(nodeType = null) {\n    this.nodeType = nodeType;\n    this.updateType = NodeUpdateType.None;\n    this.uuid = MathUtils.generateUUID();\n    Object.defineProperty(this, 'id', {\n      value: _nodeId++\n    });\n  }\n\n  get type() {\n    return this.constructor.name;\n  }\n\n  getHash() {\n    return this.uuid;\n  }\n\n  getUpdateType() {\n    return this.updateType;\n  }\n\n  getNodeType() {\n    return this.nodeType;\n  }\n\n  update() {\n    console.warn('Abstract function.');\n  }\n\n  generate() {\n    console.warn('Abstract function.');\n  }\n\n  analyze(builder) {\n    const hash = this.getHash(builder);\n    const sharedNode = builder.getNodeFromHash(hash);\n\n    if (sharedNode !== undefined && this !== sharedNode) {\n      return sharedNode.analyze(builder);\n    }\n\n    const nodeData = builder.getDataFromNode(this);\n    nodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;\n    const nodeKeys = getNodesKeys(this);\n\n    for (const property of nodeKeys) {\n      this[property].analyze(builder);\n    }\n  }\n\n  build(builder, output = null) {\n    const hash = this.getHash(builder);\n    const sharedNode = builder.getNodeFromHash(hash);\n\n    if (sharedNode !== undefined && this !== sharedNode) {\n      return sharedNode.build(builder, output);\n    }\n\n    builder.addNode(this);\n    builder.addStack(this);\n    const nodeData = builder.getDataFromNode(this);\n    const isGenerateOnce = this.generate.length === 1;\n    let snippet = null;\n\n    if (isGenerateOnce) {\n      const type = this.getNodeType(builder);\n      snippet = nodeData.snippet;\n\n      if (snippet === undefined) {\n        snippet = this.generate(builder) || '';\n        nodeData.snippet = snippet;\n      }\n\n      snippet = builder.format(snippet, type, output);\n    } else {\n      snippet = this.generate(builder, output) || '';\n    }\n\n    builder.removeStack(this);\n    return snippet;\n  }\n\n  serialize(json) {\n    const nodeKeys = getNodesKeys(this);\n\n    if (nodeKeys.length > 0) {\n      const inputNodes = {};\n\n      for (const property of nodeKeys) {\n        inputNodes[property] = this[property].toJSON(json.meta).uuid;\n      }\n\n      json.inputNodes = inputNodes;\n    }\n  }\n\n  deserialize(json) {\n    if (json.inputNodes !== undefined) {\n      const nodes = json.meta.nodes;\n\n      for (const property in json.inputNodes) {\n        const uuid = json.inputNodes[property];\n        this[property] = nodes[uuid];\n      }\n    }\n  }\n\n  toJSON(meta) {\n    const {\n      uuid,\n      type\n    } = this;\n    const isRoot = meta === undefined || typeof meta === 'string';\n\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    } // serialize\n\n\n    let data = meta.nodes[uuid];\n\n    if (data === undefined) {\n      data = {\n        uuid,\n        type,\n        meta,\n        metadata: {\n          version: 4.5,\n          type: 'Node',\n          generator: 'Node.toJSON'\n        }\n      };\n      meta.nodes[data.uuid] = data;\n      this.serialize(data);\n      delete data.meta;\n    } // TODO: Copied from Object3D.toJSON\n\n\n    function extractFromCache(cache) {\n      const values = [];\n\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n\n    return data;\n  }\n\n}\n\nNode.prototype.isNode = true;\n\nexport default Node;\n"]},"metadata":{},"sourceType":"module"}
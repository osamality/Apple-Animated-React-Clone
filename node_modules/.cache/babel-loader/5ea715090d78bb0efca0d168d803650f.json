{"ast":null,"code":"/**\n * Main content for the worker that handles the loading and execution of\n * modules within it.\n */\nfunction workerBootstrap() {\n  var modules = Object.create(null); // Handle messages for registering a module\n\n  function registerModule(ref, callback) {\n    var id = ref.id;\n    var name = ref.name;\n    var dependencies = ref.dependencies;\n    if (dependencies === void 0) dependencies = [];\n    var init = ref.init;\n    if (init === void 0) init = function () {};\n    var getTransferables = ref.getTransferables;\n    if (getTransferables === void 0) getTransferables = null; // Only register once\n\n    if (modules[id]) {\n      return;\n    }\n\n    try {\n      // If any dependencies are modules, ensure they're registered and grab their value\n      dependencies = dependencies.map(function (dep) {\n        if (dep && dep.isWorkerModule) {\n          registerModule(dep, function (depResult) {\n            if (depResult instanceof Error) {\n              throw depResult;\n            }\n          });\n          dep = modules[dep.id].value;\n        }\n\n        return dep;\n      }); // Rehydrate functions\n\n      init = rehydrate(\"<\" + name + \">.init\", init);\n\n      if (getTransferables) {\n        getTransferables = rehydrate(\"<\" + name + \">.getTransferables\", getTransferables);\n      } // Initialize the module and store its value\n\n\n      var value = null;\n\n      if (typeof init === 'function') {\n        value = init.apply(void 0, dependencies);\n      } else {\n        console.error('worker module init function failed to rehydrate');\n      }\n\n      modules[id] = {\n        id: id,\n        value: value,\n        getTransferables: getTransferables\n      };\n      callback(value);\n    } catch (err) {\n      if (!(err && err.noLog)) {\n        console.error(err);\n      }\n\n      callback(err);\n    }\n  } // Handle messages for calling a registered module's result function\n\n\n  function callModule(ref, callback) {\n    var ref$1;\n    var id = ref.id;\n    var args = ref.args;\n\n    if (!modules[id] || typeof modules[id].value !== 'function') {\n      callback(new Error(\"Worker module \" + id + \": not found or its 'init' did not return a function\"));\n    }\n\n    try {\n      var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n\n      if (result && typeof result.then === 'function') {\n        result.then(handleResult, function (rej) {\n          return callback(rej instanceof Error ? rej : new Error('' + rej));\n        });\n      } else {\n        handleResult(result);\n      }\n    } catch (err) {\n      callback(err);\n    }\n\n    function handleResult(result) {\n      try {\n        var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n\n        if (!tx || !Array.isArray(tx) || !tx.length) {\n          tx = undefined; //postMessage is very picky about not passing null or empty transferables\n        }\n\n        callback(result, tx);\n      } catch (err) {\n        console.error(err);\n        callback(err);\n      }\n    }\n  }\n\n  function rehydrate(name, str) {\n    var result = void 0;\n\n    self.troikaDefine = function (r) {\n      return result = r;\n    };\n\n    var url = URL.createObjectURL(new Blob([\"/** \" + name.replace(/\\*/g, '') + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\"], {\n      type: 'application/javascript'\n    }));\n\n    try {\n      importScripts(url);\n    } catch (err) {\n      console.error(err);\n    }\n\n    URL.revokeObjectURL(url);\n    delete self.troikaDefine;\n    return result;\n  } // Handler for all messages within the worker\n\n\n  self.addEventListener('message', function (e) {\n    var ref = e.data;\n    var messageId = ref.messageId;\n    var action = ref.action;\n    var data = ref.data;\n\n    try {\n      // Module registration\n      if (action === 'registerModule') {\n        registerModule(data, function (result) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: {\n                isCallable: typeof result === 'function'\n              }\n            });\n          }\n        });\n      } // Invocation\n\n\n      if (action === 'callModule') {\n        callModule(data, function (result, transferables) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: result\n            }, transferables || undefined);\n          }\n        });\n      }\n    } catch (err) {\n      postMessage({\n        messageId: messageId,\n        success: false,\n        error: err.stack\n      });\n    }\n  });\n}\n/**\n * Fallback for `defineWorkerModule` that behaves identically but runs in the main\n * thread, for when the execution environment doesn't support web workers or they\n * are disallowed due to e.g. CSP security restrictions.\n */\n\n\nfunction defineMainThreadModule(options) {\n  var moduleFunc = function () {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    return moduleFunc._getInitResult().then(function (initResult) {\n      if (typeof initResult === 'function') {\n        return initResult.apply(void 0, args);\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function');\n      }\n    });\n  };\n\n  moduleFunc._getInitResult = function () {\n    // We can ignore getTransferables in main thread. TODO workerId?\n    var dependencies = options.dependencies;\n    var init = options.init; // Resolve dependencies\n\n    dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) {\n      return dep && dep._getInitResult ? dep._getInitResult() : dep;\n    }) : []; // Invoke init with the resolved dependencies\n\n    var initPromise = Promise.all(dependencies).then(function (deps) {\n      return init.apply(null, deps);\n    }); // Cache the resolved promise for subsequent calls\n\n    moduleFunc._getInitResult = function () {\n      return initPromise;\n    };\n\n    return initPromise;\n  };\n\n  return moduleFunc;\n}\n\nvar supportsWorkers = function () {\n  var supported = false; // Only attempt worker initialization in browsers; elsewhere it would just be\n  // noise e.g. loading into a Node environment for SSR.\n\n  if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\n    try {\n      // TODO additional checks for things like importScripts within the worker?\n      //  Would need to be an async check.\n      var worker = new Worker(URL.createObjectURL(new Blob([''], {\n        type: 'application/javascript'\n      })));\n      worker.terminate();\n      supported = true;\n    } catch (err) {\n      if (typeof process !== 'undefined' && process.env.NODE_ENV === 'test') ;else {\n        console.log(\"Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [\" + err.message + \"]\");\n      }\n    }\n  } // Cached result\n\n\n  supportsWorkers = function () {\n    return supported;\n  };\n\n  return supported;\n};\n\nvar _workerModuleId = 0;\nvar _messageId = 0;\nvar _allowInitAsString = false;\nvar workers = Object.create(null);\nvar registeredModules = Object.create(null); //workerId -> Set<unregisterFn>\n\nvar openRequests = Object.create(null);\n/**\n * Define a module of code that will be executed with a web worker. This provides a simple\n * interface for moving chunks of logic off the main thread, and managing their dependencies\n * among one another.\n *\n * @param {object} options\n * @param {function} options.init\n * @param {array} [options.dependencies]\n * @param {function} [options.getTransferables]\n * @param {string} [options.name]\n * @param {string} [options.workerId]\n * @return {function(...[*]): {then}}\n */\n\nfunction defineWorkerModule(options) {\n  if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\n    throw new Error('requires `options.init` function');\n  }\n\n  var dependencies = options.dependencies;\n  var init = options.init;\n  var getTransferables = options.getTransferables;\n  var workerId = options.workerId;\n\n  if (!supportsWorkers()) {\n    return defineMainThreadModule(options);\n  }\n\n  if (workerId == null) {\n    workerId = '#default';\n  }\n\n  var id = \"workerModule\" + ++_workerModuleId;\n  var name = options.name || id;\n  var registrationPromise = null;\n  dependencies = dependencies && dependencies.map(function (dep) {\n    // Wrap raw functions as worker modules with no dependencies\n    if (typeof dep === 'function' && !dep.workerModuleData) {\n      _allowInitAsString = true;\n      dep = defineWorkerModule({\n        workerId: workerId,\n        name: \"<\" + name + \"> function dependency: \" + dep.name,\n        init: \"function(){return (\\n\" + stringifyFunction(dep) + \"\\n)}\"\n      });\n      _allowInitAsString = false;\n    } // Grab postable data for worker modules\n\n\n    if (dep && dep.workerModuleData) {\n      dep = dep.workerModuleData;\n    }\n\n    return dep;\n  });\n\n  function moduleFunc() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len]; // Register this module if needed\n\n\n    if (!registrationPromise) {\n      registrationPromise = callWorker(workerId, 'registerModule', moduleFunc.workerModuleData);\n\n      var unregister = function () {\n        registrationPromise = null;\n        registeredModules[workerId].delete(unregister);\n      };\n\n      (registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);\n    } // Invoke the module, returning a promise\n\n\n    return registrationPromise.then(function (ref) {\n      var isCallable = ref.isCallable;\n\n      if (isCallable) {\n        return callWorker(workerId, 'callModule', {\n          id: id,\n          args: args\n        });\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function');\n      }\n    });\n  }\n\n  moduleFunc.workerModuleData = {\n    isWorkerModule: true,\n    id: id,\n    name: name,\n    dependencies: dependencies,\n    init: stringifyFunction(init),\n    getTransferables: getTransferables && stringifyFunction(getTransferables)\n  };\n  return moduleFunc;\n}\n/**\n * Terminate an active Worker by a workerId that was passed to defineWorkerModule.\n * This only terminates the Worker itself; the worker module will remain available\n * and if you call it again its Worker will be respawned.\n * @param {string} workerId\n */\n\n\nfunction terminateWorker(workerId) {\n  // Unregister all modules that were registered in that worker\n  if (registeredModules[workerId]) {\n    registeredModules[workerId].forEach(function (unregister) {\n      unregister();\n    });\n  } // Terminate the Worker object\n\n\n  if (workers[workerId]) {\n    workers[workerId].terminate();\n    delete workers[workerId];\n  }\n}\n/**\n * Stringifies a function into a form that can be deserialized in the worker\n * @param fn\n */\n\n\nfunction stringifyFunction(fn) {\n  var str = fn.toString(); // If it was defined in object method/property format, it needs to be modified\n\n  if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n    str = 'function ' + str;\n  }\n\n  return str;\n}\n\nfunction getWorker(workerId) {\n  var worker = workers[workerId];\n\n  if (!worker) {\n    // Bootstrap the worker's content\n    var bootstrap = stringifyFunction(workerBootstrap); // Create the worker from the bootstrap function content\n\n    worker = workers[workerId] = new Worker(URL.createObjectURL(new Blob([\"/** Worker Module Bootstrap: \" + workerId.replace(/\\*/g, '') + \" **/\\n\\n;(\" + bootstrap + \")()\"], {\n      type: 'application/javascript'\n    }))); // Single handler for response messages from the worker\n\n    worker.onmessage = function (e) {\n      var response = e.data;\n      var msgId = response.messageId;\n      var callback = openRequests[msgId];\n\n      if (!callback) {\n        throw new Error('WorkerModule response with empty or unknown messageId');\n      }\n\n      delete openRequests[msgId];\n      callback(response);\n    };\n  }\n\n  return worker;\n} // Issue a call to the worker with a callback to handle the response\n\n\nfunction callWorker(workerId, action, data) {\n  return new Promise(function (resolve, reject) {\n    var messageId = ++_messageId;\n\n    openRequests[messageId] = function (response) {\n      if (response.success) {\n        resolve(response.result);\n      } else {\n        reject(new Error(\"Error in worker \" + action + \" call: \" + response.error));\n      }\n    };\n\n    getWorker(workerId).postMessage({\n      messageId: messageId,\n      action: action,\n      data: data\n    });\n  });\n}\n\nexport { defineWorkerModule, stringifyFunction, terminateWorker };","map":{"version":3,"sources":["/Users/osamakhan/Desktop/dev/Apple-Animated-React-Clone/node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js"],"names":["workerBootstrap","modules","Object","create","registerModule","ref","callback","id","name","dependencies","init","getTransferables","map","dep","isWorkerModule","depResult","Error","value","rehydrate","apply","console","error","err","noLog","callModule","ref$1","args","result","then","handleResult","rej","tx","Array","isArray","length","undefined","str","self","troikaDefine","r","url","URL","createObjectURL","Blob","replace","type","importScripts","revokeObjectURL","addEventListener","e","data","messageId","action","postMessage","success","message","isCallable","transferables","stack","defineMainThreadModule","options","moduleFunc","len","arguments","_getInitResult","initResult","initPromise","Promise","all","deps","supportsWorkers","supported","window","document","worker","Worker","terminate","process","env","NODE_ENV","log","_workerModuleId","_messageId","_allowInitAsString","workers","registeredModules","openRequests","defineWorkerModule","workerId","registrationPromise","workerModuleData","stringifyFunction","callWorker","unregister","delete","Set","add","terminateWorker","forEach","fn","toString","test","getWorker","bootstrap","onmessage","response","msgId","resolve","reject"],"mappings":"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","sourcesContent":["/**\n * Main content for the worker that handles the loading and execution of\n * modules within it.\n */\nfunction workerBootstrap() {\n  var modules = Object.create(null);\n\n  // Handle messages for registering a module\n  function registerModule(ref, callback) {\n    var id = ref.id;\n    var name = ref.name;\n    var dependencies = ref.dependencies; if ( dependencies === void 0 ) dependencies = [];\n    var init = ref.init; if ( init === void 0 ) init = function(){};\n    var getTransferables = ref.getTransferables; if ( getTransferables === void 0 ) getTransferables = null;\n\n    // Only register once\n    if (modules[id]) { return }\n\n    try {\n      // If any dependencies are modules, ensure they're registered and grab their value\n      dependencies = dependencies.map(function (dep) {\n        if (dep && dep.isWorkerModule) {\n          registerModule(dep, function (depResult) {\n            if (depResult instanceof Error) { throw depResult }\n          });\n          dep = modules[dep.id].value;\n        }\n        return dep\n      });\n\n      // Rehydrate functions\n      init = rehydrate((\"<\" + name + \">.init\"), init);\n      if (getTransferables) {\n        getTransferables = rehydrate((\"<\" + name + \">.getTransferables\"), getTransferables);\n      }\n\n      // Initialize the module and store its value\n      var value = null;\n      if (typeof init === 'function') {\n        value = init.apply(void 0, dependencies);\n      } else {\n        console.error('worker module init function failed to rehydrate');\n      }\n      modules[id] = {\n        id: id,\n        value: value,\n        getTransferables: getTransferables\n      };\n      callback(value);\n    } catch(err) {\n      if (!(err && err.noLog)) {\n        console.error(err);\n      }\n      callback(err);\n    }\n  }\n\n  // Handle messages for calling a registered module's result function\n  function callModule(ref, callback) {\n    var ref$1;\n\n    var id = ref.id;\n    var args = ref.args;\n    if (!modules[id] || typeof modules[id].value !== 'function') {\n      callback(new Error((\"Worker module \" + id + \": not found or its 'init' did not return a function\")));\n    }\n    try {\n      var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n      if (result && typeof result.then === 'function') {\n        result.then(handleResult, function (rej) { return callback(rej instanceof Error ? rej : new Error('' + rej)); });\n      } else {\n        handleResult(result);\n      }\n    } catch(err) {\n      callback(err);\n    }\n    function handleResult(result) {\n      try {\n        var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n        if (!tx || !Array.isArray(tx) || !tx.length) {\n          tx = undefined; //postMessage is very picky about not passing null or empty transferables\n        }\n        callback(result, tx);\n      } catch(err) {\n        console.error(err);\n        callback(err);\n      }\n    }\n  }\n\n  function rehydrate(name, str) {\n    var result = void 0;\n    self.troikaDefine = function (r) { return result = r; };\n    var url = URL.createObjectURL(\n      new Blob(\n        [(\"/** \" + (name.replace(/\\*/g, '')) + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\")],\n        {type: 'application/javascript'}\n      )\n    );\n    try {\n      importScripts(url);\n    } catch(err) {\n      console.error(err);\n    }\n    URL.revokeObjectURL(url);\n    delete self.troikaDefine;\n    return result\n  }\n\n  // Handler for all messages within the worker\n  self.addEventListener('message', function (e) {\n    var ref = e.data;\n    var messageId = ref.messageId;\n    var action = ref.action;\n    var data = ref.data;\n    try {\n      // Module registration\n      if (action === 'registerModule') {\n        registerModule(data, function (result) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: {isCallable: typeof result === 'function'}\n            });\n          }\n        });\n      }\n      // Invocation\n      if (action === 'callModule') {\n        callModule(data, function (result, transferables) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: result\n            }, transferables || undefined);\n          }\n        });\n      }\n    } catch(err) {\n      postMessage({\n        messageId: messageId,\n        success: false,\n        error: err.stack\n      });\n    }\n  });\n}\n\n/**\n * Fallback for `defineWorkerModule` that behaves identically but runs in the main\n * thread, for when the execution environment doesn't support web workers or they\n * are disallowed due to e.g. CSP security restrictions.\n */\nfunction defineMainThreadModule(options) {\n  var moduleFunc = function() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return moduleFunc._getInitResult().then(function (initResult) {\n      if (typeof initResult === 'function') {\n        return initResult.apply(void 0, args)\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function')\n      }\n    })\n  };\n  moduleFunc._getInitResult = function() {\n    // We can ignore getTransferables in main thread. TODO workerId?\n    var dependencies = options.dependencies;\n    var init = options.init;\n\n    // Resolve dependencies\n    dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) { return dep && dep._getInitResult ? dep._getInitResult() : dep; }\n    ) : [];\n\n    // Invoke init with the resolved dependencies\n    var initPromise = Promise.all(dependencies).then(function (deps) {\n      return init.apply(null, deps)\n    });\n\n    // Cache the resolved promise for subsequent calls\n    moduleFunc._getInitResult = function () { return initPromise; };\n\n    return initPromise\n  };\n  return moduleFunc\n}\n\nvar supportsWorkers = function () {\n  var supported = false;\n\n  // Only attempt worker initialization in browsers; elsewhere it would just be\n  // noise e.g. loading into a Node environment for SSR.\n  if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\n    try {\n      // TODO additional checks for things like importScripts within the worker?\n      //  Would need to be an async check.\n      var worker = new Worker(\n        URL.createObjectURL(new Blob([''], { type: 'application/javascript' }))\n      );\n      worker.terminate();\n      supported = true;\n    } catch (err) {\n      if (typeof process !== 'undefined' && process.env.NODE_ENV === 'test') ; else {\n        console.log(\n          (\"Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [\" + (err.message) + \"]\")\n        );\n      }\n    }\n  }\n\n  // Cached result\n  supportsWorkers = function () { return supported; };\n  return supported\n};\n\nvar _workerModuleId = 0;\nvar _messageId = 0;\nvar _allowInitAsString = false;\nvar workers = Object.create(null);\nvar registeredModules = Object.create(null); //workerId -> Set<unregisterFn>\nvar openRequests = Object.create(null);\n\n\n/**\n * Define a module of code that will be executed with a web worker. This provides a simple\n * interface for moving chunks of logic off the main thread, and managing their dependencies\n * among one another.\n *\n * @param {object} options\n * @param {function} options.init\n * @param {array} [options.dependencies]\n * @param {function} [options.getTransferables]\n * @param {string} [options.name]\n * @param {string} [options.workerId]\n * @return {function(...[*]): {then}}\n */\nfunction defineWorkerModule(options) {\n  if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\n    throw new Error('requires `options.init` function')\n  }\n  var dependencies = options.dependencies;\n  var init = options.init;\n  var getTransferables = options.getTransferables;\n  var workerId = options.workerId;\n\n  if (!supportsWorkers()) {\n    return defineMainThreadModule(options)\n  }\n\n  if (workerId == null) {\n    workerId = '#default';\n  }\n  var id = \"workerModule\" + (++_workerModuleId);\n  var name = options.name || id;\n  var registrationPromise = null;\n\n  dependencies = dependencies && dependencies.map(function (dep) {\n    // Wrap raw functions as worker modules with no dependencies\n    if (typeof dep === 'function' && !dep.workerModuleData) {\n      _allowInitAsString = true;\n      dep = defineWorkerModule({\n        workerId: workerId,\n        name: (\"<\" + name + \"> function dependency: \" + (dep.name)),\n        init: (\"function(){return (\\n\" + (stringifyFunction(dep)) + \"\\n)}\")\n      });\n      _allowInitAsString = false;\n    }\n    // Grab postable data for worker modules\n    if (dep && dep.workerModuleData) {\n      dep = dep.workerModuleData;\n    }\n    return dep\n  });\n\n  function moduleFunc() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    // Register this module if needed\n    if (!registrationPromise) {\n      registrationPromise = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);\n      var unregister = function () {\n        registrationPromise = null;\n        registeredModules[workerId].delete(unregister);\n      }\n      ;(registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);\n    }\n\n    // Invoke the module, returning a promise\n    return registrationPromise.then(function (ref) {\n      var isCallable = ref.isCallable;\n\n      if (isCallable) {\n        return callWorker(workerId,'callModule', {id: id, args: args})\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function')\n      }\n    })\n  }\n  moduleFunc.workerModuleData = {\n    isWorkerModule: true,\n    id: id,\n    name: name,\n    dependencies: dependencies,\n    init: stringifyFunction(init),\n    getTransferables: getTransferables && stringifyFunction(getTransferables)\n  };\n  return moduleFunc\n}\n\n/**\n * Terminate an active Worker by a workerId that was passed to defineWorkerModule.\n * This only terminates the Worker itself; the worker module will remain available\n * and if you call it again its Worker will be respawned.\n * @param {string} workerId\n */\nfunction terminateWorker(workerId) {\n  // Unregister all modules that were registered in that worker\n  if (registeredModules[workerId]) {\n    registeredModules[workerId].forEach(function (unregister) {\n      unregister();\n    });\n  }\n  // Terminate the Worker object\n  if (workers[workerId]) {\n    workers[workerId].terminate();\n    delete workers[workerId];\n  }\n}\n\n/**\n * Stringifies a function into a form that can be deserialized in the worker\n * @param fn\n */\nfunction stringifyFunction(fn) {\n  var str = fn.toString();\n  // If it was defined in object method/property format, it needs to be modified\n  if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n    str = 'function ' + str;\n  }\n  return str\n}\n\n\nfunction getWorker(workerId) {\n  var worker = workers[workerId];\n  if (!worker) {\n    // Bootstrap the worker's content\n    var bootstrap = stringifyFunction(workerBootstrap);\n\n    // Create the worker from the bootstrap function content\n    worker = workers[workerId] = new Worker(\n      URL.createObjectURL(\n        new Blob(\n          [(\"/** Worker Module Bootstrap: \" + (workerId.replace(/\\*/g, '')) + \" **/\\n\\n;(\" + bootstrap + \")()\")],\n          {type: 'application/javascript'}\n        )\n      )\n    );\n\n    // Single handler for response messages from the worker\n    worker.onmessage = function (e) {\n      var response = e.data;\n      var msgId = response.messageId;\n      var callback = openRequests[msgId];\n      if (!callback) {\n        throw new Error('WorkerModule response with empty or unknown messageId')\n      }\n      delete openRequests[msgId];\n      callback(response);\n    };\n  }\n  return worker\n}\n\n// Issue a call to the worker with a callback to handle the response\nfunction callWorker(workerId, action, data) {\n  return new Promise(function (resolve, reject) {\n    var messageId = ++_messageId;\n    openRequests[messageId] = function (response) {\n      if (response.success) {\n        resolve(response.result);\n      } else {\n        reject(new Error((\"Error in worker \" + action + \" call: \" + (response.error))));\n      }\n    };\n    getWorker(workerId).postMessage({\n      messageId: messageId,\n      action: action,\n      data: data\n    });\n  })\n}\n\nexport { defineWorkerModule, stringifyFunction, terminateWorker };\n"]},"metadata":{},"sourceType":"module"}
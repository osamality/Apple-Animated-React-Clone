{"ast":null,"code":"import { Vector3 } from 'three';\n/**\n * Generates 2D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/sketch/15493\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, -Z.\n * @param v1         Corner index -X, +Z.\n * @param v2         Corner index +X, +Z.\n * @param v3         Corner index +X, -Z.\n */\n\nconst hilbert2D = (center = new Vector3(0, 0, 0), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3) => {\n  // Default Vars\n  const half = size / 2;\n  const vec_s = [new Vector3(center.x - half, center.y, center.z - half), new Vector3(center.x - half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z - half)];\n  const vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]]; // Recurse iterations\n\n  if (0 <= --iterations) {\n    const tmp = [];\n    Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v1, v0, v3)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n\n  return vec;\n};\n/**\n * Generates 3D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/visuals/?visualID=15599\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, +Y, -Z.\n * @param v1         Corner index -X, +Y, +Z.\n * @param v2         Corner index -X, -Y, +Z.\n * @param v3         Corner index -X, -Y, -Z.\n * @param v4         Corner index +X, -Y, -Z.\n * @param v5         Corner index +X, -Y, +Z.\n * @param v6         Corner index +X, +Y, +Z.\n * @param v7         Corner index +X, +Y, -Z.\n */\n\n\nconst hilbert3D = (center = new Vector3(0, 0, 0), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3, v4 = 4, v5 = 5, v6 = 6, v7 = 7) => {\n  // Default Vars\n  const half = size / 2;\n  const vec_s = [new Vector3(center.x - half, center.y + half, center.z - half), new Vector3(center.x - half, center.y + half, center.z + half), new Vector3(center.x - half, center.y - half, center.z + half), new Vector3(center.x - half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z + half), new Vector3(center.x + half, center.y + half, center.z + half), new Vector3(center.x + half, center.y + half, center.z - half)];\n  const vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]]; // Recurse iterations\n\n  if (--iterations >= 0) {\n    const tmp = [];\n    Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n\n  return vec;\n};\n/**\n * Generates a Gosper curve (lying in the XY plane)\n *\n * https://gist.github.com/nitaku/6521802\n *\n * @param size The size of a single gosper island.\n */\n\n\nconst gosper = (size = 1) => {\n  function fractalize(config) {\n    let output = '';\n    let input = config.axiom;\n\n    for (let i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {\n      output = '';\n\n      for (let j = 0, jl = input.length; j < jl; j++) {\n        const char = input[j];\n\n        if (char in config.rules) {\n          output += config.rules[char];\n        } else {\n          output += char;\n        }\n      }\n\n      input = output;\n    }\n\n    return output;\n  }\n\n  function toPoints(config) {\n    let currX = 0;\n    let currY = 0;\n    let angle = 0;\n    const path = [0, 0, 0];\n    const fractal = config.fractal;\n\n    for (let i = 0, l = fractal.length; i < l; i++) {\n      const char = fractal[i];\n\n      if (char === '+') {\n        angle += config.angle;\n      } else if (char === '-') {\n        angle -= config.angle;\n      } else if (char === 'F') {\n        currX += config.size * Math.cos(angle);\n        currY += -config.size * Math.sin(angle);\n        path.push(currX, currY, 0);\n      }\n    }\n\n    return path;\n  } //\n\n\n  const gosper = fractalize({\n    axiom: 'A',\n    steps: 4,\n    rules: {\n      A: 'A+BF++BF-FA--FAFA-BF+',\n      B: '-FA+BFBF++BF+FA--FA-B'\n    }\n  });\n  const points = toPoints({\n    fractal: gosper,\n    size: size,\n    angle: Math.PI / 3 // 60 degrees\n\n  });\n  return points;\n};\n\nconst GeometryUtils = {\n  hilbert3D,\n  gosper,\n  hilbert2D\n};\nexport { GeometryUtils };","map":{"version":3,"sources":["/Users/osamakhan/Desktop/dev/Apple-Animated-React-Clone/node_modules/three-stdlib/utils/GeometryUtils.js"],"names":["Vector3","hilbert2D","center","size","iterations","v0","v1","v2","v3","half","vec_s","x","y","z","vec","tmp","Array","prototype","push","apply","hilbert3D","v4","v5","v6","v7","gosper","fractalize","config","output","input","axiom","i","il","steps","j","jl","length","char","rules","toPoints","currX","currY","angle","path","fractal","l","Math","cos","sin","A","B","points","PI","GeometryUtils"],"mappings":"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","sourcesContent":["import { Vector3 } from 'three';\n\n/**\n * Generates 2D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/sketch/15493\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, -Z.\n * @param v1         Corner index -X, +Z.\n * @param v2         Corner index +X, +Z.\n * @param v3         Corner index +X, -Z.\n */\n\nconst hilbert2D = (center = new Vector3(0, 0, 0), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3) => {\n  // Default Vars\n  const half = size / 2;\n  const vec_s = [new Vector3(center.x - half, center.y, center.z - half), new Vector3(center.x - half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z - half)];\n  const vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]]; // Recurse iterations\n\n  if (0 <= --iterations) {\n    const tmp = [];\n    Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v1, v0, v3)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n\n  return vec;\n};\n/**\n * Generates 3D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/visuals/?visualID=15599\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, +Y, -Z.\n * @param v1         Corner index -X, +Y, +Z.\n * @param v2         Corner index -X, -Y, +Z.\n * @param v3         Corner index -X, -Y, -Z.\n * @param v4         Corner index +X, -Y, -Z.\n * @param v5         Corner index +X, -Y, +Z.\n * @param v6         Corner index +X, +Y, +Z.\n * @param v7         Corner index +X, +Y, -Z.\n */\n\n\nconst hilbert3D = (center = new Vector3(0, 0, 0), size = 10, iterations = 1, v0 = 0, v1 = 1, v2 = 2, v3 = 3, v4 = 4, v5 = 5, v6 = 6, v7 = 7) => {\n  // Default Vars\n  const half = size / 2;\n  const vec_s = [new Vector3(center.x - half, center.y + half, center.z - half), new Vector3(center.x - half, center.y + half, center.z + half), new Vector3(center.x - half, center.y - half, center.z + half), new Vector3(center.x - half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z + half), new Vector3(center.x + half, center.y + half, center.z + half), new Vector3(center.x + half, center.y + half, center.z - half)];\n  const vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]]; // Recurse iterations\n\n  if (--iterations >= 0) {\n    const tmp = [];\n    Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n\n  return vec;\n};\n/**\n * Generates a Gosper curve (lying in the XY plane)\n *\n * https://gist.github.com/nitaku/6521802\n *\n * @param size The size of a single gosper island.\n */\n\n\nconst gosper = (size = 1) => {\n  function fractalize(config) {\n    let output = '';\n    let input = config.axiom;\n\n    for (let i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {\n      output = '';\n\n      for (let j = 0, jl = input.length; j < jl; j++) {\n        const char = input[j];\n\n        if (char in config.rules) {\n          output += config.rules[char];\n        } else {\n          output += char;\n        }\n      }\n\n      input = output;\n    }\n\n    return output;\n  }\n\n  function toPoints(config) {\n    let currX = 0;\n    let currY = 0;\n    let angle = 0;\n    const path = [0, 0, 0];\n    const fractal = config.fractal;\n\n    for (let i = 0, l = fractal.length; i < l; i++) {\n      const char = fractal[i];\n\n      if (char === '+') {\n        angle += config.angle;\n      } else if (char === '-') {\n        angle -= config.angle;\n      } else if (char === 'F') {\n        currX += config.size * Math.cos(angle);\n        currY += -config.size * Math.sin(angle);\n        path.push(currX, currY, 0);\n      }\n    }\n\n    return path;\n  } //\n\n\n  const gosper = fractalize({\n    axiom: 'A',\n    steps: 4,\n    rules: {\n      A: 'A+BF++BF-FA--FAFA-BF+',\n      B: '-FA+BFBF++BF+FA--FA-B'\n    }\n  });\n  const points = toPoints({\n    fractal: gosper,\n    size: size,\n    angle: Math.PI / 3 // 60 degrees\n\n  });\n  return points;\n};\n\nconst GeometryUtils = {\n  hilbert3D,\n  gosper,\n  hilbert2D\n};\n\nexport { GeometryUtils };\n"]},"metadata":{},"sourceType":"module"}
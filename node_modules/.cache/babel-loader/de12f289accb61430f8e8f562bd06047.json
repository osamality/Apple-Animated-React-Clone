{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\n\nconst _positionVector = /*@__PURE__*/new Vector3();\n\nconst _normalVector = /*@__PURE__*/new Vector3();\n\nconst _tangentVector = /*@__PURE__*/new Vector3();\n\nconst _tangentVector4 = /*@__PURE__*/new Vector4();\n\nconst _morphVector = /*@__PURE__*/new Vector3();\n\nconst _temp = /*@__PURE__*/new Vector3();\n\nconst _skinIndex = /*@__PURE__*/new Vector4();\n\nconst _skinWeight = /*@__PURE__*/new Vector4();\n\nconst _matrix = /*@__PURE__*/new Matrix4();\n\nconst _boneMatrix = /*@__PURE__*/new Matrix4(); // Confirms that the two provided attributes are compatible\n\n\nfunction validateAttributes(attr1, attr2) {\n  if (!attr1 && !attr2) {\n    return;\n  }\n\n  const sameCount = attr1.count === attr2.count;\n  const sameNormalized = attr1.normalized === attr2.normalized;\n  const sameType = attr1.array.constructor === attr2.array.constructor;\n  const sameItemSize = attr1.itemSize === attr2.itemSize;\n\n  if (!sameCount || !sameNormalized || !sameType || !sameItemSize) {\n    throw new Error();\n  }\n} // Clones the given attribute with a new compatible buffer attribute but no data\n\n\nfunction createAttributeClone(attr, countOverride = null) {\n  const cons = attr.array.constructor;\n  const normalized = attr.normalized;\n  const itemSize = attr.itemSize;\n  const count = countOverride === null ? attr.count : countOverride;\n  return new BufferAttribute(new cons(itemSize * count), itemSize, normalized);\n} // target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\n\n\nfunction copyAttributeContents(attr, target, targetOffset = 0) {\n  if (attr.isInterleavedBufferAttribute) {\n    const itemSize = attr.itemSize;\n\n    for (let i = 0, l = attr.count; i < l; i++) {\n      const io = i + targetOffset;\n      target.setX(io, attr.getX(i));\n      if (itemSize >= 2) target.setY(io, attr.getY(i));\n      if (itemSize >= 3) target.setZ(io, attr.getZ(i));\n      if (itemSize >= 4) target.setW(io, attr.getW(i));\n    }\n  } else {\n    const array = target.array;\n    const cons = array.constructor;\n    const byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n    const temp = new cons(array.buffer, byteOffset, attr.array.length);\n    temp.set(attr.array);\n  }\n} // Adds the \"matrix\" multiplied by \"scale\" to \"target\"\n\n\nfunction addScaledMatrix(target, matrix, scale) {\n  const targetArray = target.elements;\n  const matrixArray = matrix.elements;\n\n  for (let i = 0, l = matrixArray.length; i < l; i++) {\n    targetArray[i] += matrixArray[i] * scale;\n  }\n} // A version of \"SkinnedMesh.boneTransform\" for normals\n\n\nfunction boneNormalTransform(mesh, index, target) {\n  const skeleton = mesh.skeleton;\n  const geometry = mesh.geometry;\n  const bones = skeleton.bones;\n  const boneInverses = skeleton.boneInverses;\n\n  _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n\n  _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n\n  _matrix.elements.fill(0);\n\n  for (let i = 0; i < 4; i++) {\n    const weight = _skinWeight.getComponent(i);\n\n    if (weight !== 0) {\n      const boneIndex = _skinIndex.getComponent(i);\n\n      _boneMatrix.multiplyMatrices(bones[boneIndex].matrixWorld, boneInverses[boneIndex]);\n\n      addScaledMatrix(_matrix, _boneMatrix, weight);\n    }\n  }\n\n  _matrix.multiply(mesh.bindMatrix).premultiply(mesh.bindMatrixInverse);\n\n  target.transformDirection(_matrix);\n  return target;\n} // Applies the morph target data to the target vector\n\n\nfunction applyMorphTarget(morphData, morphInfluences, morphTargetsRelative, i, target) {\n  _morphVector.set(0, 0, 0);\n\n  for (let j = 0, jl = morphData.length; j < jl; j++) {\n    const influence = morphInfluences[j];\n    const morphAttribute = morphData[j];\n    if (influence === 0) continue;\n\n    _temp.fromBufferAttribute(morphAttribute, i);\n\n    if (morphTargetsRelative) {\n      _morphVector.addScaledVector(_temp, influence);\n    } else {\n      _morphVector.addScaledVector(_temp.sub(target), influence);\n    }\n  }\n\n  target.add(_morphVector);\n} // Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\n\n\nfunction mergeBufferGeometries(geometries, options = {\n  useGroups: false,\n  updateIndex: false,\n  skipAttributes: []\n}, targetGeometry = new BufferGeometry()) {\n  const isIndexed = geometries[0].index !== null;\n  const {\n    useGroups = false,\n    updateIndex = false,\n    skipAttributes = []\n  } = options;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const attributes = {};\n  let offset = 0;\n  targetGeometry.clearGroups();\n\n  for (let i = 0; i < geometries.length; ++i) {\n    const geometry = geometries[i];\n    let attributesCount = 0; // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geometry.index !== null)) {\n      throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n    } // gather attributes, exit early if they're different\n\n\n    for (const name in geometry.attributes) {\n      if (!attributesUsed.has(name)) {\n        throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = [];\n      }\n\n      attributes[name].push(geometry.attributes[name]);\n      attributesCount++;\n    } // ensure geometries have the same number of attributes\n\n\n    if (attributesCount !== attributesUsed.size) {\n      throw new Error('StaticGeometryGenerator: Make sure all geometries have the same number of attributes.');\n    }\n\n    if (useGroups) {\n      let count;\n\n      if (isIndexed) {\n        count = geometry.index.count;\n      } else if (geometry.attributes.position !== undefined) {\n        count = geometry.attributes.position.count;\n      } else {\n        throw new Error('StaticGeometryGenerator: The geometry must have either an index or a position attribute');\n      }\n\n      targetGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  } // merge indices\n\n\n  if (isIndexed) {\n    let forceUpdateIndex = false;\n\n    if (!targetGeometry.index) {\n      let indexCount = 0;\n\n      for (let i = 0; i < geometries.length; ++i) {\n        indexCount += geometries[i].index.count;\n      }\n\n      targetGeometry.setIndex(new BufferAttribute(new Uint32Array(indexCount), 1, false));\n      forceUpdateIndex = true;\n    }\n\n    if (updateIndex || forceUpdateIndex) {\n      const targetIndex = targetGeometry.index;\n      let targetOffset = 0;\n      let indexOffset = 0;\n\n      for (let i = 0; i < geometries.length; ++i) {\n        const geometry = geometries[i];\n        const index = geometry.index;\n\n        if (skipAttributes[i] !== true) {\n          for (let j = 0; j < index.count; ++j) {\n            targetIndex.setX(targetOffset, index.getX(j) + indexOffset);\n            targetOffset++;\n          }\n        }\n\n        indexOffset += geometry.attributes.position.count;\n      }\n    }\n  } // merge attributes\n\n\n  for (const name in attributes) {\n    const attrList = attributes[name];\n\n    if (!(name in targetGeometry.attributes)) {\n      let count = 0;\n\n      for (const key in attrList) {\n        count += attrList[key].count;\n      }\n\n      targetGeometry.setAttribute(name, createAttributeClone(attributes[name][0], count));\n    }\n\n    const targetAttribute = targetGeometry.attributes[name];\n    let offset = 0;\n\n    for (let i = 0, l = attrList.length; i < l; i++) {\n      const attr = attrList[i];\n\n      if (skipAttributes[i] !== true) {\n        copyAttributeContents(attr, targetAttribute, offset);\n      }\n\n      offset += attr.count;\n    }\n  }\n\n  return targetGeometry;\n}\n\nfunction checkTypedArrayEquality(a, b) {\n  if (a === null || b === null) {\n    return a === b;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n} // Checks whether the geometry changed between this and last evaluation\n\n\nclass GeometryDiff {\n  constructor(mesh) {\n    this.matrixWorld = new Matrix4();\n    this.geometryHash = null;\n    this.boneMatrices = null;\n    this.primitiveCount = -1;\n    this.mesh = mesh;\n    this.update();\n  }\n\n  update() {\n    const mesh = this.mesh;\n    const geometry = mesh.geometry;\n    const skeleton = mesh.skeleton;\n    const primitiveCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n    this.matrixWorld.copy(mesh.matrixWorld);\n    this.geometryHash = geometry.attributes.position.version;\n    this.primitiveCount = primitiveCount;\n\n    if (skeleton) {\n      // ensure the bone matrix array is updated to the appropriate length\n      if (!skeleton.boneTexture) {\n        skeleton.computeBoneTexture();\n      }\n\n      skeleton.update(); // copy data if possible otherwise clone it\n\n      const boneMatrices = skeleton.boneMatrices;\n\n      if (!this.boneMatrices || this.boneMatrices.length !== boneMatrices.length) {\n        this.boneMatrices = boneMatrices.slice();\n      } else {\n        this.boneMatrices.set(boneMatrices);\n      }\n    } else {\n      this.boneMatrices = null;\n    }\n  }\n\n  didChange() {\n    const mesh = this.mesh;\n    const geometry = mesh.geometry;\n    const primitiveCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n    const identical = this.matrixWorld.equals(mesh.matrixWorld) && this.geometryHash === geometry.attributes.position.version && checkTypedArrayEquality(mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices) && this.primitiveCount === primitiveCount;\n    return !identical;\n  }\n\n}\n\nexport class StaticGeometryGenerator {\n  constructor(meshes) {\n    if (!Array.isArray(meshes)) {\n      meshes = [meshes];\n    }\n\n    const finalMeshes = [];\n    meshes.forEach(object => {\n      object.traverseVisible(c => {\n        if (c.isMesh) {\n          finalMeshes.push(c);\n        }\n      });\n    });\n    this.meshes = finalMeshes;\n    this.useGroups = true;\n    this.applyWorldTransforms = true;\n    this.attributes = ['position', 'normal', 'color', 'tangent', 'uv', 'uv2'];\n    this._intermediateGeometry = new Array(finalMeshes.length).fill().map(() => new BufferGeometry());\n    this._diffMap = new WeakMap();\n  }\n\n  getMaterials() {\n    const materials = [];\n    this.meshes.forEach(mesh => {\n      if (Array.isArray(mesh.material)) {\n        materials.push(...mesh.material);\n      } else {\n        materials.push(mesh.material);\n      }\n    });\n    return materials;\n  }\n\n  generate(targetGeometry = new BufferGeometry()) {\n    // track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n    let skipAttributes = [];\n    const {\n      meshes,\n      useGroups,\n      _intermediateGeometry,\n      _diffMap\n    } = this;\n\n    for (let i = 0, l = meshes.length; i < l; i++) {\n      const mesh = meshes[i];\n      const geom = _intermediateGeometry[i];\n\n      const diff = _diffMap.get(mesh);\n\n      if (!diff || diff.didChange(mesh)) {\n        this._convertToStaticGeometry(mesh, geom);\n\n        skipAttributes.push(false);\n\n        if (!diff) {\n          _diffMap.set(mesh, new GeometryDiff(mesh));\n        } else {\n          diff.update();\n        }\n      } else {\n        skipAttributes.push(true);\n      }\n    }\n\n    mergeBufferGeometries(_intermediateGeometry, {\n      useGroups,\n      skipAttributes\n    }, targetGeometry);\n\n    for (const key in targetGeometry.attributes) {\n      targetGeometry.attributes[key].needsUpdate = true;\n    }\n\n    return targetGeometry;\n  }\n\n  _convertToStaticGeometry(mesh, targetGeometry = new BufferGeometry()) {\n    const geometry = mesh.geometry;\n    const applyWorldTransforms = this.applyWorldTransforms;\n    const includeNormal = this.attributes.includes('normal');\n    const includeTangent = this.attributes.includes('tangent');\n    const attributes = geometry.attributes;\n    const targetAttributes = targetGeometry.attributes; // initialize the attributes if they don't exist\n\n    if (!targetGeometry.index) {\n      targetGeometry.index = geometry.index;\n    }\n\n    if (!targetAttributes.position) {\n      targetGeometry.setAttribute('position', createAttributeClone(attributes.position));\n    }\n\n    if (includeNormal && !targetAttributes.normal && attributes.normal) {\n      targetGeometry.setAttribute('normal', createAttributeClone(attributes.normal));\n    }\n\n    if (includeTangent && !targetAttributes.tangent && attributes.tangent) {\n      targetGeometry.setAttribute('tangent', createAttributeClone(attributes.tangent));\n    } // ensure the attributes are consistent\n\n\n    validateAttributes(geometry.index, targetGeometry.index);\n    validateAttributes(attributes.position, targetAttributes.position);\n\n    if (includeNormal) {\n      validateAttributes(attributes.normal, targetAttributes.normal);\n    }\n\n    if (includeTangent) {\n      validateAttributes(attributes.tangent, targetAttributes.tangent);\n    } // generate transformed vertex attribute data\n\n\n    const position = attributes.position;\n    const normal = includeNormal ? attributes.normal : null;\n    const tangent = includeTangent ? attributes.tangent : null;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphNormal = geometry.morphAttributes.normal;\n    const morphTangent = geometry.morphAttributes.tangent;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const morphInfluences = mesh.morphTargetInfluences;\n    const normalMatrix = new Matrix3();\n    normalMatrix.getNormalMatrix(mesh.matrixWorld);\n\n    for (let i = 0, l = attributes.position.count; i < l; i++) {\n      _positionVector.fromBufferAttribute(position, i);\n\n      if (normal) {\n        _normalVector.fromBufferAttribute(normal, i);\n      }\n\n      if (tangent) {\n        _tangentVector4.fromBufferAttribute(tangent, i);\n\n        _tangentVector.fromBufferAttribute(tangent, i);\n      } // apply morph target transform\n\n\n      if (morphInfluences) {\n        if (morphPosition) {\n          applyMorphTarget(morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector);\n        }\n\n        if (morphNormal) {\n          applyMorphTarget(morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector);\n        }\n\n        if (morphTangent) {\n          applyMorphTarget(morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector);\n        }\n      } // apply bone transform\n\n\n      if (mesh.isSkinnedMesh) {\n        mesh.boneTransform(i, _positionVector);\n\n        if (normal) {\n          boneNormalTransform(mesh, i, _normalVector);\n        }\n\n        if (tangent) {\n          boneNormalTransform(mesh, i, _tangentVector);\n        }\n      } // update the vectors of the attributes\n\n\n      if (applyWorldTransforms) {\n        _positionVector.applyMatrix4(mesh.matrixWorld);\n      }\n\n      targetAttributes.position.setXYZ(i, _positionVector.x, _positionVector.y, _positionVector.z);\n\n      if (normal) {\n        if (applyWorldTransforms) {\n          _normalVector.applyNormalMatrix(normalMatrix);\n        }\n\n        targetAttributes.normal.setXYZ(i, _normalVector.x, _normalVector.y, _normalVector.z);\n      }\n\n      if (tangent) {\n        if (applyWorldTransforms) {\n          _tangentVector.transformDirection(mesh.matrixWorld);\n        }\n\n        targetAttributes.tangent.setXYZW(i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w);\n      }\n    } // copy other attributes over\n\n\n    for (const i in this.attributes) {\n      const key = this.attributes[i];\n\n      if (key === 'position' || key === 'tangent' || key === 'normal' || !(key in attributes)) {\n        continue;\n      }\n\n      if (!targetAttributes[key]) {\n        targetGeometry.setAttribute(key, createAttributeClone(attributes[key]));\n      }\n\n      validateAttributes(attributes[key], targetAttributes[key]);\n      copyAttributeContents(attributes[key], targetAttributes[key]);\n    }\n\n    return targetGeometry;\n  }\n\n}","map":{"version":3,"sources":["/Users/osamakhan/Desktop/dev/Apple-Animated-React-Clone/node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js"],"names":["BufferAttribute","BufferGeometry","Vector3","Vector4","Matrix4","Matrix3","_positionVector","_normalVector","_tangentVector","_tangentVector4","_morphVector","_temp","_skinIndex","_skinWeight","_matrix","_boneMatrix","validateAttributes","attr1","attr2","sameCount","count","sameNormalized","normalized","sameType","array","constructor","sameItemSize","itemSize","Error","createAttributeClone","attr","countOverride","cons","copyAttributeContents","target","targetOffset","isInterleavedBufferAttribute","i","l","io","setX","getX","setY","getY","setZ","getZ","setW","getW","byteOffset","BYTES_PER_ELEMENT","temp","buffer","length","set","addScaledMatrix","matrix","scale","targetArray","elements","matrixArray","boneNormalTransform","mesh","index","skeleton","geometry","bones","boneInverses","fromBufferAttribute","attributes","skinIndex","skinWeight","fill","weight","getComponent","boneIndex","multiplyMatrices","matrixWorld","multiply","bindMatrix","premultiply","bindMatrixInverse","transformDirection","applyMorphTarget","morphData","morphInfluences","morphTargetsRelative","j","jl","influence","morphAttribute","addScaledVector","sub","add","mergeBufferGeometries","geometries","options","useGroups","updateIndex","skipAttributes","targetGeometry","isIndexed","attributesUsed","Set","Object","keys","offset","clearGroups","attributesCount","name","has","undefined","push","size","position","addGroup","forceUpdateIndex","indexCount","setIndex","Uint32Array","targetIndex","indexOffset","attrList","key","setAttribute","targetAttribute","checkTypedArrayEquality","a","b","GeometryDiff","geometryHash","boneMatrices","primitiveCount","update","copy","version","boneTexture","computeBoneTexture","slice","didChange","identical","equals","StaticGeometryGenerator","meshes","Array","isArray","finalMeshes","forEach","object","traverseVisible","c","isMesh","applyWorldTransforms","_intermediateGeometry","map","_diffMap","WeakMap","getMaterials","materials","material","generate","geom","diff","get","_convertToStaticGeometry","needsUpdate","includeNormal","includes","includeTangent","targetAttributes","normal","tangent","morphPosition","morphAttributes","morphNormal","morphTangent","morphTargetInfluences","normalMatrix","getNormalMatrix","isSkinnedMesh","boneTransform","applyMatrix4","setXYZ","x","y","z","applyNormalMatrix","setXYZW","w"],"mappings":"AAAA,SAASA,eAAT,EAA0BC,cAA1B,EAA0CC,OAA1C,EAAmDC,OAAnD,EAA4DC,OAA5D,EAAqEC,OAArE,QAAoF,OAApF;;AAEA,MAAMC,eAAe,GAAG,aAAc,IAAIJ,OAAJ,EAAtC;;AACA,MAAMK,aAAa,GAAG,aAAc,IAAIL,OAAJ,EAApC;;AACA,MAAMM,cAAc,GAAG,aAAc,IAAIN,OAAJ,EAArC;;AACA,MAAMO,eAAe,GAAG,aAAc,IAAIN,OAAJ,EAAtC;;AAEA,MAAMO,YAAY,GAAG,aAAc,IAAIR,OAAJ,EAAnC;;AACA,MAAMS,KAAK,GAAG,aAAc,IAAIT,OAAJ,EAA5B;;AAEA,MAAMU,UAAU,GAAG,aAAc,IAAIT,OAAJ,EAAjC;;AACA,MAAMU,WAAW,GAAG,aAAc,IAAIV,OAAJ,EAAlC;;AACA,MAAMW,OAAO,GAAG,aAAc,IAAIV,OAAJ,EAA9B;;AACA,MAAMW,WAAW,GAAG,aAAc,IAAIX,OAAJ,EAAlC,C,CAEA;;;AACA,SAASY,kBAAT,CAA6BC,KAA7B,EAAoCC,KAApC,EAA4C;AAE3C,MAAK,CAAED,KAAF,IAAW,CAAEC,KAAlB,EAA0B;AAEzB;AAEA;;AAED,QAAMC,SAAS,GAAGF,KAAK,CAACG,KAAN,KAAgBF,KAAK,CAACE,KAAxC;AACA,QAAMC,cAAc,GAAGJ,KAAK,CAACK,UAAN,KAAqBJ,KAAK,CAACI,UAAlD;AACA,QAAMC,QAAQ,GAAGN,KAAK,CAACO,KAAN,CAAYC,WAAZ,KAA4BP,KAAK,CAACM,KAAN,CAAYC,WAAzD;AACA,QAAMC,YAAY,GAAGT,KAAK,CAACU,QAAN,KAAmBT,KAAK,CAACS,QAA9C;;AAEA,MAAK,CAAER,SAAF,IAAe,CAAEE,cAAjB,IAAmC,CAAEE,QAArC,IAAiD,CAAEG,YAAxD,EAAuE;AAEtE,UAAM,IAAIE,KAAJ,EAAN;AAEA;AAED,C,CAED;;;AACA,SAASC,oBAAT,CAA+BC,IAA/B,EAAqCC,aAAa,GAAG,IAArD,EAA4D;AAE3D,QAAMC,IAAI,GAAGF,IAAI,CAACN,KAAL,CAAWC,WAAxB;AACA,QAAMH,UAAU,GAAGQ,IAAI,CAACR,UAAxB;AACA,QAAMK,QAAQ,GAAGG,IAAI,CAACH,QAAtB;AACA,QAAMP,KAAK,GAAGW,aAAa,KAAK,IAAlB,GAAyBD,IAAI,CAACV,KAA9B,GAAsCW,aAApD;AAEA,SAAO,IAAI/B,eAAJ,CAAqB,IAAIgC,IAAJ,CAAUL,QAAQ,GAAGP,KAArB,CAArB,EAAmDO,QAAnD,EAA6DL,UAA7D,CAAP;AAEA,C,CAED;AACA;;;AACA,SAASW,qBAAT,CAAgCH,IAAhC,EAAsCI,MAAtC,EAA8CC,YAAY,GAAG,CAA7D,EAAiE;AAEhE,MAAKL,IAAI,CAACM,4BAAV,EAAyC;AAExC,UAAMT,QAAQ,GAAGG,IAAI,CAACH,QAAtB;;AACA,SAAM,IAAIU,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGR,IAAI,CAACV,KAA1B,EAAiCiB,CAAC,GAAGC,CAArC,EAAwCD,CAAC,EAAzC,EAA+C;AAE9C,YAAME,EAAE,GAAGF,CAAC,GAAGF,YAAf;AACAD,MAAAA,MAAM,CAACM,IAAP,CAAaD,EAAb,EAAiBT,IAAI,CAACW,IAAL,CAAWJ,CAAX,CAAjB;AACA,UAAKV,QAAQ,IAAI,CAAjB,EAAqBO,MAAM,CAACQ,IAAP,CAAaH,EAAb,EAAiBT,IAAI,CAACa,IAAL,CAAWN,CAAX,CAAjB;AACrB,UAAKV,QAAQ,IAAI,CAAjB,EAAqBO,MAAM,CAACU,IAAP,CAAaL,EAAb,EAAiBT,IAAI,CAACe,IAAL,CAAWR,CAAX,CAAjB;AACrB,UAAKV,QAAQ,IAAI,CAAjB,EAAqBO,MAAM,CAACY,IAAP,CAAaP,EAAb,EAAiBT,IAAI,CAACiB,IAAL,CAAWV,CAAX,CAAjB;AAErB;AAED,GAbD,MAaO;AAEN,UAAMb,KAAK,GAAGU,MAAM,CAACV,KAArB;AACA,UAAMQ,IAAI,GAAGR,KAAK,CAACC,WAAnB;AACA,UAAMuB,UAAU,GAAGxB,KAAK,CAACyB,iBAAN,GAA0BnB,IAAI,CAACH,QAA/B,GAA0CQ,YAA7D;AACA,UAAMe,IAAI,GAAG,IAAIlB,IAAJ,CAAUR,KAAK,CAAC2B,MAAhB,EAAwBH,UAAxB,EAAoClB,IAAI,CAACN,KAAL,CAAW4B,MAA/C,CAAb;AACAF,IAAAA,IAAI,CAACG,GAAL,CAAUvB,IAAI,CAACN,KAAf;AAEA;AAED,C,CAED;;;AACA,SAAS8B,eAAT,CAA0BpB,MAA1B,EAAkCqB,MAAlC,EAA0CC,KAA1C,EAAkD;AAEjD,QAAMC,WAAW,GAAGvB,MAAM,CAACwB,QAA3B;AACA,QAAMC,WAAW,GAAGJ,MAAM,CAACG,QAA3B;;AACA,OAAM,IAAIrB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGqB,WAAW,CAACP,MAAjC,EAAyCf,CAAC,GAAGC,CAA7C,EAAgDD,CAAC,EAAjD,EAAuD;AAEtDoB,IAAAA,WAAW,CAAEpB,CAAF,CAAX,IAAoBsB,WAAW,CAAEtB,CAAF,CAAX,GAAmBmB,KAAvC;AAEA;AAED,C,CAED;;;AACA,SAASI,mBAAT,CAA8BC,IAA9B,EAAoCC,KAApC,EAA2C5B,MAA3C,EAAoD;AAEnD,QAAM6B,QAAQ,GAAGF,IAAI,CAACE,QAAtB;AACA,QAAMC,QAAQ,GAAGH,IAAI,CAACG,QAAtB;AACA,QAAMC,KAAK,GAAGF,QAAQ,CAACE,KAAvB;AACA,QAAMC,YAAY,GAAGH,QAAQ,CAACG,YAA9B;;AAEAtD,EAAAA,UAAU,CAACuD,mBAAX,CAAgCH,QAAQ,CAACI,UAAT,CAAoBC,SAApD,EAA+DP,KAA/D;;AACAjD,EAAAA,WAAW,CAACsD,mBAAZ,CAAiCH,QAAQ,CAACI,UAAT,CAAoBE,UAArD,EAAiER,KAAjE;;AAEAhD,EAAAA,OAAO,CAAC4C,QAAR,CAAiBa,IAAjB,CAAuB,CAAvB;;AAEA,OAAM,IAAIlC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG,CAArB,EAAwBA,CAAC,EAAzB,EAA+B;AAE9B,UAAMmC,MAAM,GAAG3D,WAAW,CAAC4D,YAAZ,CAA0BpC,CAA1B,CAAf;;AAEA,QAAKmC,MAAM,KAAK,CAAhB,EAAoB;AAEnB,YAAME,SAAS,GAAG9D,UAAU,CAAC6D,YAAX,CAAyBpC,CAAzB,CAAlB;;AACAtB,MAAAA,WAAW,CAAC4D,gBAAZ,CAA8BV,KAAK,CAAES,SAAF,CAAL,CAAmBE,WAAjD,EAA8DV,YAAY,CAAEQ,SAAF,CAA1E;;AAEApB,MAAAA,eAAe,CAAExC,OAAF,EAAWC,WAAX,EAAwByD,MAAxB,CAAf;AAEA;AAED;;AAED1D,EAAAA,OAAO,CAAC+D,QAAR,CAAkBhB,IAAI,CAACiB,UAAvB,EAAoCC,WAApC,CAAiDlB,IAAI,CAACmB,iBAAtD;;AACA9C,EAAAA,MAAM,CAAC+C,kBAAP,CAA2BnE,OAA3B;AAEA,SAAOoB,MAAP;AAEA,C,CAED;;;AACA,SAASgD,gBAAT,CAA2BC,SAA3B,EAAsCC,eAAtC,EAAuDC,oBAAvD,EAA6EhD,CAA7E,EAAgFH,MAAhF,EAAyF;AAExFxB,EAAAA,YAAY,CAAC2C,GAAb,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB;;AACA,OAAM,IAAIiC,CAAC,GAAG,CAAR,EAAWC,EAAE,GAAGJ,SAAS,CAAC/B,MAAhC,EAAwCkC,CAAC,GAAGC,EAA5C,EAAgDD,CAAC,EAAjD,EAAuD;AAEtD,UAAME,SAAS,GAAGJ,eAAe,CAAEE,CAAF,CAAjC;AACA,UAAMG,cAAc,GAAGN,SAAS,CAAEG,CAAF,CAAhC;AAEA,QAAKE,SAAS,KAAK,CAAnB,EAAuB;;AAEvB7E,IAAAA,KAAK,CAACwD,mBAAN,CAA2BsB,cAA3B,EAA2CpD,CAA3C;;AAEA,QAAKgD,oBAAL,EAA4B;AAE3B3E,MAAAA,YAAY,CAACgF,eAAb,CAA8B/E,KAA9B,EAAqC6E,SAArC;AAEA,KAJD,MAIO;AAEN9E,MAAAA,YAAY,CAACgF,eAAb,CAA8B/E,KAAK,CAACgF,GAAN,CAAWzD,MAAX,CAA9B,EAAmDsD,SAAnD;AAEA;AAED;;AAEDtD,EAAAA,MAAM,CAAC0D,GAAP,CAAYlF,YAAZ;AAEA,C,CAED;;;AACA,SAASmF,qBAAT,CAAgCC,UAAhC,EAA4CC,OAAO,GAAG;AAAEC,EAAAA,SAAS,EAAE,KAAb;AAAoBC,EAAAA,WAAW,EAAE,KAAjC;AAAwCC,EAAAA,cAAc,EAAE;AAAxD,CAAtD,EAAoHC,cAAc,GAAG,IAAIlG,cAAJ,EAArI,EAA4J;AAE3J,QAAMmG,SAAS,GAAGN,UAAU,CAAE,CAAF,CAAV,CAAgBhC,KAAhB,KAA0B,IAA5C;AACA,QAAM;AAAEkC,IAAAA,SAAS,GAAG,KAAd;AAAqBC,IAAAA,WAAW,GAAG,KAAnC;AAA0CC,IAAAA,cAAc,GAAG;AAA3D,MAAkEH,OAAxE;AAEA,QAAMM,cAAc,GAAG,IAAIC,GAAJ,CAASC,MAAM,CAACC,IAAP,CAAaV,UAAU,CAAE,CAAF,CAAV,CAAgB1B,UAA7B,CAAT,CAAvB;AACA,QAAMA,UAAU,GAAG,EAAnB;AAEA,MAAIqC,MAAM,GAAG,CAAb;AAEAN,EAAAA,cAAc,CAACO,WAAf;;AACA,OAAM,IAAIrE,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGyD,UAAU,CAAC1C,MAAhC,EAAwC,EAAGf,CAA3C,EAA+C;AAE9C,UAAM2B,QAAQ,GAAG8B,UAAU,CAAEzD,CAAF,CAA3B;AACA,QAAIsE,eAAe,GAAG,CAAtB,CAH8C,CAK9C;;AACA,QAAKP,SAAS,MAAOpC,QAAQ,CAACF,KAAT,KAAmB,IAA1B,CAAd,EAAiD;AAEhD,YAAM,IAAIlC,KAAJ,CAAW,qJAAX,CAAN;AAEA,KAV6C,CAY9C;;;AACA,SAAM,MAAMgF,IAAZ,IAAoB5C,QAAQ,CAACI,UAA7B,EAA0C;AAEzC,UAAK,CAAEiC,cAAc,CAACQ,GAAf,CAAoBD,IAApB,CAAP,EAAoC;AAEnC,cAAM,IAAIhF,KAAJ,CAAW,yFAAyFgF,IAAzF,GAAgG,8DAA3G,CAAN;AAEA;;AAED,UAAKxC,UAAU,CAAEwC,IAAF,CAAV,KAAuBE,SAA5B,EAAwC;AAEvC1C,QAAAA,UAAU,CAAEwC,IAAF,CAAV,GAAqB,EAArB;AAEA;;AAEDxC,MAAAA,UAAU,CAAEwC,IAAF,CAAV,CAAmBG,IAAnB,CAAyB/C,QAAQ,CAACI,UAAT,CAAqBwC,IAArB,CAAzB;AACAD,MAAAA,eAAe;AAEf,KA9B6C,CAgC9C;;;AACA,QAAKA,eAAe,KAAKN,cAAc,CAACW,IAAxC,EAA+C;AAE9C,YAAM,IAAIpF,KAAJ,CAAW,uFAAX,CAAN;AAEA;;AAED,QAAKoE,SAAL,EAAiB;AAEhB,UAAI5E,KAAJ;;AACA,UAAKgF,SAAL,EAAiB;AAEhBhF,QAAAA,KAAK,GAAG4C,QAAQ,CAACF,KAAT,CAAe1C,KAAvB;AAEA,OAJD,MAIO,IAAK4C,QAAQ,CAACI,UAAT,CAAoB6C,QAApB,KAAiCH,SAAtC,EAAkD;AAExD1F,QAAAA,KAAK,GAAG4C,QAAQ,CAACI,UAAT,CAAoB6C,QAApB,CAA6B7F,KAArC;AAEA,OAJM,MAIA;AAEN,cAAM,IAAIQ,KAAJ,CAAW,yFAAX,CAAN;AAEA;;AAEDuE,MAAAA,cAAc,CAACe,QAAf,CAAyBT,MAAzB,EAAiCrF,KAAjC,EAAwCiB,CAAxC;AACAoE,MAAAA,MAAM,IAAIrF,KAAV;AAEA;AAED,GAxE0J,CA0E3J;;;AACA,MAAKgF,SAAL,EAAiB;AAEhB,QAAIe,gBAAgB,GAAG,KAAvB;;AACA,QAAK,CAAEhB,cAAc,CAACrC,KAAtB,EAA8B;AAE7B,UAAIsD,UAAU,GAAG,CAAjB;;AACA,WAAM,IAAI/E,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGyD,UAAU,CAAC1C,MAAhC,EAAwC,EAAGf,CAA3C,EAA+C;AAE9C+E,QAAAA,UAAU,IAAItB,UAAU,CAAEzD,CAAF,CAAV,CAAgByB,KAAhB,CAAsB1C,KAApC;AAEA;;AAED+E,MAAAA,cAAc,CAACkB,QAAf,CAAyB,IAAIrH,eAAJ,CAAqB,IAAIsH,WAAJ,CAAiBF,UAAjB,CAArB,EAAoD,CAApD,EAAuD,KAAvD,CAAzB;AACAD,MAAAA,gBAAgB,GAAG,IAAnB;AAEA;;AAED,QAAKlB,WAAW,IAAIkB,gBAApB,EAAuC;AAEtC,YAAMI,WAAW,GAAGpB,cAAc,CAACrC,KAAnC;AACA,UAAI3B,YAAY,GAAG,CAAnB;AACA,UAAIqF,WAAW,GAAG,CAAlB;;AACA,WAAM,IAAInF,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGyD,UAAU,CAAC1C,MAAhC,EAAwC,EAAGf,CAA3C,EAA+C;AAE9C,cAAM2B,QAAQ,GAAG8B,UAAU,CAAEzD,CAAF,CAA3B;AACA,cAAMyB,KAAK,GAAGE,QAAQ,CAACF,KAAvB;;AACA,YAAKoC,cAAc,CAAE7D,CAAF,CAAd,KAAwB,IAA7B,EAAoC;AAEnC,eAAM,IAAIiD,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGxB,KAAK,CAAC1C,KAA3B,EAAkC,EAAGkE,CAArC,EAAyC;AAExCiC,YAAAA,WAAW,CAAC/E,IAAZ,CAAkBL,YAAlB,EAAgC2B,KAAK,CAACrB,IAAN,CAAY6C,CAAZ,IAAkBkC,WAAlD;AACArF,YAAAA,YAAY;AAEZ;AAED;;AAEDqF,QAAAA,WAAW,IAAIxD,QAAQ,CAACI,UAAT,CAAoB6C,QAApB,CAA6B7F,KAA5C;AAEA;AAED;AAED,GAtH0J,CAwH3J;;;AACA,OAAM,MAAMwF,IAAZ,IAAoBxC,UAApB,EAAiC;AAEhC,UAAMqD,QAAQ,GAAGrD,UAAU,CAAEwC,IAAF,CAA3B;;AACA,QAAK,EAAIA,IAAI,IAAIT,cAAc,CAAC/B,UAA3B,CAAL,EAA+C;AAE9C,UAAIhD,KAAK,GAAG,CAAZ;;AACA,WAAM,MAAMsG,GAAZ,IAAmBD,QAAnB,EAA8B;AAE7BrG,QAAAA,KAAK,IAAIqG,QAAQ,CAAEC,GAAF,CAAR,CAAgBtG,KAAzB;AAEA;;AAED+E,MAAAA,cAAc,CAACwB,YAAf,CAA6Bf,IAA7B,EAAmC/E,oBAAoB,CAAEuC,UAAU,CAAEwC,IAAF,CAAV,CAAoB,CAApB,CAAF,EAA2BxF,KAA3B,CAAvD;AAEA;;AAED,UAAMwG,eAAe,GAAGzB,cAAc,CAAC/B,UAAf,CAA2BwC,IAA3B,CAAxB;AACA,QAAIH,MAAM,GAAG,CAAb;;AACA,SAAM,IAAIpE,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGmF,QAAQ,CAACrE,MAA9B,EAAsCf,CAAC,GAAGC,CAA1C,EAA6CD,CAAC,EAA9C,EAAoD;AAEnD,YAAMP,IAAI,GAAG2F,QAAQ,CAAEpF,CAAF,CAArB;;AACA,UAAK6D,cAAc,CAAE7D,CAAF,CAAd,KAAwB,IAA7B,EAAoC;AAEnCJ,QAAAA,qBAAqB,CAAEH,IAAF,EAAQ8F,eAAR,EAAyBnB,MAAzB,CAArB;AAEA;;AAEDA,MAAAA,MAAM,IAAI3E,IAAI,CAACV,KAAf;AAEA;AAED;;AAED,SAAO+E,cAAP;AAEA;;AAED,SAAS0B,uBAAT,CAAkCC,CAAlC,EAAqCC,CAArC,EAAyC;AAExC,MAAKD,CAAC,KAAK,IAAN,IAAcC,CAAC,KAAK,IAAzB,EAAgC;AAE/B,WAAOD,CAAC,KAAKC,CAAb;AAEA;;AAED,MAAKD,CAAC,CAAC1E,MAAF,KAAa2E,CAAC,CAAC3E,MAApB,EAA6B;AAE5B,WAAO,KAAP;AAEA;;AAED,OAAM,IAAIf,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGwF,CAAC,CAAC1E,MAAvB,EAA+Bf,CAAC,GAAGC,CAAnC,EAAsCD,CAAC,EAAvC,EAA6C;AAE5C,QAAKyF,CAAC,CAAEzF,CAAF,CAAD,KAAW0F,CAAC,CAAE1F,CAAF,CAAjB,EAAyB;AAExB,aAAO,KAAP;AAEA;AAED;;AAED,SAAO,IAAP;AAEA,C,CAED;;;AACA,MAAM2F,YAAN,CAAmB;AAElBvG,EAAAA,WAAW,CAAEoC,IAAF,EAAS;AAEnB,SAAKe,WAAL,GAAmB,IAAIxE,OAAJ,EAAnB;AACA,SAAK6H,YAAL,GAAoB,IAApB;AACA,SAAKC,YAAL,GAAoB,IAApB;AACA,SAAKC,cAAL,GAAsB,CAAE,CAAxB;AACA,SAAKtE,IAAL,GAAYA,IAAZ;AAEA,SAAKuE,MAAL;AAEA;;AAEDA,EAAAA,MAAM,GAAG;AAER,UAAMvE,IAAI,GAAG,KAAKA,IAAlB;AACA,UAAMG,QAAQ,GAAGH,IAAI,CAACG,QAAtB;AACA,UAAMD,QAAQ,GAAGF,IAAI,CAACE,QAAtB;AACA,UAAMoE,cAAc,GAAG,CAAEnE,QAAQ,CAACF,KAAT,GAAiBE,QAAQ,CAACF,KAAT,CAAe1C,KAAhC,GAAwC4C,QAAQ,CAACI,UAAT,CAAoB6C,QAApB,CAA6B7F,KAAvE,IAAiF,CAAxG;AACA,SAAKwD,WAAL,CAAiByD,IAAjB,CAAuBxE,IAAI,CAACe,WAA5B;AACA,SAAKqD,YAAL,GAAoBjE,QAAQ,CAACI,UAAT,CAAoB6C,QAApB,CAA6BqB,OAAjD;AACA,SAAKH,cAAL,GAAsBA,cAAtB;;AAEA,QAAKpE,QAAL,EAAgB;AAEf;AACA,UAAK,CAAEA,QAAQ,CAACwE,WAAhB,EAA8B;AAE7BxE,QAAAA,QAAQ,CAACyE,kBAAT;AAEA;;AAEDzE,MAAAA,QAAQ,CAACqE,MAAT,GATe,CAWf;;AACA,YAAMF,YAAY,GAAGnE,QAAQ,CAACmE,YAA9B;;AACA,UAAK,CAAE,KAAKA,YAAP,IAAuB,KAAKA,YAAL,CAAkB9E,MAAlB,KAA6B8E,YAAY,CAAC9E,MAAtE,EAA+E;AAE9E,aAAK8E,YAAL,GAAoBA,YAAY,CAACO,KAAb,EAApB;AAEA,OAJD,MAIO;AAEN,aAAKP,YAAL,CAAkB7E,GAAlB,CAAuB6E,YAAvB;AAEA;AAED,KAvBD,MAuBO;AAEN,WAAKA,YAAL,GAAoB,IAApB;AAEA;AAED;;AAEDQ,EAAAA,SAAS,GAAG;AAEX,UAAM7E,IAAI,GAAG,KAAKA,IAAlB;AACA,UAAMG,QAAQ,GAAGH,IAAI,CAACG,QAAtB;AACA,UAAMmE,cAAc,GAAG,CAAEnE,QAAQ,CAACF,KAAT,GAAiBE,QAAQ,CAACF,KAAT,CAAe1C,KAAhC,GAAwC4C,QAAQ,CAACI,UAAT,CAAoB6C,QAApB,CAA6B7F,KAAvE,IAAiF,CAAxG;AACA,UAAMuH,SAAS,GACd,KAAK/D,WAAL,CAAiBgE,MAAjB,CAAyB/E,IAAI,CAACe,WAA9B,KACA,KAAKqD,YAAL,KAAsBjE,QAAQ,CAACI,UAAT,CAAoB6C,QAApB,CAA6BqB,OADnD,IAEAT,uBAAuB,CAAEhE,IAAI,CAACE,QAAL,IAAiBF,IAAI,CAACE,QAAL,CAAcmE,YAA/B,IAA+C,IAAjD,EAAuD,KAAKA,YAA5D,CAFvB,IAGA,KAAKC,cAAL,KAAwBA,cAJzB;AAMA,WAAO,CAAEQ,SAAT;AAEA;;AApEiB;;AAwEnB,OAAO,MAAME,uBAAN,CAA8B;AAEpCpH,EAAAA,WAAW,CAAEqH,MAAF,EAAW;AAErB,QAAK,CAAEC,KAAK,CAACC,OAAN,CAAeF,MAAf,CAAP,EAAiC;AAEhCA,MAAAA,MAAM,GAAG,CAAEA,MAAF,CAAT;AAEA;;AAED,UAAMG,WAAW,GAAG,EAApB;AACAH,IAAAA,MAAM,CAACI,OAAP,CAAgBC,MAAM,IAAI;AAEzBA,MAAAA,MAAM,CAACC,eAAP,CAAwBC,CAAC,IAAI;AAE5B,YAAKA,CAAC,CAACC,MAAP,EAAgB;AAEfL,UAAAA,WAAW,CAAClC,IAAZ,CAAkBsC,CAAlB;AAEA;AAED,OARD;AAUA,KAZD;AAcA,SAAKP,MAAL,GAAcG,WAAd;AACA,SAAKjD,SAAL,GAAiB,IAAjB;AACA,SAAKuD,oBAAL,GAA4B,IAA5B;AACA,SAAKnF,UAAL,GAAkB,CAAE,UAAF,EAAc,QAAd,EAAwB,OAAxB,EAAiC,SAAjC,EAA4C,IAA5C,EAAkD,KAAlD,CAAlB;AACA,SAAKoF,qBAAL,GAA6B,IAAIT,KAAJ,CAAWE,WAAW,CAAC7F,MAAvB,EAAgCmB,IAAhC,GAAuCkF,GAAvC,CAA4C,MAAM,IAAIxJ,cAAJ,EAAlD,CAA7B;AACA,SAAKyJ,QAAL,GAAgB,IAAIC,OAAJ,EAAhB;AAEA;;AAEDC,EAAAA,YAAY,GAAG;AAEd,UAAMC,SAAS,GAAG,EAAlB;AACA,SAAKf,MAAL,CAAYI,OAAZ,CAAqBrF,IAAI,IAAI;AAE5B,UAAKkF,KAAK,CAACC,OAAN,CAAenF,IAAI,CAACiG,QAApB,CAAL,EAAsC;AAErCD,QAAAA,SAAS,CAAC9C,IAAV,CAAgB,GAAGlD,IAAI,CAACiG,QAAxB;AAEA,OAJD,MAIO;AAEND,QAAAA,SAAS,CAAC9C,IAAV,CAAgBlD,IAAI,CAACiG,QAArB;AAEA;AAED,KAZD;AAaA,WAAOD,SAAP;AAEA;;AAEDE,EAAAA,QAAQ,CAAE5D,cAAc,GAAG,IAAIlG,cAAJ,EAAnB,EAA0C;AAEjD;AACA,QAAIiG,cAAc,GAAG,EAArB;AACA,UAAM;AAAE4C,MAAAA,MAAF;AAAU9C,MAAAA,SAAV;AAAqBwD,MAAAA,qBAArB;AAA4CE,MAAAA;AAA5C,QAAyD,IAA/D;;AACA,SAAM,IAAIrH,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGwG,MAAM,CAAC1F,MAA5B,EAAoCf,CAAC,GAAGC,CAAxC,EAA2CD,CAAC,EAA5C,EAAkD;AAEjD,YAAMwB,IAAI,GAAGiF,MAAM,CAAEzG,CAAF,CAAnB;AACA,YAAM2H,IAAI,GAAGR,qBAAqB,CAAEnH,CAAF,CAAlC;;AACA,YAAM4H,IAAI,GAAGP,QAAQ,CAACQ,GAAT,CAAcrG,IAAd,CAAb;;AACA,UAAK,CAAEoG,IAAF,IAAUA,IAAI,CAACvB,SAAL,CAAgB7E,IAAhB,CAAf,EAAwC;AAEvC,aAAKsG,wBAAL,CAA+BtG,IAA/B,EAAqCmG,IAArC;;AACA9D,QAAAA,cAAc,CAACa,IAAf,CAAqB,KAArB;;AAEA,YAAK,CAAEkD,IAAP,EAAc;AAEbP,UAAAA,QAAQ,CAACrG,GAAT,CAAcQ,IAAd,EAAoB,IAAImE,YAAJ,CAAkBnE,IAAlB,CAApB;AAEA,SAJD,MAIO;AAENoG,UAAAA,IAAI,CAAC7B,MAAL;AAEA;AAED,OAfD,MAeO;AAENlC,QAAAA,cAAc,CAACa,IAAf,CAAqB,IAArB;AAEA;AAED;;AAEDlB,IAAAA,qBAAqB,CAAE2D,qBAAF,EAAyB;AAAExD,MAAAA,SAAF;AAAaE,MAAAA;AAAb,KAAzB,EAAwDC,cAAxD,CAArB;;AAEA,SAAM,MAAMuB,GAAZ,IAAmBvB,cAAc,CAAC/B,UAAlC,EAA+C;AAE9C+B,MAAAA,cAAc,CAAC/B,UAAf,CAA2BsD,GAA3B,EAAiC0C,WAAjC,GAA+C,IAA/C;AAEA;;AAED,WAAOjE,cAAP;AAEA;;AAEDgE,EAAAA,wBAAwB,CAAEtG,IAAF,EAAQsC,cAAc,GAAG,IAAIlG,cAAJ,EAAzB,EAAgD;AAEvE,UAAM+D,QAAQ,GAAGH,IAAI,CAACG,QAAtB;AACA,UAAMuF,oBAAoB,GAAG,KAAKA,oBAAlC;AACA,UAAMc,aAAa,GAAG,KAAKjG,UAAL,CAAgBkG,QAAhB,CAA0B,QAA1B,CAAtB;AACA,UAAMC,cAAc,GAAG,KAAKnG,UAAL,CAAgBkG,QAAhB,CAA0B,SAA1B,CAAvB;AACA,UAAMlG,UAAU,GAAGJ,QAAQ,CAACI,UAA5B;AACA,UAAMoG,gBAAgB,GAAGrE,cAAc,CAAC/B,UAAxC,CAPuE,CASvE;;AACA,QAAK,CAAE+B,cAAc,CAACrC,KAAtB,EAA8B;AAE7BqC,MAAAA,cAAc,CAACrC,KAAf,GAAuBE,QAAQ,CAACF,KAAhC;AAEA;;AAED,QAAK,CAAE0G,gBAAgB,CAACvD,QAAxB,EAAmC;AAElCd,MAAAA,cAAc,CAACwB,YAAf,CAA6B,UAA7B,EAAyC9F,oBAAoB,CAAEuC,UAAU,CAAC6C,QAAb,CAA7D;AAEA;;AAED,QAAKoD,aAAa,IAAI,CAAEG,gBAAgB,CAACC,MAApC,IAA8CrG,UAAU,CAACqG,MAA9D,EAAuE;AAEtEtE,MAAAA,cAAc,CAACwB,YAAf,CAA6B,QAA7B,EAAuC9F,oBAAoB,CAAEuC,UAAU,CAACqG,MAAb,CAA3D;AAEA;;AAED,QAAKF,cAAc,IAAI,CAAEC,gBAAgB,CAACE,OAArC,IAAgDtG,UAAU,CAACsG,OAAhE,EAA0E;AAEzEvE,MAAAA,cAAc,CAACwB,YAAf,CAA6B,SAA7B,EAAwC9F,oBAAoB,CAAEuC,UAAU,CAACsG,OAAb,CAA5D;AAEA,KAhCsE,CAkCvE;;;AACA1J,IAAAA,kBAAkB,CAAEgD,QAAQ,CAACF,KAAX,EAAkBqC,cAAc,CAACrC,KAAjC,CAAlB;AACA9C,IAAAA,kBAAkB,CAAEoD,UAAU,CAAC6C,QAAb,EAAuBuD,gBAAgB,CAACvD,QAAxC,CAAlB;;AAEA,QAAKoD,aAAL,EAAqB;AAEpBrJ,MAAAA,kBAAkB,CAAEoD,UAAU,CAACqG,MAAb,EAAqBD,gBAAgB,CAACC,MAAtC,CAAlB;AAEA;;AAED,QAAKF,cAAL,EAAsB;AAErBvJ,MAAAA,kBAAkB,CAAEoD,UAAU,CAACsG,OAAb,EAAsBF,gBAAgB,CAACE,OAAvC,CAAlB;AAEA,KAhDsE,CAkDvE;;;AACA,UAAMzD,QAAQ,GAAG7C,UAAU,CAAC6C,QAA5B;AACA,UAAMwD,MAAM,GAAGJ,aAAa,GAAGjG,UAAU,CAACqG,MAAd,GAAuB,IAAnD;AACA,UAAMC,OAAO,GAAGH,cAAc,GAAGnG,UAAU,CAACsG,OAAd,GAAwB,IAAtD;AACA,UAAMC,aAAa,GAAG3G,QAAQ,CAAC4G,eAAT,CAAyB3D,QAA/C;AACA,UAAM4D,WAAW,GAAG7G,QAAQ,CAAC4G,eAAT,CAAyBH,MAA7C;AACA,UAAMK,YAAY,GAAG9G,QAAQ,CAAC4G,eAAT,CAAyBF,OAA9C;AACA,UAAMrF,oBAAoB,GAAGrB,QAAQ,CAACqB,oBAAtC;AACA,UAAMD,eAAe,GAAGvB,IAAI,CAACkH,qBAA7B;AACA,UAAMC,YAAY,GAAG,IAAI3K,OAAJ,EAArB;AACA2K,IAAAA,YAAY,CAACC,eAAb,CAA8BpH,IAAI,CAACe,WAAnC;;AAEA,SAAM,IAAIvC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG8B,UAAU,CAAC6C,QAAX,CAAoB7F,KAAzC,EAAgDiB,CAAC,GAAGC,CAApD,EAAuDD,CAAC,EAAxD,EAA8D;AAE7D/B,MAAAA,eAAe,CAAC6D,mBAAhB,CAAqC8C,QAArC,EAA+C5E,CAA/C;;AACA,UAAKoI,MAAL,EAAc;AAEblK,QAAAA,aAAa,CAAC4D,mBAAd,CAAmCsG,MAAnC,EAA2CpI,CAA3C;AAEA;;AAED,UAAKqI,OAAL,EAAe;AAEdjK,QAAAA,eAAe,CAAC0D,mBAAhB,CAAqCuG,OAArC,EAA8CrI,CAA9C;;AACA7B,QAAAA,cAAc,CAAC2D,mBAAf,CAAoCuG,OAApC,EAA6CrI,CAA7C;AAEA,OAd4D,CAgB7D;;;AACA,UAAK+C,eAAL,EAAuB;AAEtB,YAAKuF,aAAL,EAAqB;AAEpBzF,UAAAA,gBAAgB,CAAEyF,aAAF,EAAiBvF,eAAjB,EAAkCC,oBAAlC,EAAwDhD,CAAxD,EAA2D/B,eAA3D,CAAhB;AAEA;;AAED,YAAKuK,WAAL,EAAmB;AAElB3F,UAAAA,gBAAgB,CAAE2F,WAAF,EAAezF,eAAf,EAAgCC,oBAAhC,EAAsDhD,CAAtD,EAAyD9B,aAAzD,CAAhB;AAEA;;AAED,YAAKuK,YAAL,EAAoB;AAEnB5F,UAAAA,gBAAgB,CAAE4F,YAAF,EAAgB1F,eAAhB,EAAiCC,oBAAjC,EAAuDhD,CAAvD,EAA0D7B,cAA1D,CAAhB;AAEA;AAED,OArC4D,CAuC7D;;;AACA,UAAKqD,IAAI,CAACqH,aAAV,EAA0B;AAEzBrH,QAAAA,IAAI,CAACsH,aAAL,CAAoB9I,CAApB,EAAuB/B,eAAvB;;AACA,YAAKmK,MAAL,EAAc;AAEb7G,UAAAA,mBAAmB,CAAEC,IAAF,EAAQxB,CAAR,EAAW9B,aAAX,CAAnB;AAEA;;AAED,YAAKmK,OAAL,EAAe;AAEd9G,UAAAA,mBAAmB,CAAEC,IAAF,EAAQxB,CAAR,EAAW7B,cAAX,CAAnB;AAEA;AAED,OAvD4D,CAyD7D;;;AACA,UAAK+I,oBAAL,EAA4B;AAE3BjJ,QAAAA,eAAe,CAAC8K,YAAhB,CAA8BvH,IAAI,CAACe,WAAnC;AAEA;;AAED4F,MAAAA,gBAAgB,CAACvD,QAAjB,CAA0BoE,MAA1B,CAAkChJ,CAAlC,EAAqC/B,eAAe,CAACgL,CAArD,EAAwDhL,eAAe,CAACiL,CAAxE,EAA2EjL,eAAe,CAACkL,CAA3F;;AAEA,UAAKf,MAAL,EAAc;AAEb,YAAKlB,oBAAL,EAA4B;AAE3BhJ,UAAAA,aAAa,CAACkL,iBAAd,CAAiCT,YAAjC;AAEA;;AAEDR,QAAAA,gBAAgB,CAACC,MAAjB,CAAwBY,MAAxB,CAAgChJ,CAAhC,EAAmC9B,aAAa,CAAC+K,CAAjD,EAAoD/K,aAAa,CAACgL,CAAlE,EAAqEhL,aAAa,CAACiL,CAAnF;AAEA;;AAED,UAAKd,OAAL,EAAe;AAEd,YAAKnB,oBAAL,EAA4B;AAE3B/I,UAAAA,cAAc,CAACyE,kBAAf,CAAmCpB,IAAI,CAACe,WAAxC;AAEA;;AAED4F,QAAAA,gBAAgB,CAACE,OAAjB,CAAyBgB,OAAzB,CAAkCrJ,CAAlC,EAAqC7B,cAAc,CAAC8K,CAApD,EAAuD9K,cAAc,CAAC+K,CAAtE,EAAyE/K,cAAc,CAACgL,CAAxF,EAA2F/K,eAAe,CAACkL,CAA3G;AAEA;AAED,KAxJsE,CA0JvE;;;AACA,SAAM,MAAMtJ,CAAZ,IAAiB,KAAK+B,UAAtB,EAAmC;AAElC,YAAMsD,GAAG,GAAG,KAAKtD,UAAL,CAAiB/B,CAAjB,CAAZ;;AACA,UAAKqF,GAAG,KAAK,UAAR,IAAsBA,GAAG,KAAK,SAA9B,IAA2CA,GAAG,KAAK,QAAnD,IAA+D,EAAIA,GAAG,IAAItD,UAAX,CAApE,EAA8F;AAE7F;AAEA;;AAED,UAAK,CAAEoG,gBAAgB,CAAE9C,GAAF,CAAvB,EAAiC;AAEhCvB,QAAAA,cAAc,CAACwB,YAAf,CAA6BD,GAA7B,EAAkC7F,oBAAoB,CAAEuC,UAAU,CAAEsD,GAAF,CAAZ,CAAtD;AAEA;;AAED1G,MAAAA,kBAAkB,CAAEoD,UAAU,CAAEsD,GAAF,CAAZ,EAAqB8C,gBAAgB,CAAE9C,GAAF,CAArC,CAAlB;AACAzF,MAAAA,qBAAqB,CAAEmC,UAAU,CAAEsD,GAAF,CAAZ,EAAqB8C,gBAAgB,CAAE9C,GAAF,CAArC,CAArB;AAEA;;AAED,WAAOvB,cAAP;AAEA;;AApRmC","sourcesContent":["import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\n\nconst _positionVector = /*@__PURE__*/ new Vector3();\nconst _normalVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\n\nconst _morphVector = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\n\n// Confirms that the two provided attributes are compatible\nfunction validateAttributes( attr1, attr2 ) {\n\n\tif ( ! attr1 && ! attr2 ) {\n\n\t\treturn;\n\n\t}\n\n\tconst sameCount = attr1.count === attr2.count;\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\tthrow new Error();\n\n\t}\n\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction createAttributeClone( attr, countOverride = null ) {\n\n\tconst cons = attr.array.constructor;\n\tconst normalized = attr.normalized;\n\tconst itemSize = attr.itemSize;\n\tconst count = countOverride === null ? attr.count : countOverride;\n\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n}\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\tconst itemSize = attr.itemSize;\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\tconst io = i + targetOffset;\n\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = target.array;\n\t\tconst cons = array.constructor;\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\ttemp.set( attr.array );\n\n\t}\n\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix( target, matrix, scale ) {\n\n\tconst targetArray = target.elements;\n\tconst matrixArray = matrix.elements;\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t}\n\n}\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform( mesh, index, target ) {\n\n\tconst skeleton = mesh.skeleton;\n\tconst geometry = mesh.geometry;\n\tconst bones = skeleton.bones;\n\tconst boneInverses = skeleton.boneInverses;\n\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t_matrix.elements.fill( 0 );\n\n\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\tif ( weight !== 0 ) {\n\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t}\n\n\t}\n\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\ttarget.transformDirection( _matrix );\n\n\treturn target;\n\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t_morphVector.set( 0, 0, 0 );\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\tconst influence = morphInfluences[ j ];\n\t\tconst morphAttribute = morphData[ j ];\n\n\t\tif ( influence === 0 ) continue;\n\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t} else {\n\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t}\n\n\t}\n\n\ttarget.add( _morphVector );\n\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new BufferGeometry() ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\tconst { useGroups = false, updateIndex = false, skipAttributes = [] } = options;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst attributes = {};\n\n\tlet offset = 0;\n\n\ttargetGeometry.clearGroups();\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) {\n\n\t\t\t\tattributes[ name ] = [];\n\n\t\t\t}\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\n\n\t\t\t}\n\n\t\t\ttargetGeometry.addGroup( offset, count, i );\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\tif ( isIndexed ) {\n\n\t\tlet forceUpdateIndex = false;\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\tlet indexCount = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tindexCount += geometries[ i ].index.count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\n\t\t\tforceUpdateIndex = true;\n\n\t\t}\n\n\t\tif ( updateIndex || forceUpdateIndex ) {\n\n\t\t\tconst targetIndex = targetGeometry.index;\n\t\t\tlet targetOffset = 0;\n\t\t\tlet indexOffset = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\n\t\t\t\t\t\ttargetOffset ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometry.attributes.position.count;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// merge attributes\n\tfor ( const name in attributes ) {\n\n\t\tconst attrList = attributes[ name ];\n\t\tif ( ! ( name in targetGeometry.attributes ) ) {\n\n\t\t\tlet count = 0;\n\t\t\tfor ( const key in attrList ) {\n\n\t\t\t\tcount += attrList[ key ].count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\n\n\t\t}\n\n\t\tconst targetAttribute = targetGeometry.attributes[ name ];\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = attrList.length; i < l; i ++ ) {\n\n\t\t\tconst attr = attrList[ i ];\n\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t}\n\n\t\t\toffset += attr.count;\n\n\t\t}\n\n\t}\n\n\treturn targetGeometry;\n\n}\n\nfunction checkTypedArrayEquality( a, b ) {\n\n\tif ( a === null || b === null ) {\n\n\t\treturn a === b;\n\n\t}\n\n\tif ( a.length !== b.length ) {\n\n\t\treturn false;\n\n\t}\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\n// Checks whether the geometry changed between this and last evaluation\nclass GeometryDiff {\n\n\tconstructor( mesh ) {\n\n\t\tthis.matrixWorld = new Matrix4();\n\t\tthis.geometryHash = null;\n\t\tthis.boneMatrices = null;\n\t\tthis.primitiveCount = - 1;\n\t\tthis.mesh = mesh;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst skeleton = mesh.skeleton;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\tthis.geometryHash = geometry.attributes.position.version;\n\t\tthis.primitiveCount = primitiveCount;\n\n\t\tif ( skeleton ) {\n\n\t\t\t// ensure the bone matrix array is updated to the appropriate length\n\t\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\t\tskeleton.computeBoneTexture();\n\n\t\t\t}\n\n\t\t\tskeleton.update();\n\n\t\t\t// copy data if possible otherwise clone it\n\t\t\tconst boneMatrices = skeleton.boneMatrices;\n\t\t\tif ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {\n\n\t\t\t\tthis.boneMatrices = boneMatrices.slice();\n\n\t\t\t} else {\n\n\t\t\t\tthis.boneMatrices.set( boneMatrices );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = null;\n\n\t\t}\n\n\t}\n\n\tdidChange() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tconst identical =\n\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\tthis.geometryHash === geometry.attributes.position.version &&\n\t\t\tcheckTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&\n\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\treturn ! identical;\n\n\t}\n\n}\n\nexport class StaticGeometryGenerator {\n\n\tconstructor( meshes ) {\n\n\t\tif ( ! Array.isArray( meshes ) ) {\n\n\t\t\tmeshes = [ meshes ];\n\n\t\t}\n\n\t\tconst finalMeshes = [];\n\t\tmeshes.forEach( object => {\n\n\t\t\tobject.traverseVisible( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tfinalMeshes.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tthis.meshes = finalMeshes;\n\t\tthis.useGroups = true;\n\t\tthis.applyWorldTransforms = true;\n\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new BufferGeometry() );\n\t\tthis._diffMap = new WeakMap();\n\n\t}\n\n\tgetMaterials() {\n\n\t\tconst materials = [];\n\t\tthis.meshes.forEach( mesh => {\n\n\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\tmaterials.push( ...mesh.material );\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( mesh.material );\n\n\t\t\t}\n\n\t\t} );\n\t\treturn materials;\n\n\t}\n\n\tgenerate( targetGeometry = new BufferGeometry() ) {\n\n\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\tlet skipAttributes = [];\n\t\tconst { meshes, useGroups, _intermediateGeometry, _diffMap } = this;\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tconst geom = _intermediateGeometry[ i ];\n\t\t\tconst diff = _diffMap.get( mesh );\n\t\t\tif ( ! diff || diff.didChange( mesh ) ) {\n\n\t\t\t\tthis._convertToStaticGeometry( mesh, geom );\n\t\t\t\tskipAttributes.push( false );\n\n\t\t\t\tif ( ! diff ) {\n\n\t\t\t\t\t_diffMap.set( mesh, new GeometryDiff( mesh ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdiff.update();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tskipAttributes.push( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );\n\n\t\tfor ( const key in targetGeometry.attributes ) {\n\n\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n\t_convertToStaticGeometry( mesh, targetGeometry = new BufferGeometry() ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tconst applyWorldTransforms = this.applyWorldTransforms;\n\t\tconst includeNormal = this.attributes.includes( 'normal' );\n\t\tconst includeTangent = this.attributes.includes( 'tangent' );\n\t\tconst attributes = geometry.attributes;\n\t\tconst targetAttributes = targetGeometry.attributes;\n\n\t\t// initialize the attributes if they don't exist\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\ttargetGeometry.index = geometry.index;\n\n\t\t}\n\n\t\tif ( ! targetAttributes.position ) {\n\n\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t\t}\n\n\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t\t}\n\n\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t\t}\n\n\t\t// ensure the attributes are consistent\n\t\tvalidateAttributes( geometry.index, targetGeometry.index );\n\t\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\t\tif ( includeNormal ) {\n\n\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t\t}\n\n\t\tif ( includeTangent ) {\n\n\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t\t}\n\n\t\t// generate transformed vertex attribute data\n\t\tconst position = attributes.position;\n\t\tconst normal = includeNormal ? attributes.normal : null;\n\t\tconst tangent = includeTangent ? attributes.tangent : null;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphNormal = geometry.morphAttributes.normal;\n\t\tconst morphTangent = geometry.morphAttributes.tangent;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\tconst morphInfluences = mesh.morphTargetInfluences;\n\t\tconst normalMatrix = new Matrix3();\n\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t\t_positionVector.fromBufferAttribute( position, i );\n\t\t\tif ( normal ) {\n\n\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t\t}\n\n\t\t\t// apply morph target transform\n\t\t\tif ( morphInfluences ) {\n\n\t\t\t\tif ( morphPosition ) {\n\n\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormal ) {\n\n\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphTangent ) {\n\n\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// apply bone transform\n\t\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\t\tmesh.boneTransform( i, _positionVector );\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the vectors of the attributes\n\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// copy other attributes over\n\t\tfor ( const i in this.attributes ) {\n\n\t\t\tconst key = this.attributes[ i ];\n\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t\t}\n\n\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n}\n"]},"metadata":{},"sourceType":"module"}
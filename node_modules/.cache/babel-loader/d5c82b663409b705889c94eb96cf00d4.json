{"ast":null,"code":"import { Vector3, Ray, Loader, FileLoader, MeshStandardMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Color, BufferGeometry, BufferAttribute, LineSegments, Mesh, Matrix4, Group } from 'three'; // Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\n\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst MAIN_COLOUR_CODE = '16';\nconst MAIN_EDGE_COLOUR_CODE = '24';\n\nconst _tempVec0 = new Vector3();\n\nconst _tempVec1 = new Vector3();\n\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([UniformsLib.fog, {\n        diffuse: {\n          value: new Color()\n        },\n        opacity: {\n          value: 1.0\n        }\n      }]),\n      vertexShader:\n      /* glsl */\n      `\n        attribute vec3 control0;\n        attribute vec3 control1;\n        attribute vec3 direction;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n          #include <color_vertex>\n\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n\n          // Transform the line segment ends and control points into camera clip space\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\n\n          c0.xy /= c0.w;\n          c1.xy /= c1.w;\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n\n          // Get the direction of the segment and an orthogonal vector\n          vec2 dir = p1.xy - p0.xy;\n          vec2 norm = vec2(-dir.y, dir.x);\n\n          // Get control point directions from the line\n          vec2 c0dir = c0.xy - p1.xy;\n          vec2 c1dir = c1.xy - p1.xy;\n\n          // If the vectors to the controls points are pointed in different directions away\n          // from the line segment then the line should not be drawn.\n          float d0 = dot(normalize(norm), normalize(c0dir));\n          float d1 = dot(normalize(norm), normalize(c1dir));\n          discardFlag = float(sign(d0) != sign(d1));\n\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #include <fog_vertex>\n        }\n      `,\n      fragmentShader:\n      /* glsl */\n      `\n        uniform vec3 diffuse;\n        uniform float opacity;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n          if (discardFlag > 0.5) discard;\n\n          #include <clipping_planes_fragment>\n          vec3 outgoingLight = vec3(0.0);\n          vec4 diffuseColor = vec4(diffuse, opacity);\n          #include <logdepthbuf_fragment>\n          #include <color_fragment>\n          outgoingLight = diffuseColor.rgb; // simple shader\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n          #include <tonemapping_fragment>\n          #include <encodings_fragment>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n        }\n      `\n    });\n    Object.defineProperties(this, {\n      opacity: {\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function () {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n    this.setValues(parameters);\n    this.isLDrawConditionalLineMaterial = true;\n  }\n\n}\n\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isConditionalLine = true;\n  }\n\n}\n\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i];\n    const vertices = face.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    const v2 = vertices[2];\n\n    _tempVec0.subVectors(v1, v0);\n\n    _tempVec1.subVectors(v2, v1);\n\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\n\nconst _ray = new Ray();\n\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  // NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n  // it allows edges to be smoothed as expected (see minifig arms).\n  // --\n  // And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n  // point errors on vertices along quantization boundaries. Ie after matrix multiplication\n  // vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n  // get merged. This added epsilon attempts to push these error values to the same quantized\n  // value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n  const hashMultiplier = (1 + 1e-10) * 1e2;\n\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  } // converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n  // onto the original line.\n\n\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    const scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n\n  const hardEdges = new Set();\n  const hardEdgeRays = new Map();\n  const halfEdgeList = {};\n  const normals = []; // Save the list of hard edges by hash\n\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const vertices = ls.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0)); // only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n    // and requires more memory.\n\n    if (checkSubSegments) {\n      // add both ray directions to the map\n      const ray = toNormalizedRay(v0, v1, new Ray());\n      const rh1 = hashRay(ray);\n\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        const rh2 = hashRay(ray);\n        const info = {\n          ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info);\n        hardEdgeRays.set(rh2, info);\n      } // store both segments ends in min, max order in the distances array to check if a face edge is a\n      // subsegment later.\n\n\n      const info = hardEdgeRays.get(rh1);\n      let d0 = info.ray.direction.dot(v0);\n      let d1 = info.ray.direction.dot(v1);\n\n      if (d0 > d1) {\n        [d0, d1] = [d1, d0];\n      }\n\n      info.distances.push(d0, d1);\n    }\n  } // track the half edges associated with each triangle\n\n\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i];\n    const vertices = tri.vertices;\n    const vertCount = vertices.length;\n\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % vertCount;\n      const v0 = vertices[index];\n      const v1 = vertices[next];\n      const hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\n\n      if (hardEdges.has(hash)) {\n        continue;\n      } // if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n\n\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray);\n        const rayHash = hashRay(_ray);\n\n        if (hardEdgeRays.has(rayHash)) {\n          const info = hardEdgeRays.get(rayHash);\n          const {\n            ray,\n            distances\n          } = info;\n          let d0 = ray.direction.dot(v0);\n          let d1 = ray.direction.dot(v1);\n\n          if (d0 > d1) {\n            [d0, d1] = [d1, d0];\n          } // return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n\n\n          let found = false;\n\n          for (let i = 0, l = distances.length; i < l; i += 2) {\n            if (d0 >= distances[i] && d1 <= distances[i + 1]) {\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            continue;\n          }\n        }\n      }\n\n      const info = {\n        index: index,\n        tri: tri\n      };\n      halfEdgeList[hash] = info;\n    }\n  } // Iterate until we've tried to connect all faces to share normals\n\n\n  while (true) {\n    // Stop if there are no more faces left\n    let halfEdge = null;\n\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n\n    if (halfEdge === null) {\n      break;\n    } // Exhaustively find all connected faces\n\n\n    const queue = [halfEdge];\n\n    while (queue.length > 0) {\n      // initialize all vertex normals in this triangle\n      const tri = queue.pop().tri;\n      const vertices = tri.vertices;\n      const vertNormals = tri.normals;\n      const faceNormal = tri.faceNormal; // Check if any edge is connected to another triangle edge\n\n      const vertCount = vertices.length;\n\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % vertCount;\n        const v0 = vertices[index];\n        const v1 = vertices[next]; // delete this triangle from the list so it won't be found again\n\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherInfo = halfEdgeList[reverseHash];\n\n        if (otherInfo) {\n          const otherTri = otherInfo.tri;\n          const otherIndex = otherInfo.index;\n          const otherNormals = otherTri.normals;\n          const otherVertCount = otherNormals.length;\n          const otherFaceNormal = otherTri.faceNormal; // NOTE: If the angle between faces is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          } // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n\n\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          } // share the first normal\n\n\n          const otherNext = (otherIndex + 1) % otherVertCount;\n\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm);\n            vertNormals[index].norm = otherNormals[otherNext].norm;\n          }\n\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];\n\n          if (sharedNormal1 === null) {\n            // it's possible to encounter an edge of a triangle that has already been traversed meaning\n            // both edges already have different normals defined and shared. To work around this we create\n            // a wrapper object so when those edges are merged the normals can be updated everywhere.\n            sharedNormal1 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal1.norm);\n          }\n\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          } // share the second normal\n\n\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm);\n            vertNormals[next].norm = otherNormals[otherIndex].norm;\n          }\n\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];\n\n          if (sharedNormal2 === null) {\n            sharedNormal2 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal2.norm);\n          }\n\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\n\nfunction isPartType(type) {\n  return type === 'Part' || type === 'Unofficial_Part';\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart';\n}\n\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n        return;\n      }\n\n      this.currentCharIndex++;\n    }\n  }\n\n  getToken() {\n    const pos0 = this.currentCharIndex++; // Seek space\n\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\n        break;\n      }\n\n      this.currentCharIndex++;\n    }\n\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n  }\n\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n  }\n\n} // Fetches and parses an intermediate representation of LDraw parts files.\n\n\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader;\n    this._cache = {};\n  }\n\n  cloneResult(original) {\n    const result = {}; // vertices are transformed and normals computed before being converted to geometry\n    // so these pieces must be cloned.\n\n    result.faces = original.faces.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null\n      };\n    });\n    result.conditionalSegments = original.conditionalSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        controlPoints: face.controlPoints.map(v => v.clone())\n      };\n    });\n    result.lineSegments = original.lineSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone())\n      };\n    }); // none if this is subsequently modified\n\n    result.type = original.type;\n    result.category = original.category;\n    result.keywords = original.keywords;\n    result.subobjects = original.subobjects;\n    result.totalFaces = original.totalFaces;\n    result.startingConstructionStep = original.startingConstructionStep;\n    result.materials = original.materials;\n    result.group = null;\n    return result;\n  }\n\n  async fetchData(fileName) {\n    let triedLowerCase = false;\n    let locationState = FILE_LOCATION_AS_IS;\n\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName;\n\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = 'parts/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = 'p/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = 'models/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf('/') + 1) + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            // Try absolute path\n            locationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            // Next attempt is lower case\n            fileName = fileName.toLowerCase();\n            subobjectURL = fileName;\n            triedLowerCase = true;\n            locationState = FILE_LOCATION_AS_IS;\n          }\n\n          break;\n      }\n\n      const loader = this.loader;\n      const fileLoader = new FileLoader(loader.manager);\n      fileLoader.setPath(loader.partsLibraryPath);\n      fileLoader.setRequestHeader(loader.requestHeader);\n      fileLoader.setWithCredentials(loader.withCredentials);\n\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL);\n        return text;\n      } catch {\n        continue;\n      }\n    }\n\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n  }\n\n  parse(text, fileName = null) {\n    const loader = this.loader; // final results\n\n    const faces = [];\n    const lineSegments = [];\n    const conditionalSegments = [];\n    const subobjects = [];\n    const materials = {};\n\n    const getLocalMaterial = colorCode => {\n      return materials[colorCode] || null;\n    };\n\n    let type = 'Model';\n    let category = null;\n    let keywords = null;\n    let totalFaces = 0; // split into lines\n\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n');\n    }\n\n    const lines = text.split('\\n');\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let startingConstructionStep = false; // Parse all line commands\n\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0) continue;\n\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith('0 FILE ')) {\n          // Save previous embedded file in the cache\n          this.setData(currentEmbeddedFileName, currentEmbeddedText); // New embedded text file\n\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = '';\n        } else {\n          currentEmbeddedText += line + '\\n';\n        }\n\n        continue;\n      }\n\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n\n      if (lp.isAtTheEnd()) {\n        // Empty line\n        continue;\n      } // Parse the line type\n\n\n      const lineType = lp.getToken();\n      let material;\n      let colorCode;\n      let segment;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, c0, c1;\n\n      switch (lineType) {\n        // Line type 0: Comment or META\n        case '0':\n          // Parse meta directive\n          const meta = lp.getToken();\n\n          if (meta) {\n            switch (meta) {\n              case '!LDRAW_ORG':\n                type = lp.getToken();\n                break;\n\n              case '!COLOUR':\n                material = loader.parseColorMetaDirective(lp);\n\n                if (material) {\n                  materials[material.userData.code] = material;\n                } else {\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                }\n\n                break;\n\n              case '!CATEGORY':\n                category = lp.getToken();\n                break;\n\n              case '!KEYWORDS':\n                const newKeywords = lp.getRemainingString().split(',');\n\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n\n                break;\n\n              case 'FILE':\n                if (lineIndex > 0) {\n                  // Start embedded text files parsing\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = '';\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n\n                break;\n\n              case 'BFC':\n                // Changes to the backface culling state\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n\n                  switch (token) {\n                    case 'CERTIFY':\n                    case 'NOCERTIFY':\n                      bfcCertified = token === 'CERTIFY';\n                      bfcCCW = true;\n                      break;\n\n                    case 'CW':\n                    case 'CCW':\n                      bfcCCW = token === 'CCW';\n                      break;\n\n                    case 'INVERTNEXT':\n                      bfcInverted = true;\n                      break;\n\n                    case 'CLIP':\n                    case 'NOCLIP':\n                      bfcCull = token === 'CLIP';\n                      break;\n\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n\n                break;\n\n              case 'STEP':\n                startingConstructionStep = true;\n                break;\n            }\n          }\n\n          break;\n        // Line type 1: Sub-object file\n\n        case '1':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n\n          if (loader.fileMap[fileName]) {\n            // Found the subobject path in the preloaded file path map\n            fileName = loader.fileMap[fileName];\n          } else {\n            // Standardized subfolders\n            if (fileName.startsWith('s/')) {\n              fileName = 'parts/' + fileName;\n            } else if (fileName.startsWith('48/')) {\n              fileName = 'p/' + fileName;\n            }\n          }\n\n          subobjects.push({\n            material: material,\n            colorCode: colorCode,\n            matrix: matrix,\n            fileName: fileName,\n            inverted: bfcInverted,\n            startingConstructionStep: startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        // Line type 2: Line segment\n\n        case '2':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1]\n          };\n          lineSegments.push(segment);\n          break;\n        // Line type 5: Conditional Line segment\n\n        case '5':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          c0 = lp.getVector();\n          c1 = lp.getVector();\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1]\n          };\n          conditionalSegments.push(segment);\n          break;\n        // Line type 3: Triangle\n\n        case '3':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n          } else {\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null]\n          });\n          totalFaces++;\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n          }\n\n          break;\n        // Line type 4: Quadrilateral\n\n        case '4':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n            v3 = lp.getVector();\n          } else {\n            v3 = lp.getVector();\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          } // specifically place the triangle diagonal in the v0 and v1 slots so we can\n          // account for the doubling of vertices later when smoothing normals.\n\n\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null]\n          });\n          totalFaces += 2;\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n          }\n\n          break;\n\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.');\n      }\n    }\n\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText);\n    }\n\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      subobjects,\n      totalFaces,\n      startingConstructionStep,\n      materials,\n      fileName,\n      group: null\n    };\n  } // returns an (optionally cloned) instance of the data\n\n\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase();\n    const result = this._cache[key];\n\n    if (result === null || result instanceof Promise) {\n      return null;\n    }\n\n    if (clone) {\n      return this.cloneResult(result);\n    } else {\n      return result;\n    }\n  } // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n\n\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase();\n\n    if (!(key in this._cache)) {\n      // replace the promise with a copy of the parsed data for immediate processing\n      this._cache[key] = this.fetchData(fileName).then(text => {\n        const info = this.parse(text, fileName);\n        this._cache[key] = info;\n        return info;\n      });\n    }\n\n    await this._cache[key];\n  } // sets the data in the cache from parsed data\n\n\n  setData(fileName, text) {\n    const key = fileName.toLowerCase();\n    this._cache[key] = this.parse(text, fileName);\n  }\n\n} // returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\n\n\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n\n  return materialHierarchy[colorCode] || null;\n} // Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\n\n\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  } // Convert the given file information into a mesh by processing subobjects.\n\n\n  async processIntoMesh(info) {\n    const loader = this.loader;\n    const parseCache = this.parseCache;\n    const faceMaterials = new Set(); // Processes the part subobject information to load child parts and merge geometry onto part\n    // piece object.\n\n    const processInfoSubobjects = async (info, subobject = null) => {\n      const subobjects = info.subobjects;\n      const promises = []; // Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n      // group which lets instruction steps apply correctly.\n\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject = subobjects[i];\n        const promise = parseCache.ensureDataLoaded(subobject.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject.fileName, false);\n\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject.fileName).catch(error => {\n              console.warn(error);\n              return null;\n            });\n          }\n\n          return processInfoSubobjects(parseCache.getData(subobject.fileName), subobject);\n        });\n        promises.push(promise);\n      }\n\n      const group = new Group();\n      group.userData.category = info.category;\n      group.userData.keywords = info.keywords;\n      info.group = group;\n      const subobjectInfos = await Promise.all(promises);\n\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject = info.subobjects[i];\n        const subobjectInfo = subobjectInfos[i];\n\n        if (subobjectInfo === null) {\n          // the subobject failed to load\n          continue;\n        } // if the subobject was loaded as a separate group then apply the parent scopes materials\n\n\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo;\n          subobject.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n          subobjectGroup.userData.startingConstructionStep = subobject.startingConstructionStep;\n          subobjectGroup.name = subobject.fileName;\n          loader.applyMaterialsToMesh(subobjectGroup, subobject.colorCode, info.materials);\n          group.add(subobjectGroup);\n          continue;\n        } // add the subobject group if it has children in case it has both children and primitives\n\n\n        if (subobjectInfo.group.children.length) {\n          group.add(subobjectInfo.group);\n        } // transform the primitives into the local space of the parent piece and append them to\n        // to the parent primitives list.\n\n\n        const parentLineSegments = info.lineSegments;\n        const parentConditionalSegments = info.conditionalSegments;\n        const parentFaces = info.faces;\n        const lineSegments = subobjectInfo.lineSegments;\n        const conditionalSegments = subobjectInfo.conditionalSegments;\n        const faces = subobjectInfo.faces;\n        const matrix = subobject.matrix;\n        const inverted = subobject.inverted;\n        const matrixScaleInverted = matrix.determinant() < 0;\n        const colorCode = subobject.colorCode;\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\n          const ls = lineSegments[i];\n          const vertices = ls.vertices;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info.materials, true);\n          parentLineSegments.push(ls);\n        }\n\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n          const os = conditionalSegments[i];\n          const vertices = os.vertices;\n          const controlPoints = os.controlPoints;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          controlPoints[0].applyMatrix4(matrix);\n          controlPoints[1].applyMatrix4(matrix);\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info.materials, true);\n          parentConditionalSegments.push(os);\n        }\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const tri = faces[i];\n          const vertices = tri.vertices;\n\n          for (let i = 0, l = vertices.length; i < l; i++) {\n            vertices[i].applyMatrix4(matrix);\n          }\n\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info.materials, false);\n          faceMaterials.add(tri.colorCode); // If the scale of the object is negated then the triangle winding order\n          // needs to be flipped.\n\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse();\n          }\n\n          parentFaces.push(tri);\n        }\n\n        info.totalFaces += subobjectInfo.totalFaces;\n      } // Apply the parent subobjects pass through material code to this object. This is done several times due\n      // to material scoping.\n\n\n      if (subobject) {\n        loader.applyMaterialsToMesh(group, subobject.colorCode, info.materials);\n      }\n\n      return info;\n    }; // Track material use to see if we need to use the normal smooth slow path for hard edges.\n\n\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode);\n    }\n\n    await processInfoSubobjects(info);\n\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1;\n      generateFaceNormals(info.faces);\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n    } // Add the primitive objects and metadata.\n\n\n    const group = info.group;\n\n    if (info.faces.length > 0) {\n      group.add(createObject(info.faces, 3, false, info.totalFaces));\n    }\n\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(info.lineSegments, 2));\n    }\n\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(info.conditionalSegments, 2, true));\n    }\n\n    return group;\n  }\n\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache;\n  }\n\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase();\n      const group = await this._cache[key];\n      return group.clone();\n    } else {\n      return null;\n    }\n  } // Loads and parses the model with the given file name. Returns a cached copy if available.\n\n\n  async loadModel(fileName) {\n    const parseCache = this.parseCache;\n    const key = fileName.toLowerCase();\n\n    if (this.hasCachedModel(fileName)) {\n      // Return cached model if available.\n      return this.getCachedModel(fileName);\n    } else {\n      // Otherwise parse a new model.\n      // Ensure the file data is loaded and pre parsed.\n      await parseCache.ensureDataLoaded(fileName);\n      const info = parseCache.getData(fileName);\n      const promise = this.processIntoMesh(info); // Now that the file has loaded it's possible that another part parse has been waiting in parallel\n      // so check the cache again to see if it's been added since the last async operation so we don't\n      // do unnecessary work.\n\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName);\n      } // Cache object if it's a part so it can be reused later.\n\n\n      if (isPartType(info.type)) {\n        this._cache[key] = promise;\n      } // return a copy\n\n\n      const group = await promise;\n      return group.clone();\n    }\n  } // parses the given model text into a renderable object. Returns cached copy if available.\n\n\n  async parseModel(text) {\n    const parseCache = this.parseCache;\n    const info = parseCache.parse(text);\n\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName);\n    }\n\n    return this.processIntoMesh(info);\n  }\n\n}\n\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n\n  return 1;\n}\n\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n  // Sort the faces or line segments by color code to make later the mesh groups\n  elements.sort(sortByMaterial);\n\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n\n  const positions = new Float32Array(elementSize * totalElements * 3);\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  const materials = [];\n  const quadArray = new Array(6);\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n  let offset = 0;\n\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    let vertices = elem.vertices;\n\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j];\n      const index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    } // create the normals array if this is a set of faces\n\n\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0];\n        const v1 = vertices[1];\n        const v2 = vertices[2];\n\n        _tempVec0.subVectors(v1, v0);\n\n        _tempVec1.subVectors(v2, v1);\n\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n\n      let elemNormals = elem.normals;\n\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        // use face normal if a vertex normal is not provided\n        let n = elem.faceNormal;\n\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm;\n        }\n\n        const index = offset + j * 3;\n        normals[index + 0] = n.x;\n        normals[index + 1] = n.y;\n        normals[index + 2] = n.z;\n      }\n    }\n\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n\n      const material = elem.material;\n\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        // If a material has not been made available yet then keep the color code string in the material array\n        // to save the spot for the material once a parent scopes materials are being applied to the object.\n        materials.push(elem.colorCode);\n      }\n\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n\n    offset += 3 * vertices.length;\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n\n  bufferGeometry.setAttribute('position', new BufferAttribute(positions, 3));\n\n  if (normals !== null) {\n    bufferGeometry.setAttribute('normal', new BufferAttribute(normals, 3));\n  }\n\n  let object3d = null;\n\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const vertices = os.vertices;\n      const controlPoints = os.controlPoints;\n      const c0 = controlPoints[0];\n      const c1 = controlPoints[1];\n      const v0 = vertices[0];\n      const v1 = vertices[1];\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n  }\n\n  return object3d;\n} //\n\n\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager); // Array of THREE.Material\n\n    this.materials = [];\n    this.materialLibrary = {}; // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    this.partsCache = new LDrawPartsGeometryCache(this); // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    this.fileMap = {}; // Initializes the materials library with default materials\n\n    this.setMaterials([]); // If this flag is set to true the vertex normals will be smoothed.\n\n    this.smoothNormals = true; // The path to load parts from the LDraw parts library from.\n\n    this.partsLibraryPath = '';\n  }\n\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path;\n    return this;\n  }\n\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    const text = await fileLoader.loadAsync(url);\n    const colorLineRegex = /^0 !COLOUR/;\n    const lines = text.split(/[\\n\\r]/g);\n    const materials = [];\n\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, '');\n        const material = this.parseColorMetaDirective(new LineParser(directive));\n        materials.push(material);\n      }\n    }\n\n    this.setMaterials(materials);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(url, text => {\n      this.partsCache.parseModel(text, this.materialLibrary).then(group => {\n        this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);\n        this.computeConstructionSteps(group);\n        onLoad(group);\n      }).catch(onError);\n    }, onProgress, onError);\n  }\n\n  parse(text, onLoad) {\n    this.partsCache.parseModel(text, this.materialLibrary).then(group => {\n      this.computeConstructionSteps(group);\n      onLoad(group);\n    });\n  }\n\n  setMaterials(materials) {\n    this.materialLibrary = {};\n    this.materials = [];\n\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i]);\n    } // Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n\n\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')));\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333')));\n    return this;\n  }\n\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n\n  addMaterial(material) {\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n    const matLib = this.materialLibrary;\n\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n      matLib[material.userData.code] = material;\n    }\n\n    return this;\n  }\n\n  getMaterial(colorCode) {\n    if (colorCode.startsWith('0x2')) {\n      // Special 'direct' material value (RGB color)\n      const color = colorCode.substring(3);\n      return this.parseColorMetaDirective(new LineParser('Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + ''));\n    }\n\n    return this.materialLibrary[colorCode] || null;\n  } // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n\n\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    // find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n    const loader = this;\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n    group.traverse(c => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i]);\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material);\n        }\n      }\n    }); // Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n    // (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n    // simply returned for the subsequent material application.\n\n    function getMaterial(c, colorCode) {\n      // if our parent is a passthrough color code and we don't have the current material color available then\n      // return early.\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode;\n      }\n\n      const forEdge = c.isLineSegments || c.isConditionalLine;\n      const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\n      if (isPassthrough) {\n        colorCode = parentColorCode;\n      }\n\n      let material = null;\n\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode];\n      } else if (finalMaterialPass) {\n        // see if we can get the final material from from the \"getMaterial\" function which will attempt to\n        // parse the \"direct\" colors\n        material = loader.getMaterial(colorCode);\n\n        if (material === null) {\n          // otherwise throw an error if this is final opportunity to set the material\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`);\n        }\n      } else {\n        return colorCode;\n      }\n\n      if (c.isLineSegments) {\n        material = material.userData.edgeMaterial;\n\n        if (c.isConditionalLine) {\n          material = material.userData.conditionalEdgeMaterial;\n        }\n      }\n\n      return material;\n    }\n  }\n\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE);\n  }\n\n  getMainEdgeMaterial() {\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n  }\n\n  parseColorMetaDirective(lineParser) {\n    // Parses a color definition and returns a THREE.Material\n    let code = null; // Triangle and line colors\n\n    let color = 0xff00ff;\n    let edgeColor = 0xff00ff; // Transparency\n\n    let alpha = 1;\n    let isTransparent = false; // Self-illumination:\n\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n\n    if (!name) {\n      throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.');\n    } // Parse tag tokens and their parameters\n\n\n    let token = null;\n\n    while (true) {\n      token = lineParser.getToken();\n\n      if (!token) {\n        break;\n      }\n\n      switch (token.toUpperCase()) {\n        case 'CODE':\n          code = lineParser.getToken();\n          break;\n\n        case 'VALUE':\n          color = lineParser.getToken();\n\n          if (color.startsWith('0x')) {\n            color = '#' + color.substring(2);\n          } else if (!color.startsWith('#')) {\n            throw new Error('LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.');\n          }\n\n          break;\n\n        case 'EDGE':\n          edgeColor = lineParser.getToken();\n\n          if (edgeColor.startsWith('0x')) {\n            edgeColor = '#' + edgeColor.substring(2);\n          } else if (!edgeColor.startsWith('#')) {\n            // Try to see if edge color is a color code\n            edgeMaterial = this.getMaterial(edgeColor);\n\n            if (!edgeMaterial) {\n              throw new Error('LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.');\n            } // Get the edge material for this triangle material\n\n\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n\n          break;\n\n        case 'ALPHA':\n          alpha = parseInt(lineParser.getToken());\n\n          if (isNaN(alpha)) {\n            throw new Error('LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.');\n          }\n\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n\n          break;\n\n        case 'LUMINANCE':\n          luminance = parseInt(lineParser.getToken());\n\n          if (isNaN(luminance)) {\n            throw new Error('LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.');\n          }\n\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n\n        case 'CHROME':\n          finishType = FINISH_TYPE_CHROME;\n          break;\n\n        case 'PEARLESCENT':\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n\n        case 'RUBBER':\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n\n        case 'MATTE_METALLIC':\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n\n        case 'METAL':\n          finishType = FINISH_TYPE_METAL;\n          break;\n\n        case 'MATERIAL':\n          // Not implemented\n          lineParser.setToEnd();\n          break;\n\n        default:\n          throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.');\n      }\n    }\n\n    let material = null;\n\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.3,\n          metalness: 0\n        });\n        break;\n\n      case FINISH_TYPE_PEARLESCENT:\n        // Try to imitate pearlescency by making the surface glossy\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.3,\n          metalness: 0.25\n        });\n        break;\n\n      case FINISH_TYPE_CHROME:\n        // Mirror finish surface\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0,\n          metalness: 1\n        });\n        break;\n\n      case FINISH_TYPE_RUBBER:\n        // Rubber finish\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.9,\n          metalness: 0\n        });\n        break;\n\n      case FINISH_TYPE_MATTE_METALLIC:\n        // Brushed metal finish\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.8,\n          metalness: 0.4\n        });\n        break;\n\n      case FINISH_TYPE_METAL:\n        // Average metal finish\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.2,\n          metalness: 0.85\n        });\n        break;\n    }\n\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n\n    if (!edgeMaterial) {\n      // This is the material used for edges\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColor,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + ' - Edge'; // This is the material used for conditional edges\n\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: edgeColor,\n        opacity: alpha\n      });\n    }\n\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    this.addMaterial(material);\n    return material;\n  }\n\n  computeConstructionSteps(model) {\n    // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n    let stepNumber = 0;\n    model.traverse(c => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n\n}\n\nexport { LDrawLoader };","map":{"version":3,"sources":["/Users/osamakhan/Desktop/dev/Apple-Animated-React-Clone/node_modules/three-stdlib/loaders/LDrawLoader.js"],"names":["Vector3","Ray","Loader","FileLoader","MeshStandardMaterial","LineBasicMaterial","ShaderMaterial","UniformsUtils","UniformsLib","Color","BufferGeometry","BufferAttribute","LineSegments","Mesh","Matrix4","Group","FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","MAIN_COLOUR_CODE","MAIN_EDGE_COLOUR_CODE","_tempVec0","_tempVec1","LDrawConditionalLineMaterial","constructor","parameters","uniforms","merge","fog","diffuse","value","opacity","vertexShader","fragmentShader","Object","defineProperties","get","set","color","setValues","isLDrawConditionalLineMaterial","ConditionalLineSegments","geometry","material","isConditionalLine","generateFaceNormals","faces","i","l","length","face","vertices","v0","v1","v2","subVectors","faceNormal","crossVectors","normalize","_ray","smoothNormals","lineSegments","checkSubSegments","hashMultiplier","hashVertex","v","x","y","z","hashEdge","toNormalizedRay","targetRay","direction","scalar","dot","origin","copy","addScaledVector","hashRay","ray","hardEdges","Set","hardEdgeRays","Map","halfEdgeList","normals","ls","add","rh1","has","rh2","info","distances","d0","d1","push","tri","vertCount","i2","index","next","hash","rayHash","found","halfEdge","key","queue","pop","vertNormals","reverseHash","otherInfo","otherTri","otherIndex","otherNormals","otherVertCount","otherFaceNormal","Math","abs","otherNext","norm","sharedNormal1","sharedNormal2","isPartType","type","isPrimitiveType","test","LineParser","line","lineNumber","lineLength","currentCharIndex","currentChar","seekNonSpace","charAt","getToken","pos0","pos1","substring","getVector","parseFloat","getRemainingString","isAtTheEnd","setToEnd","getLineNumberString","LDrawParsedCache","loader","_cache","cloneResult","original","result","map","colorCode","clone","conditionalSegments","controlPoints","category","keywords","subobjects","totalFaces","startingConstructionStep","materials","group","fetchData","fileName","triedLowerCase","locationState","subobjectURL","lastIndexOf","toLowerCase","fileLoader","manager","setPath","partsLibraryPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","loadAsync","Error","parse","getLocalMaterial","indexOf","replace","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","lineIndex","startsWith","setData","lp","lineType","segment","ccw","doubleSided","v3","c0","c1","meta","parseColorMetaDirective","userData","code","console","warn","newKeywords","forEach","keyword","trim","token","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","matrix","fileMap","inverted","getData","Promise","ensureDataLoaded","then","getMaterialFromCode","parentColorCode","materialHierarchy","forEdge","isPassthrough","LDrawPartsGeometryCache","parseCache","processIntoMesh","faceMaterials","processInfoSubobjects","subobject","promises","promise","subobjectInfo","loadModel","catch","error","subobjectInfos","all","isGroup","subobjectGroup","decompose","position","quaternion","scale","name","applyMaterialsToMesh","children","parentLineSegments","parentConditionalSegments","parentFaces","matrixScaleInverted","determinant","lineColorCode","applyMatrix4","os","reverse","size","createObject","hasCachedModel","getCachedModel","parseModel","sortByMaterial","a","b","elements","elementSize","isConditionalSegments","totalElements","sort","positions","Float32Array","quadArray","Array","bufferGeometry","prevMaterial","index0","numGroupVerts","offset","iElem","nElem","elem","j","elemNormals","n","addGroup","edgeMaterial","conditionalEdgeMaterial","Infinity","setAttribute","object3d","controlArray0","controlArray1","directionArray","LDrawLoader","materialLibrary","partsCache","setMaterials","setPartsLibraryPath","path","preloadMaterials","url","colorLineRegex","directive","load","onLoad","onProgress","onError","computeConstructionSteps","addMaterial","setFileMap","matLib","getMaterial","finalMaterialPass","parentIsPassthrough","traverse","c","isMesh","isLineSegments","isArray","isMaterial","getMainMaterial","getMainEdgeMaterial","lineParser","edgeColor","alpha","isTransparent","luminance","finishType","toUpperCase","parseInt","isNaN","max","min","roughness","metalness","transparent","premultipliedAlpha","depthWrite","polygonOffset","polygonOffsetFactor","emissive","multiplyScalar","model","stepNumber","constructionStep","numConstructionSteps"],"mappings":"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","sourcesContent":["import { Vector3, Ray, Loader, FileLoader, MeshStandardMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Color, BufferGeometry, BufferAttribute, LineSegments, Mesh, Matrix4, Group } from 'three';\n\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\n\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst MAIN_COLOUR_CODE = '16';\nconst MAIN_EDGE_COLOUR_CODE = '24';\n\nconst _tempVec0 = new Vector3();\n\nconst _tempVec1 = new Vector3();\n\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([UniformsLib.fog, {\n        diffuse: {\n          value: new Color()\n        },\n        opacity: {\n          value: 1.0\n        }\n      }]),\n      vertexShader:\n      /* glsl */\n      `\n        attribute vec3 control0;\n        attribute vec3 control1;\n        attribute vec3 direction;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n          #include <color_vertex>\n\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n\n          // Transform the line segment ends and control points into camera clip space\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\n\n          c0.xy /= c0.w;\n          c1.xy /= c1.w;\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n\n          // Get the direction of the segment and an orthogonal vector\n          vec2 dir = p1.xy - p0.xy;\n          vec2 norm = vec2(-dir.y, dir.x);\n\n          // Get control point directions from the line\n          vec2 c0dir = c0.xy - p1.xy;\n          vec2 c1dir = c1.xy - p1.xy;\n\n          // If the vectors to the controls points are pointed in different directions away\n          // from the line segment then the line should not be drawn.\n          float d0 = dot(normalize(norm), normalize(c0dir));\n          float d1 = dot(normalize(norm), normalize(c1dir));\n          discardFlag = float(sign(d0) != sign(d1));\n\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #include <fog_vertex>\n        }\n      `,\n      fragmentShader:\n      /* glsl */\n      `\n        uniform vec3 diffuse;\n        uniform float opacity;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n          if (discardFlag > 0.5) discard;\n\n          #include <clipping_planes_fragment>\n          vec3 outgoingLight = vec3(0.0);\n          vec4 diffuseColor = vec4(diffuse, opacity);\n          #include <logdepthbuf_fragment>\n          #include <color_fragment>\n          outgoingLight = diffuseColor.rgb; // simple shader\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n          #include <tonemapping_fragment>\n          #include <encodings_fragment>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n        }\n      `\n    });\n    Object.defineProperties(this, {\n      opacity: {\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function () {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n    this.setValues(parameters);\n    this.isLDrawConditionalLineMaterial = true;\n  }\n\n}\n\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isConditionalLine = true;\n  }\n\n}\n\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i];\n    const vertices = face.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    const v2 = vertices[2];\n\n    _tempVec0.subVectors(v1, v0);\n\n    _tempVec1.subVectors(v2, v1);\n\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\n\nconst _ray = new Ray();\n\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  // NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n  // it allows edges to be smoothed as expected (see minifig arms).\n  // --\n  // And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n  // point errors on vertices along quantization boundaries. Ie after matrix multiplication\n  // vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n  // get merged. This added epsilon attempts to push these error values to the same quantized\n  // value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n  const hashMultiplier = (1 + 1e-10) * 1e2;\n\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  } // converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n  // onto the original line.\n\n\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    const scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n\n  const hardEdges = new Set();\n  const hardEdgeRays = new Map();\n  const halfEdgeList = {};\n  const normals = []; // Save the list of hard edges by hash\n\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const vertices = ls.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0)); // only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n    // and requires more memory.\n\n    if (checkSubSegments) {\n      // add both ray directions to the map\n      const ray = toNormalizedRay(v0, v1, new Ray());\n      const rh1 = hashRay(ray);\n\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        const rh2 = hashRay(ray);\n        const info = {\n          ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info);\n        hardEdgeRays.set(rh2, info);\n      } // store both segments ends in min, max order in the distances array to check if a face edge is a\n      // subsegment later.\n\n\n      const info = hardEdgeRays.get(rh1);\n      let d0 = info.ray.direction.dot(v0);\n      let d1 = info.ray.direction.dot(v1);\n\n      if (d0 > d1) {\n        [d0, d1] = [d1, d0];\n      }\n\n      info.distances.push(d0, d1);\n    }\n  } // track the half edges associated with each triangle\n\n\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i];\n    const vertices = tri.vertices;\n    const vertCount = vertices.length;\n\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % vertCount;\n      const v0 = vertices[index];\n      const v1 = vertices[next];\n      const hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\n\n      if (hardEdges.has(hash)) {\n        continue;\n      } // if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n\n\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray);\n        const rayHash = hashRay(_ray);\n\n        if (hardEdgeRays.has(rayHash)) {\n          const info = hardEdgeRays.get(rayHash);\n          const {\n            ray,\n            distances\n          } = info;\n          let d0 = ray.direction.dot(v0);\n          let d1 = ray.direction.dot(v1);\n\n          if (d0 > d1) {\n            [d0, d1] = [d1, d0];\n          } // return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n\n\n          let found = false;\n\n          for (let i = 0, l = distances.length; i < l; i += 2) {\n            if (d0 >= distances[i] && d1 <= distances[i + 1]) {\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            continue;\n          }\n        }\n      }\n\n      const info = {\n        index: index,\n        tri: tri\n      };\n      halfEdgeList[hash] = info;\n    }\n  } // Iterate until we've tried to connect all faces to share normals\n\n\n  while (true) {\n    // Stop if there are no more faces left\n    let halfEdge = null;\n\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n\n    if (halfEdge === null) {\n      break;\n    } // Exhaustively find all connected faces\n\n\n    const queue = [halfEdge];\n\n    while (queue.length > 0) {\n      // initialize all vertex normals in this triangle\n      const tri = queue.pop().tri;\n      const vertices = tri.vertices;\n      const vertNormals = tri.normals;\n      const faceNormal = tri.faceNormal; // Check if any edge is connected to another triangle edge\n\n      const vertCount = vertices.length;\n\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % vertCount;\n        const v0 = vertices[index];\n        const v1 = vertices[next]; // delete this triangle from the list so it won't be found again\n\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherInfo = halfEdgeList[reverseHash];\n\n        if (otherInfo) {\n          const otherTri = otherInfo.tri;\n          const otherIndex = otherInfo.index;\n          const otherNormals = otherTri.normals;\n          const otherVertCount = otherNormals.length;\n          const otherFaceNormal = otherTri.faceNormal; // NOTE: If the angle between faces is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          } // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n\n\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          } // share the first normal\n\n\n          const otherNext = (otherIndex + 1) % otherVertCount;\n\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm);\n            vertNormals[index].norm = otherNormals[otherNext].norm;\n          }\n\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];\n\n          if (sharedNormal1 === null) {\n            // it's possible to encounter an edge of a triangle that has already been traversed meaning\n            // both edges already have different normals defined and shared. To work around this we create\n            // a wrapper object so when those edges are merged the normals can be updated everywhere.\n            sharedNormal1 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal1.norm);\n          }\n\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          } // share the second normal\n\n\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm);\n            vertNormals[next].norm = otherNormals[otherIndex].norm;\n          }\n\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];\n\n          if (sharedNormal2 === null) {\n            sharedNormal2 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal2.norm);\n          }\n\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\n\nfunction isPartType(type) {\n  return type === 'Part' || type === 'Unofficial_Part';\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart';\n}\n\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n        return;\n      }\n\n      this.currentCharIndex++;\n    }\n  }\n\n  getToken() {\n    const pos0 = this.currentCharIndex++; // Seek space\n\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\n        break;\n      }\n\n      this.currentCharIndex++;\n    }\n\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n  }\n\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n  }\n\n} // Fetches and parses an intermediate representation of LDraw parts files.\n\n\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader;\n    this._cache = {};\n  }\n\n  cloneResult(original) {\n    const result = {}; // vertices are transformed and normals computed before being converted to geometry\n    // so these pieces must be cloned.\n\n    result.faces = original.faces.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null\n      };\n    });\n    result.conditionalSegments = original.conditionalSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        controlPoints: face.controlPoints.map(v => v.clone())\n      };\n    });\n    result.lineSegments = original.lineSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone())\n      };\n    }); // none if this is subsequently modified\n\n    result.type = original.type;\n    result.category = original.category;\n    result.keywords = original.keywords;\n    result.subobjects = original.subobjects;\n    result.totalFaces = original.totalFaces;\n    result.startingConstructionStep = original.startingConstructionStep;\n    result.materials = original.materials;\n    result.group = null;\n    return result;\n  }\n\n  async fetchData(fileName) {\n    let triedLowerCase = false;\n    let locationState = FILE_LOCATION_AS_IS;\n\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName;\n\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = 'parts/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = 'p/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = 'models/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf('/') + 1) + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            // Try absolute path\n            locationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            // Next attempt is lower case\n            fileName = fileName.toLowerCase();\n            subobjectURL = fileName;\n            triedLowerCase = true;\n            locationState = FILE_LOCATION_AS_IS;\n          }\n\n          break;\n      }\n\n      const loader = this.loader;\n      const fileLoader = new FileLoader(loader.manager);\n      fileLoader.setPath(loader.partsLibraryPath);\n      fileLoader.setRequestHeader(loader.requestHeader);\n      fileLoader.setWithCredentials(loader.withCredentials);\n\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL);\n        return text;\n      } catch {\n        continue;\n      }\n    }\n\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n  }\n\n  parse(text, fileName = null) {\n    const loader = this.loader; // final results\n\n    const faces = [];\n    const lineSegments = [];\n    const conditionalSegments = [];\n    const subobjects = [];\n    const materials = {};\n\n    const getLocalMaterial = colorCode => {\n      return materials[colorCode] || null;\n    };\n\n    let type = 'Model';\n    let category = null;\n    let keywords = null;\n    let totalFaces = 0; // split into lines\n\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n');\n    }\n\n    const lines = text.split('\\n');\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let startingConstructionStep = false; // Parse all line commands\n\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0) continue;\n\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith('0 FILE ')) {\n          // Save previous embedded file in the cache\n          this.setData(currentEmbeddedFileName, currentEmbeddedText); // New embedded text file\n\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = '';\n        } else {\n          currentEmbeddedText += line + '\\n';\n        }\n\n        continue;\n      }\n\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n\n      if (lp.isAtTheEnd()) {\n        // Empty line\n        continue;\n      } // Parse the line type\n\n\n      const lineType = lp.getToken();\n      let material;\n      let colorCode;\n      let segment;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, c0, c1;\n\n      switch (lineType) {\n        // Line type 0: Comment or META\n        case '0':\n          // Parse meta directive\n          const meta = lp.getToken();\n\n          if (meta) {\n            switch (meta) {\n              case '!LDRAW_ORG':\n                type = lp.getToken();\n                break;\n\n              case '!COLOUR':\n                material = loader.parseColorMetaDirective(lp);\n\n                if (material) {\n                  materials[material.userData.code] = material;\n                } else {\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                }\n\n                break;\n\n              case '!CATEGORY':\n                category = lp.getToken();\n                break;\n\n              case '!KEYWORDS':\n                const newKeywords = lp.getRemainingString().split(',');\n\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n\n                break;\n\n              case 'FILE':\n                if (lineIndex > 0) {\n                  // Start embedded text files parsing\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = '';\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n\n                break;\n\n              case 'BFC':\n                // Changes to the backface culling state\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n\n                  switch (token) {\n                    case 'CERTIFY':\n                    case 'NOCERTIFY':\n                      bfcCertified = token === 'CERTIFY';\n                      bfcCCW = true;\n                      break;\n\n                    case 'CW':\n                    case 'CCW':\n                      bfcCCW = token === 'CCW';\n                      break;\n\n                    case 'INVERTNEXT':\n                      bfcInverted = true;\n                      break;\n\n                    case 'CLIP':\n                    case 'NOCLIP':\n                      bfcCull = token === 'CLIP';\n                      break;\n\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n\n                break;\n\n              case 'STEP':\n                startingConstructionStep = true;\n                break;\n            }\n          }\n\n          break;\n        // Line type 1: Sub-object file\n\n        case '1':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n\n          if (loader.fileMap[fileName]) {\n            // Found the subobject path in the preloaded file path map\n            fileName = loader.fileMap[fileName];\n          } else {\n            // Standardized subfolders\n            if (fileName.startsWith('s/')) {\n              fileName = 'parts/' + fileName;\n            } else if (fileName.startsWith('48/')) {\n              fileName = 'p/' + fileName;\n            }\n          }\n\n          subobjects.push({\n            material: material,\n            colorCode: colorCode,\n            matrix: matrix,\n            fileName: fileName,\n            inverted: bfcInverted,\n            startingConstructionStep: startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        // Line type 2: Line segment\n\n        case '2':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1]\n          };\n          lineSegments.push(segment);\n          break;\n        // Line type 5: Conditional Line segment\n\n        case '5':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          c0 = lp.getVector();\n          c1 = lp.getVector();\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1]\n          };\n          conditionalSegments.push(segment);\n          break;\n        // Line type 3: Triangle\n\n        case '3':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n          } else {\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null]\n          });\n          totalFaces++;\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n          }\n\n          break;\n        // Line type 4: Quadrilateral\n\n        case '4':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n            v3 = lp.getVector();\n          } else {\n            v3 = lp.getVector();\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          } // specifically place the triangle diagonal in the v0 and v1 slots so we can\n          // account for the doubling of vertices later when smoothing normals.\n\n\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null]\n          });\n          totalFaces += 2;\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n          }\n\n          break;\n\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.');\n      }\n    }\n\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText);\n    }\n\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      subobjects,\n      totalFaces,\n      startingConstructionStep,\n      materials,\n      fileName,\n      group: null\n    };\n  } // returns an (optionally cloned) instance of the data\n\n\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase();\n    const result = this._cache[key];\n\n    if (result === null || result instanceof Promise) {\n      return null;\n    }\n\n    if (clone) {\n      return this.cloneResult(result);\n    } else {\n      return result;\n    }\n  } // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n\n\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase();\n\n    if (!(key in this._cache)) {\n      // replace the promise with a copy of the parsed data for immediate processing\n      this._cache[key] = this.fetchData(fileName).then(text => {\n        const info = this.parse(text, fileName);\n        this._cache[key] = info;\n        return info;\n      });\n    }\n\n    await this._cache[key];\n  } // sets the data in the cache from parsed data\n\n\n  setData(fileName, text) {\n    const key = fileName.toLowerCase();\n    this._cache[key] = this.parse(text, fileName);\n  }\n\n} // returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\n\n\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n\n  return materialHierarchy[colorCode] || null;\n} // Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\n\n\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  } // Convert the given file information into a mesh by processing subobjects.\n\n\n  async processIntoMesh(info) {\n    const loader = this.loader;\n    const parseCache = this.parseCache;\n    const faceMaterials = new Set(); // Processes the part subobject information to load child parts and merge geometry onto part\n    // piece object.\n\n    const processInfoSubobjects = async (info, subobject = null) => {\n      const subobjects = info.subobjects;\n      const promises = []; // Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n      // group which lets instruction steps apply correctly.\n\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject = subobjects[i];\n        const promise = parseCache.ensureDataLoaded(subobject.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject.fileName, false);\n\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject.fileName).catch(error => {\n              console.warn(error);\n              return null;\n            });\n          }\n\n          return processInfoSubobjects(parseCache.getData(subobject.fileName), subobject);\n        });\n        promises.push(promise);\n      }\n\n      const group = new Group();\n      group.userData.category = info.category;\n      group.userData.keywords = info.keywords;\n      info.group = group;\n      const subobjectInfos = await Promise.all(promises);\n\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject = info.subobjects[i];\n        const subobjectInfo = subobjectInfos[i];\n\n        if (subobjectInfo === null) {\n          // the subobject failed to load\n          continue;\n        } // if the subobject was loaded as a separate group then apply the parent scopes materials\n\n\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo;\n          subobject.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n          subobjectGroup.userData.startingConstructionStep = subobject.startingConstructionStep;\n          subobjectGroup.name = subobject.fileName;\n          loader.applyMaterialsToMesh(subobjectGroup, subobject.colorCode, info.materials);\n          group.add(subobjectGroup);\n          continue;\n        } // add the subobject group if it has children in case it has both children and primitives\n\n\n        if (subobjectInfo.group.children.length) {\n          group.add(subobjectInfo.group);\n        } // transform the primitives into the local space of the parent piece and append them to\n        // to the parent primitives list.\n\n\n        const parentLineSegments = info.lineSegments;\n        const parentConditionalSegments = info.conditionalSegments;\n        const parentFaces = info.faces;\n        const lineSegments = subobjectInfo.lineSegments;\n        const conditionalSegments = subobjectInfo.conditionalSegments;\n        const faces = subobjectInfo.faces;\n        const matrix = subobject.matrix;\n        const inverted = subobject.inverted;\n        const matrixScaleInverted = matrix.determinant() < 0;\n        const colorCode = subobject.colorCode;\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\n          const ls = lineSegments[i];\n          const vertices = ls.vertices;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info.materials, true);\n          parentLineSegments.push(ls);\n        }\n\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n          const os = conditionalSegments[i];\n          const vertices = os.vertices;\n          const controlPoints = os.controlPoints;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          controlPoints[0].applyMatrix4(matrix);\n          controlPoints[1].applyMatrix4(matrix);\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info.materials, true);\n          parentConditionalSegments.push(os);\n        }\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const tri = faces[i];\n          const vertices = tri.vertices;\n\n          for (let i = 0, l = vertices.length; i < l; i++) {\n            vertices[i].applyMatrix4(matrix);\n          }\n\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info.materials, false);\n          faceMaterials.add(tri.colorCode); // If the scale of the object is negated then the triangle winding order\n          // needs to be flipped.\n\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse();\n          }\n\n          parentFaces.push(tri);\n        }\n\n        info.totalFaces += subobjectInfo.totalFaces;\n      } // Apply the parent subobjects pass through material code to this object. This is done several times due\n      // to material scoping.\n\n\n      if (subobject) {\n        loader.applyMaterialsToMesh(group, subobject.colorCode, info.materials);\n      }\n\n      return info;\n    }; // Track material use to see if we need to use the normal smooth slow path for hard edges.\n\n\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode);\n    }\n\n    await processInfoSubobjects(info);\n\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1;\n      generateFaceNormals(info.faces);\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n    } // Add the primitive objects and metadata.\n\n\n    const group = info.group;\n\n    if (info.faces.length > 0) {\n      group.add(createObject(info.faces, 3, false, info.totalFaces));\n    }\n\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(info.lineSegments, 2));\n    }\n\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(info.conditionalSegments, 2, true));\n    }\n\n    return group;\n  }\n\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache;\n  }\n\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase();\n      const group = await this._cache[key];\n      return group.clone();\n    } else {\n      return null;\n    }\n  } // Loads and parses the model with the given file name. Returns a cached copy if available.\n\n\n  async loadModel(fileName) {\n    const parseCache = this.parseCache;\n    const key = fileName.toLowerCase();\n\n    if (this.hasCachedModel(fileName)) {\n      // Return cached model if available.\n      return this.getCachedModel(fileName);\n    } else {\n      // Otherwise parse a new model.\n      // Ensure the file data is loaded and pre parsed.\n      await parseCache.ensureDataLoaded(fileName);\n      const info = parseCache.getData(fileName);\n      const promise = this.processIntoMesh(info); // Now that the file has loaded it's possible that another part parse has been waiting in parallel\n      // so check the cache again to see if it's been added since the last async operation so we don't\n      // do unnecessary work.\n\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName);\n      } // Cache object if it's a part so it can be reused later.\n\n\n      if (isPartType(info.type)) {\n        this._cache[key] = promise;\n      } // return a copy\n\n\n      const group = await promise;\n      return group.clone();\n    }\n  } // parses the given model text into a renderable object. Returns cached copy if available.\n\n\n  async parseModel(text) {\n    const parseCache = this.parseCache;\n    const info = parseCache.parse(text);\n\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName);\n    }\n\n    return this.processIntoMesh(info);\n  }\n\n}\n\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n\n  return 1;\n}\n\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n  // Sort the faces or line segments by color code to make later the mesh groups\n  elements.sort(sortByMaterial);\n\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n\n  const positions = new Float32Array(elementSize * totalElements * 3);\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  const materials = [];\n  const quadArray = new Array(6);\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n  let offset = 0;\n\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    let vertices = elem.vertices;\n\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j];\n      const index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    } // create the normals array if this is a set of faces\n\n\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0];\n        const v1 = vertices[1];\n        const v2 = vertices[2];\n\n        _tempVec0.subVectors(v1, v0);\n\n        _tempVec1.subVectors(v2, v1);\n\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n\n      let elemNormals = elem.normals;\n\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        // use face normal if a vertex normal is not provided\n        let n = elem.faceNormal;\n\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm;\n        }\n\n        const index = offset + j * 3;\n        normals[index + 0] = n.x;\n        normals[index + 1] = n.y;\n        normals[index + 2] = n.z;\n      }\n    }\n\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n\n      const material = elem.material;\n\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        // If a material has not been made available yet then keep the color code string in the material array\n        // to save the spot for the material once a parent scopes materials are being applied to the object.\n        materials.push(elem.colorCode);\n      }\n\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n\n    offset += 3 * vertices.length;\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n\n  bufferGeometry.setAttribute('position', new BufferAttribute(positions, 3));\n\n  if (normals !== null) {\n    bufferGeometry.setAttribute('normal', new BufferAttribute(normals, 3));\n  }\n\n  let object3d = null;\n\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const vertices = os.vertices;\n      const controlPoints = os.controlPoints;\n      const c0 = controlPoints[0];\n      const c1 = controlPoints[1];\n      const v0 = vertices[0];\n      const v1 = vertices[1];\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n  }\n\n  return object3d;\n} //\n\n\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager); // Array of THREE.Material\n\n    this.materials = [];\n    this.materialLibrary = {}; // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    this.partsCache = new LDrawPartsGeometryCache(this); // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    this.fileMap = {}; // Initializes the materials library with default materials\n\n    this.setMaterials([]); // If this flag is set to true the vertex normals will be smoothed.\n\n    this.smoothNormals = true; // The path to load parts from the LDraw parts library from.\n\n    this.partsLibraryPath = '';\n  }\n\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path;\n    return this;\n  }\n\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    const text = await fileLoader.loadAsync(url);\n    const colorLineRegex = /^0 !COLOUR/;\n    const lines = text.split(/[\\n\\r]/g);\n    const materials = [];\n\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, '');\n        const material = this.parseColorMetaDirective(new LineParser(directive));\n        materials.push(material);\n      }\n    }\n\n    this.setMaterials(materials);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(url, text => {\n      this.partsCache.parseModel(text, this.materialLibrary).then(group => {\n        this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);\n        this.computeConstructionSteps(group);\n        onLoad(group);\n      }).catch(onError);\n    }, onProgress, onError);\n  }\n\n  parse(text, onLoad) {\n    this.partsCache.parseModel(text, this.materialLibrary).then(group => {\n      this.computeConstructionSteps(group);\n      onLoad(group);\n    });\n  }\n\n  setMaterials(materials) {\n    this.materialLibrary = {};\n    this.materials = [];\n\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i]);\n    } // Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n\n\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')));\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333')));\n    return this;\n  }\n\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n\n  addMaterial(material) {\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n    const matLib = this.materialLibrary;\n\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n      matLib[material.userData.code] = material;\n    }\n\n    return this;\n  }\n\n  getMaterial(colorCode) {\n    if (colorCode.startsWith('0x2')) {\n      // Special 'direct' material value (RGB color)\n      const color = colorCode.substring(3);\n      return this.parseColorMetaDirective(new LineParser('Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + ''));\n    }\n\n    return this.materialLibrary[colorCode] || null;\n  } // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n\n\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    // find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n    const loader = this;\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n    group.traverse(c => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i]);\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material);\n        }\n      }\n    }); // Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n    // (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n    // simply returned for the subsequent material application.\n\n    function getMaterial(c, colorCode) {\n      // if our parent is a passthrough color code and we don't have the current material color available then\n      // return early.\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode;\n      }\n\n      const forEdge = c.isLineSegments || c.isConditionalLine;\n      const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\n      if (isPassthrough) {\n        colorCode = parentColorCode;\n      }\n\n      let material = null;\n\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode];\n      } else if (finalMaterialPass) {\n        // see if we can get the final material from from the \"getMaterial\" function which will attempt to\n        // parse the \"direct\" colors\n        material = loader.getMaterial(colorCode);\n\n        if (material === null) {\n          // otherwise throw an error if this is final opportunity to set the material\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`);\n        }\n      } else {\n        return colorCode;\n      }\n\n      if (c.isLineSegments) {\n        material = material.userData.edgeMaterial;\n\n        if (c.isConditionalLine) {\n          material = material.userData.conditionalEdgeMaterial;\n        }\n      }\n\n      return material;\n    }\n  }\n\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE);\n  }\n\n  getMainEdgeMaterial() {\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n  }\n\n  parseColorMetaDirective(lineParser) {\n    // Parses a color definition and returns a THREE.Material\n    let code = null; // Triangle and line colors\n\n    let color = 0xff00ff;\n    let edgeColor = 0xff00ff; // Transparency\n\n    let alpha = 1;\n    let isTransparent = false; // Self-illumination:\n\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n\n    if (!name) {\n      throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.');\n    } // Parse tag tokens and their parameters\n\n\n    let token = null;\n\n    while (true) {\n      token = lineParser.getToken();\n\n      if (!token) {\n        break;\n      }\n\n      switch (token.toUpperCase()) {\n        case 'CODE':\n          code = lineParser.getToken();\n          break;\n\n        case 'VALUE':\n          color = lineParser.getToken();\n\n          if (color.startsWith('0x')) {\n            color = '#' + color.substring(2);\n          } else if (!color.startsWith('#')) {\n            throw new Error('LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.');\n          }\n\n          break;\n\n        case 'EDGE':\n          edgeColor = lineParser.getToken();\n\n          if (edgeColor.startsWith('0x')) {\n            edgeColor = '#' + edgeColor.substring(2);\n          } else if (!edgeColor.startsWith('#')) {\n            // Try to see if edge color is a color code\n            edgeMaterial = this.getMaterial(edgeColor);\n\n            if (!edgeMaterial) {\n              throw new Error('LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.');\n            } // Get the edge material for this triangle material\n\n\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n\n          break;\n\n        case 'ALPHA':\n          alpha = parseInt(lineParser.getToken());\n\n          if (isNaN(alpha)) {\n            throw new Error('LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.');\n          }\n\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n\n          break;\n\n        case 'LUMINANCE':\n          luminance = parseInt(lineParser.getToken());\n\n          if (isNaN(luminance)) {\n            throw new Error('LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.');\n          }\n\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n\n        case 'CHROME':\n          finishType = FINISH_TYPE_CHROME;\n          break;\n\n        case 'PEARLESCENT':\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n\n        case 'RUBBER':\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n\n        case 'MATTE_METALLIC':\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n\n        case 'METAL':\n          finishType = FINISH_TYPE_METAL;\n          break;\n\n        case 'MATERIAL':\n          // Not implemented\n          lineParser.setToEnd();\n          break;\n\n        default:\n          throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.');\n      }\n    }\n\n    let material = null;\n\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.3,\n          metalness: 0\n        });\n        break;\n\n      case FINISH_TYPE_PEARLESCENT:\n        // Try to imitate pearlescency by making the surface glossy\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.3,\n          metalness: 0.25\n        });\n        break;\n\n      case FINISH_TYPE_CHROME:\n        // Mirror finish surface\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0,\n          metalness: 1\n        });\n        break;\n\n      case FINISH_TYPE_RUBBER:\n        // Rubber finish\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.9,\n          metalness: 0\n        });\n        break;\n\n      case FINISH_TYPE_MATTE_METALLIC:\n        // Brushed metal finish\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.8,\n          metalness: 0.4\n        });\n        break;\n\n      case FINISH_TYPE_METAL:\n        // Average metal finish\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.2,\n          metalness: 0.85\n        });\n        break;\n    }\n\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n\n    if (!edgeMaterial) {\n      // This is the material used for edges\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColor,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + ' - Edge'; // This is the material used for conditional edges\n\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: edgeColor,\n        opacity: alpha\n      });\n    }\n\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    this.addMaterial(material);\n    return material;\n  }\n\n  computeConstructionSteps(model) {\n    // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n    let stepNumber = 0;\n    model.traverse(c => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n\n}\n\nexport { LDrawLoader };\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber'; // From: https://github.com/mrdoob/three.js/blob/dev/examples/webgl_shadowmap_pcss.html\n\nconst pcss = ({\n  frustum = 3.75,\n  size = 0.005,\n  near = 9.5,\n  samples = 10,\n  rings = 11\n} = {}) => `#define LIGHT_WORLD_SIZE ${size}\n#define LIGHT_FRUSTUM_WIDTH ${frustum}\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n#define NEAR_PLANE ${near}\n\n#define NUM_SAMPLES ${samples}\n#define NUM_RINGS ${rings}\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n\nvec2 poissonDisk[NUM_SAMPLES];\n\nvoid initPoissonSamples( const in vec2 randomSeed ) {\n  float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n  float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n  // jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n  float angle = rand( randomSeed ) * PI2;\n  float radius = INV_NUM_SAMPLES;\n  float radiusStep = radius;\n\n  #pragma unroll_loop_start\n  for( int i = 0; i < ${samples}; i ++ ) {\n    poissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );\n    radius += radiusStep;\n    angle += ANGLE_STEP;\n  }\n  #pragma unroll_loop_end\n}\n\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n  return (zReceiver - zBlocker) / zBlocker;\n}\n\nfloat findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\n  // This uses similar triangles to compute what\n  // area of the shadow map we should search\n  float searchRadius = LIGHT_SIZE_UV * ( zReceiver - NEAR_PLANE ) / zReceiver;\n  float blockerDepthSum = 0.0;\n  float shadowMapDepth = 0.0;\n  int numBlockers = 0;  \n  #pragma unroll_loop_start\n  for( int i = 0; i < ${samples}; i++ ) {\n    shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n    if ( shadowMapDepth < zReceiver ) {\n      blockerDepthSum += shadowMapDepth;\n      numBlockers ++;\n    }\n  }\n  #pragma unroll_loop_end\n\n  if( numBlockers == 0 ) return -1.0;\n  return blockerDepthSum / float( numBlockers );\n}\n\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {\n  float sum = 0.0;\n  float depth;\n  #pragma unroll_loop_start\n  for( int i = 0; i < ${samples}; i ++ ) {\n    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );\n    if( zReceiver <= depth ) sum += 1.0;\n  }\n  #pragma unroll_loop_end\n  #pragma unroll_loop_start\n  for( int i = 0; i < ${samples}; i ++ ) {\n    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );\n    if( zReceiver <= depth ) sum += 1.0;\n  }\n  #pragma unroll_loop_end\n  return sum / ( 2.0 * float( ${samples} ) );\n}\n\nfloat PCSS ( sampler2D shadowMap, vec4 coords ) {\n  vec2 uv = coords.xy;\n  float zReceiver = coords.z; // Assumed to be eye-space z in this code\n\n  initPoissonSamples( uv );\n  // STEP 1: blocker search\n  float avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver );\n\n  //There are no occluders so early out (this saves filtering)\n  if( avgBlockerDepth == -1.0 ) return 1.0;\n\n  // STEP 2: penumbra size\n  float penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );\n  float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\n  // STEP 3: filtering\n  //return avgBlockerDepth;\n  return PCF_Filter( shadowMap, uv, zReceiver, filterRadius );\n}`;\n\nlet deployed = false;\n\nconst softShadows = props => {\n  // Avoid adding the effect twice, which may happen in HMR scenarios\n  if (!deployed) {\n    console.warn('drei/softShadows() is deprecated, use <SoftShadows> instead');\n    deployed = true;\n    let shader = THREE.ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss({ ...props\n    }));\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    THREE.ShaderChunk.shadowmap_pars_fragment = shader;\n  }\n};\n\nfunction reset(gl, scene, camera) {\n  scene.traverse(object => {\n    if (object.material) {\n      gl.properties.remove(object.material);\n      object.material.dispose();\n    }\n  });\n  gl.info.programs.length = 0;\n  gl.compile(scene, camera);\n}\n\nfunction SoftShadows({\n  frustum = 3.75,\n  size = 0.005,\n  near = 9.5,\n  samples = 10,\n  rings = 11\n}) {\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  React.useEffect(() => {\n    const original = THREE.ShaderChunk.shadowmap_pars_fragment;\n    let shader = THREE.ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss({\n      frustum,\n      size,\n      near,\n      samples,\n      rings\n    }));\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    THREE.ShaderChunk.shadowmap_pars_fragment = shader;\n    reset(gl, scene, camera);\n    return () => {\n      THREE.ShaderChunk.shadowmap_pars_fragment = original;\n      reset(gl, scene, camera);\n    };\n  }, [frustum, size, near, samples, rings]);\n}\n\nexport { SoftShadows, softShadows };","map":{"version":3,"sources":["/Users/osamakhan/Desktop/dev/Apple-Animated-React-Clone/node_modules/@react-three/drei/core/softShadows.js"],"names":["React","THREE","useThree","pcss","frustum","size","near","samples","rings","deployed","softShadows","props","console","warn","shader","ShaderChunk","shadowmap_pars_fragment","replace","reset","gl","scene","camera","traverse","object","material","properties","remove","dispose","info","programs","length","compile","SoftShadows","state","useEffect","original"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\n\n// From: https://github.com/mrdoob/three.js/blob/dev/examples/webgl_shadowmap_pcss.html\n\nconst pcss = ({\n  frustum = 3.75,\n  size = 0.005,\n  near = 9.5,\n  samples = 10,\n  rings = 11\n} = {}) => `#define LIGHT_WORLD_SIZE ${size}\n#define LIGHT_FRUSTUM_WIDTH ${frustum}\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n#define NEAR_PLANE ${near}\n\n#define NUM_SAMPLES ${samples}\n#define NUM_RINGS ${rings}\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n\nvec2 poissonDisk[NUM_SAMPLES];\n\nvoid initPoissonSamples( const in vec2 randomSeed ) {\n  float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n  float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n  // jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n  float angle = rand( randomSeed ) * PI2;\n  float radius = INV_NUM_SAMPLES;\n  float radiusStep = radius;\n\n  #pragma unroll_loop_start\n  for( int i = 0; i < ${samples}; i ++ ) {\n    poissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );\n    radius += radiusStep;\n    angle += ANGLE_STEP;\n  }\n  #pragma unroll_loop_end\n}\n\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n  return (zReceiver - zBlocker) / zBlocker;\n}\n\nfloat findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\n  // This uses similar triangles to compute what\n  // area of the shadow map we should search\n  float searchRadius = LIGHT_SIZE_UV * ( zReceiver - NEAR_PLANE ) / zReceiver;\n  float blockerDepthSum = 0.0;\n  float shadowMapDepth = 0.0;\n  int numBlockers = 0;  \n  #pragma unroll_loop_start\n  for( int i = 0; i < ${samples}; i++ ) {\n    shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n    if ( shadowMapDepth < zReceiver ) {\n      blockerDepthSum += shadowMapDepth;\n      numBlockers ++;\n    }\n  }\n  #pragma unroll_loop_end\n\n  if( numBlockers == 0 ) return -1.0;\n  return blockerDepthSum / float( numBlockers );\n}\n\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {\n  float sum = 0.0;\n  float depth;\n  #pragma unroll_loop_start\n  for( int i = 0; i < ${samples}; i ++ ) {\n    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );\n    if( zReceiver <= depth ) sum += 1.0;\n  }\n  #pragma unroll_loop_end\n  #pragma unroll_loop_start\n  for( int i = 0; i < ${samples}; i ++ ) {\n    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );\n    if( zReceiver <= depth ) sum += 1.0;\n  }\n  #pragma unroll_loop_end\n  return sum / ( 2.0 * float( ${samples} ) );\n}\n\nfloat PCSS ( sampler2D shadowMap, vec4 coords ) {\n  vec2 uv = coords.xy;\n  float zReceiver = coords.z; // Assumed to be eye-space z in this code\n\n  initPoissonSamples( uv );\n  // STEP 1: blocker search\n  float avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver );\n\n  //There are no occluders so early out (this saves filtering)\n  if( avgBlockerDepth == -1.0 ) return 1.0;\n\n  // STEP 2: penumbra size\n  float penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );\n  float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\n  // STEP 3: filtering\n  //return avgBlockerDepth;\n  return PCF_Filter( shadowMap, uv, zReceiver, filterRadius );\n}`;\n\nlet deployed = false;\nconst softShadows = props => {\n  // Avoid adding the effect twice, which may happen in HMR scenarios\n  if (!deployed) {\n    console.warn('drei/softShadows() is deprecated, use <SoftShadows> instead');\n    deployed = true;\n    let shader = THREE.ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss({ ...props\n    }));\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    THREE.ShaderChunk.shadowmap_pars_fragment = shader;\n  }\n};\n\nfunction reset(gl, scene, camera) {\n  scene.traverse(object => {\n    if (object.material) {\n      gl.properties.remove(object.material);\n      object.material.dispose();\n    }\n  });\n  gl.info.programs.length = 0;\n  gl.compile(scene, camera);\n}\n\nfunction SoftShadows({\n  frustum = 3.75,\n  size = 0.005,\n  near = 9.5,\n  samples = 10,\n  rings = 11\n}) {\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  React.useEffect(() => {\n    const original = THREE.ShaderChunk.shadowmap_pars_fragment;\n    let shader = THREE.ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss({\n      frustum,\n      size,\n      near,\n      samples,\n      rings\n    }));\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    THREE.ShaderChunk.shadowmap_pars_fragment = shader;\n    reset(gl, scene, camera);\n    return () => {\n      THREE.ShaderChunk.shadowmap_pars_fragment = original;\n      reset(gl, scene, camera);\n    };\n  }, [frustum, size, near, samples, rings]);\n}\n\nexport { SoftShadows, softShadows };\n"]},"metadata":{},"sourceType":"module"}
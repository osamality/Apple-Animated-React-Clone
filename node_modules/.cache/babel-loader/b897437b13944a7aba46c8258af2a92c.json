{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\nimport { useHelper } from './useHelper.js';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { Edges } from './Edges.js';\nimport { FullScreenQuad } from 'three-stdlib';\n\nfunction createNormalMaterial(side = THREE.FrontSide) {\n  const viewMatrix = {\n    value: new THREE.Matrix4()\n  };\n  return Object.assign(new THREE.MeshNormalMaterial({\n    side\n  }), {\n    viewMatrix,\n    onBeforeCompile: shader => {\n      shader.uniforms.viewMatrix = viewMatrix;\n      shader.fragmentShader = `vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n         }\\n` + shader.fragmentShader.replace('#include <normal_fragment_maps>', `#include <normal_fragment_maps>\n           normal = inverseTransformDirection( normal, viewMatrix );\\n`);\n    }\n  });\n}\n\nconst CausticsProjectionMaterial = shaderMaterial({\n  causticsTexture: null,\n  causticsTextureB: null,\n  color: new THREE.Color(),\n  lightProjMatrix: new THREE.Matrix4(),\n  lightViewMatrix: new THREE.Matrix4()\n}, `varying vec3 vWorldPosition;   \n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\n     vWorldPosition = worldPosition.xyz;\n   }`, `varying vec3 vWorldPosition;\n  uniform vec3 color;\n  uniform sampler2D causticsTexture; \n  uniform sampler2D causticsTextureB; \n  uniform mat4 lightProjMatrix;\n  uniform mat4 lightViewMatrix;\n   void main() {\n    // Apply caustics  \n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\n    lightSpacePos.xyz /= lightSpacePos.w;\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\n    gl_FragColor = vec4((front + back) * color, 1.0);\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n   }`);\nconst CausticsMaterial = shaderMaterial({\n  cameraMatrixWorld: new THREE.Matrix4(),\n  cameraProjectionMatrixInv: new THREE.Matrix4(),\n  normalTexture: null,\n  depthTexture: null,\n  lightDir: new THREE.Vector3(0, 1, 0),\n  lightPlaneNormal: new THREE.Vector3(0, 1, 0),\n  lightPlaneConstant: 0,\n  near: 0.1,\n  far: 100,\n  modelMatrix: new THREE.Matrix4(),\n  worldRadius: 1 / 40,\n  ior: 1.1,\n  bounces: 0,\n  resolution: 1024,\n  size: 10,\n  intensity: 0.5\n},\n/* glsl */\n`\n  varying vec2 vUv;\n  void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }`,\n/* glsl */\n`  \n  uniform mat4 cameraMatrixWorld;\n  uniform mat4 cameraProjectionMatrixInv;\n  uniform vec3 lightDir;\n  uniform vec3 lightPlaneNormal;\n  uniform float lightPlaneConstant;\n  uniform float near;\n  uniform float far;\n  uniform float time;\n  uniform float worldRadius;\n  uniform float resolution;\n  uniform float size;\n  uniform float intensity;\n  uniform float ior;\n  precision highp isampler2D;\n  precision highp usampler2D;\n  uniform sampler2D normalTexture;\n  uniform sampler2D depthTexture;\n  uniform float bounces;\n  varying vec2 vUv;\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\n    // Perspective division\n    viewSpacePosition /= viewSpacePosition.w;\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\n    return worldSpacePosition.xyz;\n  }                  \n  float sdPlane( vec3 p, vec3 n, float h ) {\n    // n must be normalized\n    return dot(p,n) + h;\n  }\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n  }\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\n    rayOrigin = ro;\n    rayDirection = rd;\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\n    rayOrigin = pos + rayDirection * 0.1;\n    return rayDirection;\n  }\n  void main() {\n    // Each sample consists of random offset in the x and y direction\n    float caustic = 0.0;\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\n    float texelsNeeded = worldRadius / causticTexelSize;\n    float sampleRadius = texelsNeeded / resolution;\n    float sum = 0.0;\n    if (texture2D(depthTexture, vUv).x == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 uv1 = vUv + offset1 * sampleRadius;\n    vec2 uv2 = vUv + offset2 * sampleRadius;\n    vec2 uv3 = vUv + offset3 * sampleRadius;\n    vec2 uv4 = vUv + offset4 * sampleRadius;\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\n    // Sanity check the depths\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\n    vec3 endPos1, endPos2, endPos3, endPos4;\n    vec3 endDir1, endDir2, endDir3, endDir4;\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\n    caustic += intensity * (lightPosArea / finalArea);\n    // Calculate the area of the triangle in light spaces\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\n  }`);\nconst NORMALPROPS = {\n  depth: true,\n  minFilter: THREE.LinearFilter,\n  magFilter: THREE.LinearFilter,\n  encoding: THREE.LinearEncoding,\n  type: THREE.UnsignedByteType\n};\nconst CAUSTICPROPS = {\n  minFilter: THREE.LinearMipmapLinearFilter,\n  magFilter: THREE.LinearFilter,\n  encoding: THREE.LinearEncoding,\n  format: THREE.RGBAFormat,\n  type: THREE.FloatType,\n  generateMipmaps: true\n};\nconst Caustics = /*#__PURE__*/React.forwardRef(({\n  debug,\n  children,\n  frames = 1,\n  ior = 1.1,\n  color = 'white',\n  causticsOnly = false,\n  backfaces = false,\n  backfaceIor = 1.1,\n  worldRadius = 0.3125,\n  intensity = 0.05,\n  resolution = 2024,\n  lightSource = [5, 5, 5],\n  ...props\n}, fref) => {\n  extend({\n    CausticsProjectionMaterial\n  });\n  const ref = React.useRef(null);\n  const camera = React.useRef(null);\n  const scene = React.useRef(null);\n  const plane = React.useRef(null);\n  const gl = useThree(state => state.gl);\n  const helper = useHelper(debug && camera, THREE.CameraHelper); // Buffers for front and back faces\n\n  const normalTarget = useFBO(resolution, resolution, NORMALPROPS);\n  const normalTargetB = useFBO(resolution, resolution, NORMALPROPS);\n  const causticsTarget = useFBO(resolution, resolution, CAUSTICPROPS);\n  const causticsTargetB = useFBO(resolution, resolution, CAUSTICPROPS); // Normal materials for front and back faces\n\n  const [normalMat] = React.useState(() => createNormalMaterial());\n  const [normalMatB] = React.useState(() => createNormalMaterial(THREE.BackSide)); // The quad that catches the caustics\n\n  const [causticsMaterial] = React.useState(() => new CausticsMaterial());\n  const [causticsQuad] = React.useState(() => new FullScreenQuad(causticsMaterial));\n  React.useLayoutEffect(() => {\n    ref.current.updateWorldMatrix(false, true);\n  });\n  let count = 0;\n  const v = new THREE.Vector3();\n  const lpF = new THREE.Frustum();\n  const lpM = new THREE.Matrix4();\n  const lpP = new THREE.Plane();\n  const lightDir = new THREE.Vector3();\n  const lightDirInv = new THREE.Vector3();\n  const bounds = new THREE.Box3();\n  const focusPos = new THREE.Vector3();\n  useFrame((state, delta) => {\n    if (frames === Infinity || count++ < frames) {\n      var _scene$current$parent, _helper$current;\n\n      if (Array.isArray(lightSource)) lightDir.fromArray(lightSource).normalize();else lightDir.copy(ref.current.worldToLocal(lightSource.current.getWorldPosition(v)).normalize());\n      lightDirInv.copy(lightDir).multiplyScalar(-1);\n      let boundsVertices = [];\n      (_scene$current$parent = scene.current.parent) == null ? void 0 : _scene$current$parent.matrixWorld.identity();\n      bounds.setFromObject(scene.current, true);\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.max.z));\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.max.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.max.y, bounds.max.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.min.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.min.y, bounds.max.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.max.z));\n      const worldVerts = boundsVertices.map(v => v.clone());\n      bounds.getCenter(focusPos);\n      boundsVertices = boundsVertices.map(v => v.clone().sub(focusPos));\n      const lightPlane = lpP.set(lightDirInv, 0);\n      const projectedVerts = boundsVertices.map(v => lightPlane.projectPoint(v, new THREE.Vector3()));\n      const centralVert = projectedVerts.reduce((a, b) => a.add(b), v.set(0, 0, 0)).divideScalar(projectedVerts.length);\n      const radius = projectedVerts.map(v => v.distanceTo(centralVert)).reduce((a, b) => Math.max(a, b));\n      const dirLength = boundsVertices.map(x => x.dot(lightDir)).reduce((a, b) => Math.max(a, b)); // Shadows\n\n      camera.current.position.copy(lightDir.clone().multiplyScalar(dirLength).add(focusPos));\n      camera.current.lookAt(scene.current.localToWorld(focusPos.clone()));\n      const dirMatrix = lpM.lookAt(camera.current.position, focusPos, v.set(0, 1, 0));\n      camera.current.left = -radius;\n      camera.current.right = radius;\n      camera.current.top = radius;\n      camera.current.bottom = -radius;\n      const yOffset = v.set(0, radius, 0).applyMatrix4(dirMatrix);\n      const yTime = (camera.current.position.y + yOffset.y) / lightDir.y;\n      camera.current.near = 0.1;\n      camera.current.far = yTime;\n      camera.current.updateProjectionMatrix();\n      camera.current.updateMatrixWorld(); // Now find size of ground plane\n\n      const groundProjectedCoords = worldVerts.map(v => v.add(lightDir.clone().multiplyScalar(-v.y / lightDir.y)));\n      const centerPos = groundProjectedCoords.reduce((a, b) => a.add(b), v.set(0, 0, 0)).divideScalar(groundProjectedCoords.length);\n      const maxSize = 2 * groundProjectedCoords.map(v => Math.hypot(v.x - centerPos.x, v.z - centerPos.z)).reduce((a, b) => Math.max(a, b));\n      plane.current.scale.setScalar(maxSize);\n      plane.current.position.copy(centerPos);\n      if (debug) (_helper$current = helper.current) == null ? void 0 : _helper$current.update(); // Inject uniforms\n\n      normalMatB.viewMatrix.value = normalMat.viewMatrix.value = camera.current.matrixWorldInverse;\n      const dirLightNearPlane = lpF.setFromProjectionMatrix(lpM.multiplyMatrices(camera.current.projectionMatrix, camera.current.matrixWorldInverse)).planes[4];\n      causticsMaterial.cameraMatrixWorld = camera.current.matrixWorld;\n      causticsMaterial.cameraProjectionMatrixInv = camera.current.projectionMatrixInverse;\n      causticsMaterial.lightDir = lightDirInv;\n      causticsMaterial.lightPlaneNormal = dirLightNearPlane.normal;\n      causticsMaterial.lightPlaneConstant = dirLightNearPlane.constant; //console.log(causticsMaterial.lightDir)\n\n      causticsMaterial.near = camera.current.near;\n      causticsMaterial.far = camera.current.far;\n      causticsMaterial.resolution = resolution;\n      causticsMaterial.size = radius;\n      causticsMaterial.intensity = intensity;\n      causticsMaterial.worldRadius = worldRadius; // Switch the scene on\n\n      scene.current.visible = true; // Render front face normals\n\n      gl.setRenderTarget(normalTarget);\n      gl.clear();\n      scene.current.overrideMaterial = normalMat;\n      gl.render(scene.current, camera.current); // Render back face normals, if enabled\n\n      gl.setRenderTarget(normalTargetB);\n      gl.clear();\n\n      if (backfaces) {\n        scene.current.overrideMaterial = normalMatB;\n        gl.render(scene.current, camera.current);\n      } // Remove the override material\n\n\n      scene.current.overrideMaterial = null; // Render front face caustics\n\n      causticsMaterial.ior = ior;\n      plane.current.material.lightProjMatrix = camera.current.projectionMatrix;\n      plane.current.material.lightViewMatrix = camera.current.matrixWorldInverse;\n      causticsMaterial.normalTexture = normalTarget.texture;\n      causticsMaterial.depthTexture = normalTarget.depthTexture;\n      gl.setRenderTarget(causticsTarget);\n      gl.clear();\n      causticsQuad.render(gl); // Render back face caustics, if enabled\n\n      causticsMaterial.ior = backfaceIor;\n      causticsMaterial.normalTexture = normalTargetB.texture;\n      causticsMaterial.depthTexture = normalTargetB.depthTexture;\n      gl.setRenderTarget(causticsTargetB);\n      gl.clear();\n      if (backfaces) causticsQuad.render(gl); // Reset render target\n\n      gl.setRenderTarget(null); // Switch the scene off if caustics is all that's wanted\n\n      if (causticsOnly) scene.current.visible = false;\n    }\n  });\n  React.useImperativeHandle(fref, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props), /*#__PURE__*/React.createElement(\"scene\", {\n    ref: scene\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    ref: camera,\n    up: [0, 1, 0]\n  }), children), /*#__PURE__*/React.createElement(\"mesh\", {\n    renderOrder: 2,\n    ref: plane,\n    \"rotation-x\": -Math.PI / 2\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"causticsProjectionMaterial\", {\n    transparent: true,\n    color: color,\n    causticsTexture: causticsTarget.texture,\n    causticsTextureB: causticsTargetB.texture,\n    blending: THREE.CustomBlending,\n    blendSrc: THREE.OneFactor,\n    blendDst: THREE.SrcAlphaFactor,\n    depthWrite: false\n  }), debug && /*#__PURE__*/React.createElement(Edges, null, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: \"#ffff00\",\n    toneMapped: false\n  }))));\n});\nexport { Caustics };","map":{"version":3,"sources":["/Users/osamakhan/Desktop/dev/Apple-Animated-React-Clone/node_modules/@react-three/drei/core/Caustics.js"],"names":["_extends","THREE","React","extend","useThree","useFrame","useFBO","useHelper","shaderMaterial","Edges","FullScreenQuad","createNormalMaterial","side","FrontSide","viewMatrix","value","Matrix4","Object","assign","MeshNormalMaterial","onBeforeCompile","shader","uniforms","fragmentShader","replace","CausticsProjectionMaterial","causticsTexture","causticsTextureB","color","Color","lightProjMatrix","lightViewMatrix","CausticsMaterial","cameraMatrixWorld","cameraProjectionMatrixInv","normalTexture","depthTexture","lightDir","Vector3","lightPlaneNormal","lightPlaneConstant","near","far","modelMatrix","worldRadius","ior","bounces","resolution","size","intensity","NORMALPROPS","depth","minFilter","LinearFilter","magFilter","encoding","LinearEncoding","type","UnsignedByteType","CAUSTICPROPS","LinearMipmapLinearFilter","format","RGBAFormat","FloatType","generateMipmaps","Caustics","forwardRef","debug","children","frames","causticsOnly","backfaces","backfaceIor","lightSource","props","fref","ref","useRef","camera","scene","plane","gl","state","helper","CameraHelper","normalTarget","normalTargetB","causticsTarget","causticsTargetB","normalMat","useState","normalMatB","BackSide","causticsMaterial","causticsQuad","useLayoutEffect","current","updateWorldMatrix","count","v","lpF","Frustum","lpM","lpP","Plane","lightDirInv","bounds","Box3","focusPos","delta","Infinity","_scene$current$parent","_helper$current","Array","isArray","fromArray","normalize","copy","worldToLocal","getWorldPosition","multiplyScalar","boundsVertices","parent","matrixWorld","identity","setFromObject","push","min","x","y","z","max","worldVerts","map","clone","getCenter","sub","lightPlane","set","projectedVerts","projectPoint","centralVert","reduce","a","b","add","divideScalar","length","radius","distanceTo","Math","dirLength","dot","position","lookAt","localToWorld","dirMatrix","left","right","top","bottom","yOffset","applyMatrix4","yTime","updateProjectionMatrix","updateMatrixWorld","groundProjectedCoords","centerPos","maxSize","hypot","scale","setScalar","update","matrixWorldInverse","dirLightNearPlane","setFromProjectionMatrix","multiplyMatrices","projectionMatrix","planes","projectionMatrixInverse","normal","constant","visible","setRenderTarget","clear","overrideMaterial","render","material","texture","useImperativeHandle","createElement","up","renderOrder","PI","transparent","blending","CustomBlending","blendSrc","OneFactor","blendDst","SrcAlphaFactor","depthWrite","toneMapped"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,oCAArB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,MAAT,EAAiBC,QAAjB,EAA2BC,QAA3B,QAA2C,oBAA3C;AACA,SAASC,MAAT,QAAuB,aAAvB;AACA,SAASC,SAAT,QAA0B,gBAA1B;AACA,SAASC,cAAT,QAA+B,qBAA/B;AACA,SAASC,KAAT,QAAsB,YAAtB;AACA,SAASC,cAAT,QAA+B,cAA/B;;AAEA,SAASC,oBAAT,CAA8BC,IAAI,GAAGX,KAAK,CAACY,SAA3C,EAAsD;AACpD,QAAMC,UAAU,GAAG;AACjBC,IAAAA,KAAK,EAAE,IAAId,KAAK,CAACe,OAAV;AADU,GAAnB;AAGA,SAAOC,MAAM,CAACC,MAAP,CAAc,IAAIjB,KAAK,CAACkB,kBAAV,CAA6B;AAChDP,IAAAA;AADgD,GAA7B,CAAd,EAEH;AACFE,IAAAA,UADE;AAEFM,IAAAA,eAAe,EAAEC,MAAM,IAAI;AACzBA,MAAAA,MAAM,CAACC,QAAP,CAAgBR,UAAhB,GAA6BA,UAA7B;AACAO,MAAAA,MAAM,CAACE,cAAP,GAAyB;AAC/B;AACA,aAF8B,GAEdF,MAAM,CAACE,cAAP,CAAsBC,OAAtB,CAA8B,iCAA9B,EAAkE;AAClF,uEADgB,CAFV;AAID;AARC,GAFG,CAAP;AAYD;;AAED,MAAMC,0BAA0B,GAAGjB,cAAc,CAAC;AAChDkB,EAAAA,eAAe,EAAE,IAD+B;AAEhDC,EAAAA,gBAAgB,EAAE,IAF8B;AAGhDC,EAAAA,KAAK,EAAE,IAAI3B,KAAK,CAAC4B,KAAV,EAHyC;AAIhDC,EAAAA,eAAe,EAAE,IAAI7B,KAAK,CAACe,OAAV,EAJ+B;AAKhDe,EAAAA,eAAe,EAAE,IAAI9B,KAAK,CAACe,OAAV;AAL+B,CAAD,EAM7C;AACJ;AACA;AACA;AACA;AACA,KAXiD,EAWzC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KA3BiD,CAAjD;AA4BA,MAAMgB,gBAAgB,GAAGxB,cAAc,CAAC;AACtCyB,EAAAA,iBAAiB,EAAE,IAAIhC,KAAK,CAACe,OAAV,EADmB;AAEtCkB,EAAAA,yBAAyB,EAAE,IAAIjC,KAAK,CAACe,OAAV,EAFW;AAGtCmB,EAAAA,aAAa,EAAE,IAHuB;AAItCC,EAAAA,YAAY,EAAE,IAJwB;AAKtCC,EAAAA,QAAQ,EAAE,IAAIpC,KAAK,CAACqC,OAAV,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAL4B;AAMtCC,EAAAA,gBAAgB,EAAE,IAAItC,KAAK,CAACqC,OAAV,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CANoB;AAOtCE,EAAAA,kBAAkB,EAAE,CAPkB;AAQtCC,EAAAA,IAAI,EAAE,GARgC;AAStCC,EAAAA,GAAG,EAAE,GATiC;AAUtCC,EAAAA,WAAW,EAAE,IAAI1C,KAAK,CAACe,OAAV,EAVyB;AAWtC4B,EAAAA,WAAW,EAAE,IAAI,EAXqB;AAYtCC,EAAAA,GAAG,EAAE,GAZiC;AAatCC,EAAAA,OAAO,EAAE,CAb6B;AActCC,EAAAA,UAAU,EAAE,IAd0B;AAetCC,EAAAA,IAAI,EAAE,EAfgC;AAgBtCC,EAAAA,SAAS,EAAE;AAhB2B,CAAD;AAkBvC;AACC;AACD;AACA;AACA;AACA;AACA,IAxBuC;AAyBvC;AACC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\nimport { useHelper } from './useHelper.js';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { Edges } from './Edges.js';\nimport { FullScreenQuad } from 'three-stdlib';\n\nfunction createNormalMaterial(side = THREE.FrontSide) {\n  const viewMatrix = {\n    value: new THREE.Matrix4()\n  };\n  return Object.assign(new THREE.MeshNormalMaterial({\n    side\n  }), {\n    viewMatrix,\n    onBeforeCompile: shader => {\n      shader.uniforms.viewMatrix = viewMatrix;\n      shader.fragmentShader = `vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n         }\\n` + shader.fragmentShader.replace('#include <normal_fragment_maps>', `#include <normal_fragment_maps>\n           normal = inverseTransformDirection( normal, viewMatrix );\\n`);\n    }\n  });\n}\n\nconst CausticsProjectionMaterial = shaderMaterial({\n  causticsTexture: null,\n  causticsTextureB: null,\n  color: new THREE.Color(),\n  lightProjMatrix: new THREE.Matrix4(),\n  lightViewMatrix: new THREE.Matrix4()\n}, `varying vec3 vWorldPosition;   \n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\n     vWorldPosition = worldPosition.xyz;\n   }`, `varying vec3 vWorldPosition;\n  uniform vec3 color;\n  uniform sampler2D causticsTexture; \n  uniform sampler2D causticsTextureB; \n  uniform mat4 lightProjMatrix;\n  uniform mat4 lightViewMatrix;\n   void main() {\n    // Apply caustics  \n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\n    lightSpacePos.xyz /= lightSpacePos.w;\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\n    gl_FragColor = vec4((front + back) * color, 1.0);\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n   }`);\nconst CausticsMaterial = shaderMaterial({\n  cameraMatrixWorld: new THREE.Matrix4(),\n  cameraProjectionMatrixInv: new THREE.Matrix4(),\n  normalTexture: null,\n  depthTexture: null,\n  lightDir: new THREE.Vector3(0, 1, 0),\n  lightPlaneNormal: new THREE.Vector3(0, 1, 0),\n  lightPlaneConstant: 0,\n  near: 0.1,\n  far: 100,\n  modelMatrix: new THREE.Matrix4(),\n  worldRadius: 1 / 40,\n  ior: 1.1,\n  bounces: 0,\n  resolution: 1024,\n  size: 10,\n  intensity: 0.5\n},\n/* glsl */\n`\n  varying vec2 vUv;\n  void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }`,\n/* glsl */\n`  \n  uniform mat4 cameraMatrixWorld;\n  uniform mat4 cameraProjectionMatrixInv;\n  uniform vec3 lightDir;\n  uniform vec3 lightPlaneNormal;\n  uniform float lightPlaneConstant;\n  uniform float near;\n  uniform float far;\n  uniform float time;\n  uniform float worldRadius;\n  uniform float resolution;\n  uniform float size;\n  uniform float intensity;\n  uniform float ior;\n  precision highp isampler2D;\n  precision highp usampler2D;\n  uniform sampler2D normalTexture;\n  uniform sampler2D depthTexture;\n  uniform float bounces;\n  varying vec2 vUv;\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\n    // Perspective division\n    viewSpacePosition /= viewSpacePosition.w;\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\n    return worldSpacePosition.xyz;\n  }                  \n  float sdPlane( vec3 p, vec3 n, float h ) {\n    // n must be normalized\n    return dot(p,n) + h;\n  }\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n  }\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\n    rayOrigin = ro;\n    rayDirection = rd;\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\n    rayOrigin = pos + rayDirection * 0.1;\n    return rayDirection;\n  }\n  void main() {\n    // Each sample consists of random offset in the x and y direction\n    float caustic = 0.0;\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\n    float texelsNeeded = worldRadius / causticTexelSize;\n    float sampleRadius = texelsNeeded / resolution;\n    float sum = 0.0;\n    if (texture2D(depthTexture, vUv).x == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 uv1 = vUv + offset1 * sampleRadius;\n    vec2 uv2 = vUv + offset2 * sampleRadius;\n    vec2 uv3 = vUv + offset3 * sampleRadius;\n    vec2 uv4 = vUv + offset4 * sampleRadius;\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\n    // Sanity check the depths\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\n    vec3 endPos1, endPos2, endPos3, endPos4;\n    vec3 endDir1, endDir2, endDir3, endDir4;\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\n    caustic += intensity * (lightPosArea / finalArea);\n    // Calculate the area of the triangle in light spaces\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\n  }`);\nconst NORMALPROPS = {\n  depth: true,\n  minFilter: THREE.LinearFilter,\n  magFilter: THREE.LinearFilter,\n  encoding: THREE.LinearEncoding,\n  type: THREE.UnsignedByteType\n};\nconst CAUSTICPROPS = {\n  minFilter: THREE.LinearMipmapLinearFilter,\n  magFilter: THREE.LinearFilter,\n  encoding: THREE.LinearEncoding,\n  format: THREE.RGBAFormat,\n  type: THREE.FloatType,\n  generateMipmaps: true\n};\nconst Caustics = /*#__PURE__*/React.forwardRef(({\n  debug,\n  children,\n  frames = 1,\n  ior = 1.1,\n  color = 'white',\n  causticsOnly = false,\n  backfaces = false,\n  backfaceIor = 1.1,\n  worldRadius = 0.3125,\n  intensity = 0.05,\n  resolution = 2024,\n  lightSource = [5, 5, 5],\n  ...props\n}, fref) => {\n  extend({\n    CausticsProjectionMaterial\n  });\n  const ref = React.useRef(null);\n  const camera = React.useRef(null);\n  const scene = React.useRef(null);\n  const plane = React.useRef(null);\n  const gl = useThree(state => state.gl);\n  const helper = useHelper(debug && camera, THREE.CameraHelper); // Buffers for front and back faces\n\n  const normalTarget = useFBO(resolution, resolution, NORMALPROPS);\n  const normalTargetB = useFBO(resolution, resolution, NORMALPROPS);\n  const causticsTarget = useFBO(resolution, resolution, CAUSTICPROPS);\n  const causticsTargetB = useFBO(resolution, resolution, CAUSTICPROPS); // Normal materials for front and back faces\n\n  const [normalMat] = React.useState(() => createNormalMaterial());\n  const [normalMatB] = React.useState(() => createNormalMaterial(THREE.BackSide)); // The quad that catches the caustics\n\n  const [causticsMaterial] = React.useState(() => new CausticsMaterial());\n  const [causticsQuad] = React.useState(() => new FullScreenQuad(causticsMaterial));\n  React.useLayoutEffect(() => {\n    ref.current.updateWorldMatrix(false, true);\n  });\n  let count = 0;\n  const v = new THREE.Vector3();\n  const lpF = new THREE.Frustum();\n  const lpM = new THREE.Matrix4();\n  const lpP = new THREE.Plane();\n  const lightDir = new THREE.Vector3();\n  const lightDirInv = new THREE.Vector3();\n  const bounds = new THREE.Box3();\n  const focusPos = new THREE.Vector3();\n  useFrame((state, delta) => {\n    if (frames === Infinity || count++ < frames) {\n      var _scene$current$parent, _helper$current;\n\n      if (Array.isArray(lightSource)) lightDir.fromArray(lightSource).normalize();else lightDir.copy(ref.current.worldToLocal(lightSource.current.getWorldPosition(v)).normalize());\n      lightDirInv.copy(lightDir).multiplyScalar(-1);\n      let boundsVertices = [];\n      (_scene$current$parent = scene.current.parent) == null ? void 0 : _scene$current$parent.matrixWorld.identity();\n      bounds.setFromObject(scene.current, true);\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.max.z));\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.max.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.min.x, bounds.max.y, bounds.max.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.min.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.min.y, bounds.max.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.min.z));\n      boundsVertices.push(new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.max.z));\n      const worldVerts = boundsVertices.map(v => v.clone());\n      bounds.getCenter(focusPos);\n      boundsVertices = boundsVertices.map(v => v.clone().sub(focusPos));\n      const lightPlane = lpP.set(lightDirInv, 0);\n      const projectedVerts = boundsVertices.map(v => lightPlane.projectPoint(v, new THREE.Vector3()));\n      const centralVert = projectedVerts.reduce((a, b) => a.add(b), v.set(0, 0, 0)).divideScalar(projectedVerts.length);\n      const radius = projectedVerts.map(v => v.distanceTo(centralVert)).reduce((a, b) => Math.max(a, b));\n      const dirLength = boundsVertices.map(x => x.dot(lightDir)).reduce((a, b) => Math.max(a, b)); // Shadows\n\n      camera.current.position.copy(lightDir.clone().multiplyScalar(dirLength).add(focusPos));\n      camera.current.lookAt(scene.current.localToWorld(focusPos.clone()));\n      const dirMatrix = lpM.lookAt(camera.current.position, focusPos, v.set(0, 1, 0));\n      camera.current.left = -radius;\n      camera.current.right = radius;\n      camera.current.top = radius;\n      camera.current.bottom = -radius;\n      const yOffset = v.set(0, radius, 0).applyMatrix4(dirMatrix);\n      const yTime = (camera.current.position.y + yOffset.y) / lightDir.y;\n      camera.current.near = 0.1;\n      camera.current.far = yTime;\n      camera.current.updateProjectionMatrix();\n      camera.current.updateMatrixWorld(); // Now find size of ground plane\n\n      const groundProjectedCoords = worldVerts.map(v => v.add(lightDir.clone().multiplyScalar(-v.y / lightDir.y)));\n      const centerPos = groundProjectedCoords.reduce((a, b) => a.add(b), v.set(0, 0, 0)).divideScalar(groundProjectedCoords.length);\n      const maxSize = 2 * groundProjectedCoords.map(v => Math.hypot(v.x - centerPos.x, v.z - centerPos.z)).reduce((a, b) => Math.max(a, b));\n      plane.current.scale.setScalar(maxSize);\n      plane.current.position.copy(centerPos);\n      if (debug) (_helper$current = helper.current) == null ? void 0 : _helper$current.update(); // Inject uniforms\n\n      normalMatB.viewMatrix.value = normalMat.viewMatrix.value = camera.current.matrixWorldInverse;\n      const dirLightNearPlane = lpF.setFromProjectionMatrix(lpM.multiplyMatrices(camera.current.projectionMatrix, camera.current.matrixWorldInverse)).planes[4];\n      causticsMaterial.cameraMatrixWorld = camera.current.matrixWorld;\n      causticsMaterial.cameraProjectionMatrixInv = camera.current.projectionMatrixInverse;\n      causticsMaterial.lightDir = lightDirInv;\n      causticsMaterial.lightPlaneNormal = dirLightNearPlane.normal;\n      causticsMaterial.lightPlaneConstant = dirLightNearPlane.constant; //console.log(causticsMaterial.lightDir)\n\n      causticsMaterial.near = camera.current.near;\n      causticsMaterial.far = camera.current.far;\n      causticsMaterial.resolution = resolution;\n      causticsMaterial.size = radius;\n      causticsMaterial.intensity = intensity;\n      causticsMaterial.worldRadius = worldRadius; // Switch the scene on\n\n      scene.current.visible = true; // Render front face normals\n\n      gl.setRenderTarget(normalTarget);\n      gl.clear();\n      scene.current.overrideMaterial = normalMat;\n      gl.render(scene.current, camera.current); // Render back face normals, if enabled\n\n      gl.setRenderTarget(normalTargetB);\n      gl.clear();\n\n      if (backfaces) {\n        scene.current.overrideMaterial = normalMatB;\n        gl.render(scene.current, camera.current);\n      } // Remove the override material\n\n\n      scene.current.overrideMaterial = null; // Render front face caustics\n\n      causticsMaterial.ior = ior;\n      plane.current.material.lightProjMatrix = camera.current.projectionMatrix;\n      plane.current.material.lightViewMatrix = camera.current.matrixWorldInverse;\n      causticsMaterial.normalTexture = normalTarget.texture;\n      causticsMaterial.depthTexture = normalTarget.depthTexture;\n      gl.setRenderTarget(causticsTarget);\n      gl.clear();\n      causticsQuad.render(gl); // Render back face caustics, if enabled\n\n      causticsMaterial.ior = backfaceIor;\n      causticsMaterial.normalTexture = normalTargetB.texture;\n      causticsMaterial.depthTexture = normalTargetB.depthTexture;\n      gl.setRenderTarget(causticsTargetB);\n      gl.clear();\n      if (backfaces) causticsQuad.render(gl); // Reset render target\n\n      gl.setRenderTarget(null); // Switch the scene off if caustics is all that's wanted\n\n      if (causticsOnly) scene.current.visible = false;\n    }\n  });\n  React.useImperativeHandle(fref, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props), /*#__PURE__*/React.createElement(\"scene\", {\n    ref: scene\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    ref: camera,\n    up: [0, 1, 0]\n  }), children), /*#__PURE__*/React.createElement(\"mesh\", {\n    renderOrder: 2,\n    ref: plane,\n    \"rotation-x\": -Math.PI / 2\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"causticsProjectionMaterial\", {\n    transparent: true,\n    color: color,\n    causticsTexture: causticsTarget.texture,\n    causticsTextureB: causticsTargetB.texture,\n    blending: THREE.CustomBlending,\n    blendSrc: THREE.OneFactor,\n    blendDst: THREE.SrcAlphaFactor,\n    depthWrite: false\n  }), debug && /*#__PURE__*/React.createElement(Edges, null, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: \"#ffff00\",\n    toneMapped: false\n  }))));\n});\n\nexport { Caustics };\n"]},"metadata":{},"sourceType":"module"}
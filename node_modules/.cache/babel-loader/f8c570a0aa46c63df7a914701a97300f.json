{"ast":null,"code":"function SDFGenerator() {\n  var exports = function (exports) {\n    /**\n     * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n     */\n    function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t, pointOut) {\n      var t2 = 1 - t;\n      pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;\n      pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;\n    }\n    /**\n     * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n     */\n\n\n    function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {\n      var t2 = 1 - t;\n      pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;\n      pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;\n    }\n    /**\n     * Parse a path string into its constituent line/curve commands, invoking a callback for each.\n     * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n     * @param {function(\n     *   command: 'L'|'Q'|'C',\n     *   startX: number,\n     *   startY: number,\n     *   endX: number,\n     *   endY: number,\n     *   ctrl1X?: number,\n     *   ctrl1Y?: number,\n     *   ctrl2X?: number,\n     *   ctrl2Y?: number\n     * )} commandCallback - A callback function that will be called once for each parsed path command, passing the\n     *                      command identifier (only L/Q/C commands) and its numeric arguments.\n     */\n\n\n    function forEachPathCommand(pathString, commandCallback) {\n      var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n      var match, firstX, firstY, prevX, prevY;\n\n      while (match = segmentRE.exec(pathString)) {\n        var args = match[2].replace(/^\\s*|\\s*$/g, '').split(/[,\\s]+/).map(function (v) {\n          return parseFloat(v);\n        });\n\n        switch (match[1]) {\n          case 'M':\n            prevX = firstX = args[0];\n            prevY = firstY = args[1];\n            break;\n\n          case 'L':\n            if (args[0] !== prevX || args[1] !== prevY) {\n              // yup, some fonts have zero-length line commands\n              commandCallback('L', prevX, prevY, prevX = args[0], prevY = args[1]);\n            }\n\n            break;\n\n          case 'Q':\n            {\n              commandCallback('Q', prevX, prevY, prevX = args[2], prevY = args[3], args[0], args[1]);\n              break;\n            }\n\n          case 'C':\n            {\n              commandCallback('C', prevX, prevY, prevX = args[4], prevY = args[5], args[0], args[1], args[2], args[3]);\n              break;\n            }\n\n          case 'Z':\n            if (prevX !== firstX || prevY !== firstY) {\n              commandCallback('L', prevX, prevY, firstX, firstY);\n            }\n\n            break;\n        }\n      }\n    }\n    /**\n     * Convert a path string to a series of straight line segments\n     * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n     * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback\n     *        function that will be called once for every line segment\n     * @param {number} [curvePoints] - How many straight line segments to use when approximating a\n     *        bezier curve in the path. Defaults to 16.\n     */\n\n\n    function pathToLineSegments(pathString, segmentCallback, curvePoints) {\n      if (curvePoints === void 0) curvePoints = 16;\n      var tempPoint = {\n        x: 0,\n        y: 0\n      };\n      forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {\n        switch (command) {\n          case 'L':\n            segmentCallback(startX, startY, endX, endY);\n            break;\n\n          case 'Q':\n            {\n              var prevCurveX = startX;\n              var prevCurveY = startY;\n\n              for (var i = 1; i < curvePoints; i++) {\n                pointOnQuadraticBezier(startX, startY, ctrl1X, ctrl1Y, endX, endY, i / (curvePoints - 1), tempPoint);\n                segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);\n                prevCurveX = tempPoint.x;\n                prevCurveY = tempPoint.y;\n              }\n\n              break;\n            }\n\n          case 'C':\n            {\n              var prevCurveX$1 = startX;\n              var prevCurveY$1 = startY;\n\n              for (var i$1 = 1; i$1 < curvePoints; i$1++) {\n                pointOnCubicBezier(startX, startY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, endX, endY, i$1 / (curvePoints - 1), tempPoint);\n                segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);\n                prevCurveX$1 = tempPoint.x;\n                prevCurveY$1 = tempPoint.y;\n              }\n\n              break;\n            }\n        }\n      });\n    }\n\n    var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n    var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";\n    var cache = new WeakMap();\n    var glContextParams = {\n      premultipliedAlpha: false,\n      preserveDrawingBuffer: true,\n      antialias: false,\n      depth: false\n    };\n    /**\n     * This is a little helper library for WebGL. It assists with state management for a GL context.\n     * It's pretty tightly wrapped to the needs of this package, not very general-purpose.\n     *\n     * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap\n     * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback\n     */\n\n    function withWebGLContext(glOrCanvas, callback) {\n      var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;\n      var wrapper = cache.get(gl);\n\n      if (!wrapper) {\n        var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n        var extensions = {};\n        var programs = {};\n        var textures = {};\n        var textureUnit = -1;\n        var framebufferStack = [];\n        gl.canvas.addEventListener('webglcontextlost', function (e) {\n          handleContextLoss();\n          e.preventDefault();\n        }, false);\n\n        function getExtension(name) {\n          var ext = extensions[name];\n\n          if (!ext) {\n            ext = extensions[name] = gl.getExtension(name);\n\n            if (!ext) {\n              throw new Error(name + \" not supported\");\n            }\n          }\n\n          return ext;\n        }\n\n        function compileShader(src, type) {\n          var shader = gl.createShader(type);\n          gl.shaderSource(shader, src);\n          gl.compileShader(shader); // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n          // if (!status && !gl.isContextLost()) {\n          //   throw new Error(gl.getShaderInfoLog(shader).trim())\n          // }\n\n          return shader;\n        }\n\n        function withProgram(name, vert, frag, func) {\n          if (!programs[name]) {\n            var attributes = {};\n            var uniforms = {};\n            var program = gl.createProgram();\n            gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));\n            gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));\n            gl.linkProgram(program);\n            programs[name] = {\n              program: program,\n              transaction: function transaction(func) {\n                gl.useProgram(program);\n                func({\n                  setUniform: function setUniform(type, name) {\n                    var values = [],\n                        len = arguments.length - 2;\n\n                    while (len-- > 0) values[len] = arguments[len + 2];\n\n                    var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));\n                    gl[\"uniform\" + type].apply(gl, [uniformLoc].concat(values));\n                  },\n                  setAttribute: function setAttribute(name, size, usage, instancingDivisor, data) {\n                    var attr = attributes[name];\n\n                    if (!attr) {\n                      attr = attributes[name] = {\n                        buf: gl.createBuffer(),\n                        // TODO should we destroy our buffers?\n                        loc: gl.getAttribLocation(program, name),\n                        data: null\n                      };\n                    }\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);\n                    gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);\n                    gl.enableVertexAttribArray(attr.loc);\n\n                    if (isWebGL2) {\n                      gl.vertexAttribDivisor(attr.loc, instancingDivisor);\n                    } else {\n                      getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);\n                    }\n\n                    if (data !== attr.data) {\n                      gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n                      attr.data = data;\n                    }\n                  }\n                });\n              }\n            };\n          }\n\n          programs[name].transaction(func);\n        }\n\n        function withTexture(name, func) {\n          textureUnit++;\n\n          try {\n            gl.activeTexture(gl.TEXTURE0 + textureUnit);\n            var texture = textures[name];\n\n            if (!texture) {\n              texture = textures[name] = gl.createTexture();\n              gl.bindTexture(gl.TEXTURE_2D, texture);\n              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            }\n\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            func(texture, textureUnit);\n          } finally {\n            textureUnit--;\n          }\n        }\n\n        function withTextureFramebuffer(texture, textureUnit, func) {\n          var framebuffer = gl.createFramebuffer();\n          framebufferStack.push(framebuffer);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n          gl.activeTexture(gl.TEXTURE0 + textureUnit);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n          try {\n            func(framebuffer);\n          } finally {\n            gl.deleteFramebuffer(framebuffer);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);\n          }\n        }\n\n        function handleContextLoss() {\n          extensions = {};\n          programs = {};\n          textures = {};\n          textureUnit = -1;\n          framebufferStack.length = 0;\n        }\n\n        cache.set(gl, wrapper = {\n          gl: gl,\n          isWebGL2: isWebGL2,\n          getExtension: getExtension,\n          withProgram: withProgram,\n          withTexture: withTexture,\n          withTextureFramebuffer: withTextureFramebuffer,\n          handleContextLoss: handleContextLoss\n        });\n      }\n\n      callback(wrapper);\n    }\n\n    function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {\n      if (channels === void 0) channels = 15;\n      if (framebuffer === void 0) framebuffer = null;\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var withProgram = ref.withProgram;\n        var withTexture = ref.withTexture;\n        withTexture('copy', function (tex, texUnit) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n          withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {\n            var setUniform = ref.setUniform;\n            var setAttribute = ref.setAttribute;\n            setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));\n            setUniform('1i', 'image', texUnit);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);\n            gl.disable(gl.BLEND);\n            gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);\n            gl.viewport(x, y, width, height);\n            gl.scissor(x, y, width, height);\n            gl.drawArrays(gl.TRIANGLES, 0, 3);\n          });\n        });\n      });\n    }\n    /**\n     * Resizing a canvas clears its contents; this utility copies the previous contents over.\n     * @param canvas\n     * @param newWidth\n     * @param newHeight\n     */\n\n\n    function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {\n      var width = canvas.width;\n      var height = canvas.height;\n      withWebGLContext(canvas, function (ref) {\n        var gl = ref.gl;\n        var data = new Uint8Array(width * height * 4);\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        canvas.width = newWidth;\n        canvas.height = newHeight;\n        renderImageData(gl, data, 0, 0, width, height);\n      });\n    }\n\n    var webglUtils = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      withWebGLContext: withWebGLContext,\n      renderImageData: renderImageData,\n      resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing\n    });\n\n    function generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      var textureData = new Uint8Array(sdfWidth * sdfHeight);\n      var viewBoxWidth = viewBox[2] - viewBox[0];\n      var viewBoxHeight = viewBox[3] - viewBox[1]; // Decompose all paths into straight line segments and add them to an index\n\n      var segments = [];\n      pathToLineSegments(path, function (x1, y1, x2, y2) {\n        segments.push({\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2,\n          minX: Math.min(x1, x2),\n          minY: Math.min(y1, y2),\n          maxX: Math.max(x1, x2),\n          maxY: Math.max(y1, y2)\n        });\n      }); // Sort segments by maxX, this will let us short-circuit some loops below\n\n      segments.sort(function (a, b) {\n        return a.maxX - b.maxX;\n      }); // For each target SDF texel, find the distance from its center to its nearest line segment,\n      // map that distance to an alpha value, and write that alpha to the texel\n\n      for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {\n        for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {\n          var signedDist = findNearestSignedDistance(viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth, viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight); // Use an exponential scale to ensure the texels very near the glyph path have adequate\n          // precision, while allowing the distance field to cover the entire texture, given that\n          // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam\n\n          var alpha = Math.pow(1 - Math.abs(signedDist) / maxDistance, sdfExponent) / 2;\n\n          if (signedDist < 0) {\n            alpha = 1 - alpha;\n          }\n\n          alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp\n\n          textureData[sdfY * sdfWidth + sdfX] = alpha;\n        }\n      }\n\n      return textureData;\n      /**\n       * For a given x/y, search the index for the closest line segment and return\n       * its signed distance. Negative = inside, positive = outside, zero = on edge\n       * @param x\n       * @param y\n       * @returns {number}\n       */\n\n      function findNearestSignedDistance(x, y) {\n        var closestDistSq = Infinity;\n        var closestDist = Infinity;\n\n        for (var i = segments.length; i--;) {\n          var seg = segments[i];\n\n          if (seg.maxX + closestDist <= x) {\n            break;\n          } //sorting by maxX means no more can be closer, so we can short-circuit\n\n\n          if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {\n            var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);\n\n            if (distSq < closestDistSq) {\n              closestDistSq = distSq;\n              closestDist = Math.sqrt(closestDistSq);\n            }\n          }\n        } // Flip to negative distance if inside the poly\n\n\n        if (isPointInPoly(x, y)) {\n          closestDist = -closestDist;\n        }\n\n        return closestDist;\n      }\n      /**\n       * Determine whether the given point lies inside or outside the glyph. Uses a simple\n       * winding-number ray casting algorithm using a ray pointing east from the point.\n       */\n\n\n      function isPointInPoly(x, y) {\n        var winding = 0;\n\n        for (var i = segments.length; i--;) {\n          var seg = segments[i];\n\n          if (seg.maxX <= x) {\n            break;\n          } //sorting by maxX means no more can cross, so we can short-circuit\n\n\n          var intersects = seg.y1 > y !== seg.y2 > y && x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1;\n\n          if (intersects) {\n            winding += seg.y1 < seg.y2 ? 1 : -1;\n          }\n        }\n\n        return winding !== 0;\n      }\n    }\n\n    function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0;\n      generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n    }\n\n    function generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0;\n      var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent); // Expand single-channel data to rbga\n\n      var rgbaData = new Uint8Array(data.length * 4);\n\n      for (var i = 0; i < data.length; i++) {\n        rgbaData[i * 4 + channel] = data[i];\n      }\n\n      renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << 3 - channel, framebuffer);\n    }\n    /**\n     * Find the absolute distance from a point to a line segment at closest approach\n     */\n\n\n    function absSquareDistanceToLineSegment(x, y, lineX0, lineY0, lineX1, lineY1) {\n      var ldx = lineX1 - lineX0;\n      var ldy = lineY1 - lineY0;\n      var lengthSq = ldx * ldx + ldy * ldy;\n      var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n      var dx = x - (lineX0 + t * ldx);\n      var dy = y - (lineY0 + t * ldy);\n      return dx * dx + dy * dy;\n    }\n\n    var javascript = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      generate: generate$2,\n      generateIntoCanvas: generateIntoCanvas$2,\n      generateIntoFramebuffer: generateIntoFramebuffer$1\n    });\n    var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n    var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";\n    var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\"; // Single triangle covering viewport\n\n    var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);\n    var implicitContext = null;\n    var isTestingSupport = false;\n    var NULL_OBJECT = {};\n    var supportByCanvas = new WeakMap(); // canvas -> bool\n\n    function validateSupport(glOrCanvas) {\n      if (!isTestingSupport && !isSupported(glOrCanvas)) {\n        throw new Error('WebGL generation not supported');\n      }\n    }\n\n    function generate$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (glOrCanvas === void 0) glOrCanvas = null;\n\n      if (!glOrCanvas) {\n        glOrCanvas = implicitContext;\n\n        if (!glOrCanvas) {\n          var canvas = typeof OffscreenCanvas === 'function' ? new OffscreenCanvas(1, 1) : typeof document !== 'undefined' ? document.createElement('canvas') : null;\n\n          if (!canvas) {\n            throw new Error('OffscreenCanvas or DOM canvas not supported');\n          }\n\n          glOrCanvas = implicitContext = canvas.getContext('webgl', {\n            depth: false\n          });\n        }\n      }\n\n      validateSupport(glOrCanvas);\n      var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari\n      // Render into a background texture framebuffer\n\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var withTexture = ref.withTexture;\n        var withTextureFramebuffer = ref.withTextureFramebuffer;\n        withTexture('readable', function (texture, textureUnit) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n          withTextureFramebuffer(texture, textureUnit, function (framebuffer) {\n            generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, gl, framebuffer, 0, 0, 0 // red channel\n            );\n            gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n          });\n        });\n      }); // Throw away all but the red channel\n\n      var data = new Uint8Array(sdfWidth * sdfHeight);\n\n      for (var i = 0, j = 0; i < rgbaData.length; i += 4) {\n        data[j++] = rgbaData[i];\n      }\n\n      return data;\n    }\n\n    function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0;\n      generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n    }\n\n    function generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0; // Verify support\n\n      validateSupport(glOrCanvas); // Compute path segments\n\n      var lineSegmentCoords = [];\n      pathToLineSegments(path, function (x1, y1, x2, y2) {\n        lineSegmentCoords.push(x1, y1, x2, y2);\n      });\n      lineSegmentCoords = new Float32Array(lineSegmentCoords);\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var isWebGL2 = ref.isWebGL2;\n        var getExtension = ref.getExtension;\n        var withProgram = ref.withProgram;\n        var withTexture = ref.withTexture;\n        var withTextureFramebuffer = ref.withTextureFramebuffer;\n        var handleContextLoss = ref.handleContextLoss;\n        withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {\n          if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, intermediateTexture._lastWidth = sdfWidth, intermediateTexture._lastHeight = sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n          } // Unsigned distance pass\n\n\n          withProgram('main', mainVertex, mainFragment, function (ref) {\n            var setAttribute = ref.setAttribute;\n            var setUniform = ref.setUniform; // Init extensions\n\n            var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');\n            var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax'); // Init/update attributes\n\n            setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n            setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords); // Init/update uniforms\n\n            setUniform.apply(void 0, ['4f', 'uGlyphBounds'].concat(viewBox));\n            setUniform('1f', 'uMaxDistance', maxDistance);\n            setUniform('1f', 'uExponent', sdfExponent); // Render initial unsigned distance / winding number info to a texture\n\n            withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {\n              gl.enable(gl.BLEND);\n              gl.colorMask(true, true, true, true);\n              gl.viewport(0, 0, sdfWidth, sdfHeight);\n              gl.scissor(0, 0, sdfWidth, sdfHeight);\n              gl.blendFunc(gl.ONE, gl.ONE); // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".\n              // Alpha holds the closest (MAX) unsigned distance.\n\n              gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);\n              gl.clear(gl.COLOR_BUFFER_BIT);\n\n              if (isWebGL2) {\n                gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n              } else {\n                instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n              } // Debug\n              // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)\n              // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)\n              // console.log('intermediate texture data: ', debug)\n\n            });\n          }); // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.\n\n          withProgram('post', viewportQuadVertex, postFragment, function (program) {\n            program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n            program.setUniform('1i', 'tex', intermediateTextureUnit);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n            gl.disable(gl.BLEND);\n            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n            gl.viewport(x, y, sdfWidth, sdfHeight);\n            gl.scissor(x, y, sdfWidth, sdfHeight);\n            gl.drawArrays(gl.TRIANGLES, 0, 3);\n          });\n        }); // Handle context loss occurring during any of the above calls\n\n        if (gl.isContextLost()) {\n          handleContextLoss();\n          throw new Error('webgl context lost');\n        }\n      });\n    }\n\n    function isSupported(glOrCanvas) {\n      var key = !glOrCanvas || glOrCanvas === implicitContext ? NULL_OBJECT : glOrCanvas.canvas || glOrCanvas;\n      var supported = supportByCanvas.get(key);\n\n      if (supported === undefined) {\n        isTestingSupport = true;\n        var failReason = null;\n\n        try {\n          // Since we can't detect all failure modes up front, let's just do a trial run of a\n          // simple path and compare what we get back to the correct expected result. This will\n          // also serve to prime the shader compilation.\n          var expectedResult = [97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106, 97];\n          var testResult = generate$1(4, 4, 'M8,8L16,8L24,24L16,24Z', [0, 0, 32, 32], 24, 1, glOrCanvas);\n          supported = testResult && expectedResult.length === testResult.length && testResult.every(function (val, i) {\n            return val === expectedResult[i];\n          });\n\n          if (!supported) {\n            failReason = 'bad trial run results';\n            console.info(expectedResult, testResult);\n          }\n        } catch (err) {\n          // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?\n          supported = false;\n          failReason = err.message;\n        }\n\n        if (failReason) {\n          console.warn('WebGL SDF generation not supported:', failReason);\n        }\n\n        isTestingSupport = false;\n        supportByCanvas.set(key, supported);\n      }\n\n      return supported;\n    }\n\n    var webgl = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      generate: generate$1,\n      generateIntoCanvas: generateIntoCanvas$1,\n      generateIntoFramebuffer: generateIntoFramebuffer,\n      isSupported: isSupported\n    });\n    /**\n     * Generate an SDF texture image for a 2D path.\n     *\n     * @param {number} sdfWidth - width of the SDF output image in pixels.\n     * @param {number} sdfHeight - height of the SDF output image in pixels.\n     * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n     * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n     * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n     *        to half the maximum viewBox dimension.\n     * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n     *        will give greater precision nearer the glyph's path.\n     * @return {Uint8Array}\n     */\n\n    function generate(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n      if (maxDistance === void 0) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n      if (sdfExponent === void 0) sdfExponent = 1;\n\n      try {\n        return generate$1.apply(webgl, arguments);\n      } catch (e) {\n        console.info('WebGL SDF generation failed, falling back to JS', e);\n        return generate$2.apply(javascript, arguments);\n      }\n    }\n    /**\n     * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position\n     * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels\n     * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.\n     *\n     * @param {number} sdfWidth - width of the SDF output image in pixels.\n     * @param {number} sdfHeight - height of the SDF output image in pixels.\n     * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n     * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n     * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n     *        to half the maximum viewBox dimension.\n     * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n     *        will give greater precision nearer the glyph's path.\n     * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.\n     *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results\n     *        due to shared GL context state, this canvas should be dedicated to use by this library alone.\n     * @param {number} x - the x position at which to render the SDF.\n     * @param {number} y - the y position at which to render the SDF.\n     * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.\n     * @return {Uint8Array}\n     */\n\n\n    function generateIntoCanvas(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n      if (maxDistance === void 0) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0;\n\n      try {\n        return generateIntoCanvas$1.apply(webgl, arguments);\n      } catch (e) {\n        console.info('WebGL SDF generation failed, falling back to JS', e);\n        return generateIntoCanvas$2.apply(javascript, arguments);\n      }\n    }\n\n    exports.forEachPathCommand = forEachPathCommand;\n    exports.generate = generate;\n    exports.generateIntoCanvas = generateIntoCanvas;\n    exports.javascript = javascript;\n    exports.pathToLineSegments = pathToLineSegments;\n    exports.webgl = webgl;\n    exports.webglUtils = webglUtils;\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    return exports;\n  }({});\n\n  return exports;\n}\n\nexport { SDFGenerator as default };","map":{"version":3,"sources":["/Users/osamakhan/Desktop/dev/Apple-Animated-React-Clone/node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs"],"names":["SDFGenerator","exports","pointOnQuadraticBezier","x0","y0","x1","y1","x2","y2","t","pointOut","t2","x","y","pointOnCubicBezier","x3","y3","forEachPathCommand","pathString","commandCallback","segmentRE","match","firstX","firstY","prevX","prevY","exec","args","replace","split","map","v","parseFloat","pathToLineSegments","segmentCallback","curvePoints","tempPoint","command","startX","startY","endX","endY","ctrl1X","ctrl1Y","ctrl2X","ctrl2Y","prevCurveX","prevCurveY","i","prevCurveX$1","prevCurveY$1","i$1","viewportQuadVertex","copyTexFragment","cache","WeakMap","glContextParams","premultipliedAlpha","preserveDrawingBuffer","antialias","depth","withWebGLContext","glOrCanvas","callback","gl","getContext","wrapper","get","isWebGL2","WebGL2RenderingContext","extensions","programs","textures","textureUnit","framebufferStack","canvas","addEventListener","e","handleContextLoss","preventDefault","getExtension","name","ext","Error","compileShader","src","type","shader","createShader","shaderSource","withProgram","vert","frag","func","attributes","uniforms","program","createProgram","attachShader","VERTEX_SHADER","FRAGMENT_SHADER","linkProgram","transaction","useProgram","setUniform","values","len","arguments","length","uniformLoc","getUniformLocation","apply","concat","setAttribute","size","usage","instancingDivisor","data","attr","buf","createBuffer","loc","getAttribLocation","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","FLOAT","enableVertexAttribArray","vertexAttribDivisor","vertexAttribDivisorANGLE","bufferData","withTexture","activeTexture","TEXTURE0","texture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","withTextureFramebuffer","framebuffer","createFramebuffer","push","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","deleteFramebuffer","set","renderImageData","imageData","width","height","channels","ref","tex","texUnit","texImage2D","RGBA","UNSIGNED_BYTE","STATIC_DRAW","Float32Array","disable","BLEND","colorMask","viewport","scissor","drawArrays","TRIANGLES","resizeWebGLCanvasWithoutClearing","newWidth","newHeight","Uint8Array","readPixels","webglUtils","Object","freeze","__proto__","generate$2","sdfWidth","sdfHeight","path","viewBox","maxDistance","sdfExponent","textureData","viewBoxWidth","viewBoxHeight","segments","minX","Math","min","minY","maxX","max","maxY","sort","a","b","sdfX","sdfY","signedDist","findNearestSignedDistance","alpha","pow","abs","round","closestDistSq","Infinity","closestDist","seg","distSq","absSquareDistanceToLineSegment","sqrt","isPointInPoly","winding","intersects","generateIntoCanvas$2","channel","generateIntoFramebuffer$1","rgbaData","lineX0","lineY0","lineX1","lineY1","ldx","ldy","lengthSq","dx","dy","javascript","generate","generateIntoCanvas","generateIntoFramebuffer","mainVertex","mainFragment","postFragment","viewportUVs","implicitContext","isTestingSupport","NULL_OBJECT","supportByCanvas","validateSupport","isSupported","generate$1","OffscreenCanvas","document","createElement","j","generateIntoCanvas$1","lineSegmentCoords","intermediateTexture","intermediateTextureUnit","_lastWidth","_lastHeight","instancingExtension","blendMinMaxExtension","DYNAMIC_DRAW","enable","blendFunc","ONE","blendEquationSeparate","FUNC_ADD","MAX","MAX_EXT","clear","COLOR_BUFFER_BIT","drawArraysInstanced","drawArraysInstancedANGLE","isContextLost","key","supported","undefined","failReason","expectedResult","testResult","every","val","console","info","err","message","warn","webgl","defineProperty","value","default"],"mappings":"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","sourcesContent":["function SDFGenerator() {\nvar exports = (function (exports) {\n\n  /**\n   * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnQuadraticBezier (x0, y0, x1, y1, x2, y2, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;\n    pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;\n  }\n\n  /**\n   * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnCubicBezier (x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;\n    pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;\n  }\n\n  /**\n   * Parse a path string into its constituent line/curve commands, invoking a callback for each.\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(\n   *   command: 'L'|'Q'|'C',\n   *   startX: number,\n   *   startY: number,\n   *   endX: number,\n   *   endY: number,\n   *   ctrl1X?: number,\n   *   ctrl1Y?: number,\n   *   ctrl2X?: number,\n   *   ctrl2Y?: number\n   * )} commandCallback - A callback function that will be called once for each parsed path command, passing the\n   *                      command identifier (only L/Q/C commands) and its numeric arguments.\n   */\n  function forEachPathCommand(pathString, commandCallback) {\n    var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n    var match, firstX, firstY, prevX, prevY;\n    while ((match = segmentRE.exec(pathString))) {\n      var args = match[2]\n        .replace(/^\\s*|\\s*$/g, '')\n        .split(/[,\\s]+/)\n        .map(function (v) { return parseFloat(v); });\n      switch (match[1]) {\n        case 'M':\n          prevX = firstX = args[0];\n          prevY = firstY = args[1];\n          break\n        case 'L':\n          if (args[0] !== prevX || args[1] !== prevY) { // yup, some fonts have zero-length line commands\n            commandCallback('L', prevX, prevY, (prevX = args[0]), (prevY = args[1]));\n          }\n          break\n        case 'Q': {\n          commandCallback('Q', prevX, prevY, (prevX = args[2]), (prevY = args[3]), args[0], args[1]);\n          break\n        }\n        case 'C': {\n          commandCallback('C', prevX, prevY, (prevX = args[4]), (prevY = args[5]), args[0], args[1], args[2], args[3]);\n          break\n        }\n        case 'Z':\n          if (prevX !== firstX || prevY !== firstY) {\n            commandCallback('L', prevX, prevY, firstX, firstY);\n          }\n          break\n      }\n    }\n  }\n\n  /**\n   * Convert a path string to a series of straight line segments\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback\n   *        function that will be called once for every line segment\n   * @param {number} [curvePoints] - How many straight line segments to use when approximating a\n   *        bezier curve in the path. Defaults to 16.\n   */\n  function pathToLineSegments (pathString, segmentCallback, curvePoints) {\n    if ( curvePoints === void 0 ) curvePoints = 16;\n\n    var tempPoint = { x: 0, y: 0 };\n    forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {\n      switch (command) {\n        case 'L':\n          segmentCallback(startX, startY, endX, endY);\n          break\n        case 'Q': {\n          var prevCurveX = startX;\n          var prevCurveY = startY;\n          for (var i = 1; i < curvePoints; i++) {\n            pointOnQuadraticBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              endX, endY,\n              i / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);\n            prevCurveX = tempPoint.x;\n            prevCurveY = tempPoint.y;\n          }\n          break\n        }\n        case 'C': {\n          var prevCurveX$1 = startX;\n          var prevCurveY$1 = startY;\n          for (var i$1 = 1; i$1 < curvePoints; i$1++) {\n            pointOnCubicBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              ctrl2X, ctrl2Y,\n              endX, endY,\n              i$1 / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);\n            prevCurveX$1 = tempPoint.x;\n            prevCurveY$1 = tempPoint.y;\n          }\n          break\n        }\n      }\n    });\n  }\n\n  var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";\n\n  var cache = new WeakMap();\n\n  var glContextParams = {\n    premultipliedAlpha: false,\n    preserveDrawingBuffer: true,\n    antialias: false,\n    depth: false,\n  };\n\n  /**\n   * This is a little helper library for WebGL. It assists with state management for a GL context.\n   * It's pretty tightly wrapped to the needs of this package, not very general-purpose.\n   *\n   * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap\n   * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback\n   */\n  function withWebGLContext (glOrCanvas, callback) {\n    var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;\n    var wrapper = cache.get(gl);\n    if (!wrapper) {\n      var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n      var extensions = {};\n      var programs = {};\n      var textures = {};\n      var textureUnit = -1;\n      var framebufferStack = [];\n\n      gl.canvas.addEventListener('webglcontextlost', function (e) {\n        handleContextLoss();\n        e.preventDefault();\n      }, false);\n\n      function getExtension (name) {\n        var ext = extensions[name];\n        if (!ext) {\n          ext = extensions[name] = gl.getExtension(name);\n          if (!ext) {\n            throw new Error((name + \" not supported\"))\n          }\n        }\n        return ext\n      }\n\n      function compileShader (src, type) {\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n        // if (!status && !gl.isContextLost()) {\n        //   throw new Error(gl.getShaderInfoLog(shader).trim())\n        // }\n        return shader\n      }\n\n      function withProgram (name, vert, frag, func) {\n        if (!programs[name]) {\n          var attributes = {};\n          var uniforms = {};\n          var program = gl.createProgram();\n          gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));\n          gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));\n          gl.linkProgram(program);\n\n          programs[name] = {\n            program: program,\n            transaction: function transaction (func) {\n              gl.useProgram(program);\n              func({\n                setUniform: function setUniform (type, name) {\n                  var values = [], len = arguments.length - 2;\n                  while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];\n\n                  var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));\n                  gl[(\"uniform\" + type)].apply(gl, [ uniformLoc ].concat( values ));\n                },\n\n                setAttribute: function setAttribute (name, size, usage, instancingDivisor, data) {\n                  var attr = attributes[name];\n                  if (!attr) {\n                    attr = attributes[name] = {\n                      buf: gl.createBuffer(), // TODO should we destroy our buffers?\n                      loc: gl.getAttribLocation(program, name),\n                      data: null\n                    };\n                  }\n                  gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);\n                  gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);\n                  gl.enableVertexAttribArray(attr.loc);\n                  if (isWebGL2) {\n                    gl.vertexAttribDivisor(attr.loc, instancingDivisor);\n                  } else {\n                    getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);\n                  }\n                  if (data !== attr.data) {\n                    gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n                    attr.data = data;\n                  }\n                }\n              });\n            }\n          };\n        }\n\n        programs[name].transaction(func);\n      }\n\n      function withTexture (name, func) {\n        textureUnit++;\n        try {\n          gl.activeTexture(gl.TEXTURE0 + textureUnit);\n          var texture = textures[name];\n          if (!texture) {\n            texture = textures[name] = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n          }\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          func(texture, textureUnit);\n        } finally {\n          textureUnit--;\n        }\n      }\n\n      function withTextureFramebuffer (texture, textureUnit, func) {\n        var framebuffer = gl.createFramebuffer();\n        framebufferStack.push(framebuffer);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.activeTexture(gl.TEXTURE0 + textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        try {\n          func(framebuffer);\n        } finally {\n          gl.deleteFramebuffer(framebuffer);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);\n        }\n      }\n\n      function handleContextLoss () {\n        extensions = {};\n        programs = {};\n        textures = {};\n        textureUnit = -1;\n        framebufferStack.length = 0;\n      }\n\n      cache.set(gl, wrapper = {\n        gl: gl,\n        isWebGL2: isWebGL2,\n        getExtension: getExtension,\n        withProgram: withProgram,\n        withTexture: withTexture,\n        withTextureFramebuffer: withTextureFramebuffer,\n        handleContextLoss: handleContextLoss,\n      });\n    }\n    callback(wrapper);\n  }\n\n\n  function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {\n    if ( channels === void 0 ) channels = 15;\n    if ( framebuffer === void 0 ) framebuffer = null;\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n\n      withTexture('copy', function (tex, texUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n        withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {\n          var setUniform = ref.setUniform;\n          var setAttribute = ref.setAttribute;\n\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));\n          setUniform('1i', 'image', texUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);\n          gl.viewport(x, y, width, height);\n          gl.scissor(x, y, width, height);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n    });\n  }\n\n  /**\n   * Resizing a canvas clears its contents; this utility copies the previous contents over.\n   * @param canvas\n   * @param newWidth\n   * @param newHeight\n   */\n  function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {\n    var width = canvas.width;\n    var height = canvas.height;\n    withWebGLContext(canvas, function (ref) {\n      var gl = ref.gl;\n\n      var data = new Uint8Array(width * height * 4);\n      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      canvas.width = newWidth;\n      canvas.height = newHeight;\n      renderImageData(gl, data, 0, 0, width, height);\n    });\n  }\n\n  var webglUtils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    withWebGLContext: withWebGLContext,\n    renderImageData: renderImageData,\n    resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing\n  });\n\n  function generate$2 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    var textureData = new Uint8Array(sdfWidth * sdfHeight);\n\n    var viewBoxWidth = viewBox[2] - viewBox[0];\n    var viewBoxHeight = viewBox[3] - viewBox[1];\n\n    // Decompose all paths into straight line segments and add them to an index\n    var segments = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      segments.push({\n        x1: x1, y1: y1, x2: x2, y2: y2,\n        minX: Math.min(x1, x2),\n        minY: Math.min(y1, y2),\n        maxX: Math.max(x1, x2),\n        maxY: Math.max(y1, y2)\n      });\n    });\n\n    // Sort segments by maxX, this will let us short-circuit some loops below\n    segments.sort(function (a, b) { return a.maxX - b.maxX; });\n\n    // For each target SDF texel, find the distance from its center to its nearest line segment,\n    // map that distance to an alpha value, and write that alpha to the texel\n    for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {\n      for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {\n        var signedDist = findNearestSignedDistance(\n          viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,\n          viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight\n        );\n\n        // Use an exponential scale to ensure the texels very near the glyph path have adequate\n        // precision, while allowing the distance field to cover the entire texture, given that\n        // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam\n        var alpha = Math.pow((1 - Math.abs(signedDist) / maxDistance), sdfExponent) / 2;\n        if (signedDist < 0) {\n          alpha = 1 - alpha;\n        }\n\n        alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp\n        textureData[sdfY * sdfWidth + sdfX] = alpha;\n      }\n    }\n\n    return textureData\n\n    /**\n     * For a given x/y, search the index for the closest line segment and return\n     * its signed distance. Negative = inside, positive = outside, zero = on edge\n     * @param x\n     * @param y\n     * @returns {number}\n     */\n    function findNearestSignedDistance (x, y) {\n      var closestDistSq = Infinity;\n      var closestDist = Infinity;\n\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX + closestDist <= x) { break } //sorting by maxX means no more can be closer, so we can short-circuit\n        if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {\n          var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);\n          if (distSq < closestDistSq) {\n            closestDistSq = distSq;\n            closestDist = Math.sqrt(closestDistSq);\n          }\n        }\n      }\n\n      // Flip to negative distance if inside the poly\n      if (isPointInPoly(x, y)) {\n        closestDist = -closestDist;\n      }\n      return closestDist\n    }\n\n    /**\n     * Determine whether the given point lies inside or outside the glyph. Uses a simple\n     * winding-number ray casting algorithm using a ray pointing east from the point.\n     */\n    function isPointInPoly (x, y) {\n      var winding = 0;\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX <= x) { break } //sorting by maxX means no more can cross, so we can short-circuit\n        var intersects = ((seg.y1 > y) !== (seg.y2 > y)) && (x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1);\n        if (intersects) {\n          winding += seg.y1 < seg.y2 ? 1 : -1;\n        }\n      }\n      return winding !== 0\n    }\n  }\n\n  function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);\n    // Expand single-channel data to rbga\n    var rgbaData = new Uint8Array(data.length * 4);\n    for (var i = 0; i < data.length; i++) {\n      rgbaData[i * 4 + channel] = data[i];\n    }\n    renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << (3 - channel), framebuffer);\n  }\n\n  /**\n   * Find the absolute distance from a point to a line segment at closest approach\n   */\n  function absSquareDistanceToLineSegment (x, y, lineX0, lineY0, lineX1, lineY1) {\n    var ldx = lineX1 - lineX0;\n    var ldy = lineY1 - lineY0;\n    var lengthSq = ldx * ldx + ldy * ldy;\n    var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n    var dx = x - (lineX0 + t * ldx);\n    var dy = y - (lineY0 + t * ldy);\n    return dx * dx + dy * dy\n  }\n\n  var javascript = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$2,\n    generateIntoCanvas: generateIntoCanvas$2,\n    generateIntoFramebuffer: generateIntoFramebuffer$1\n  });\n\n  var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";\n\n  var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\";\n\n  // Single triangle covering viewport\n  var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);\n\n  var implicitContext = null;\n  var isTestingSupport = false;\n  var NULL_OBJECT = {};\n  var supportByCanvas = new WeakMap(); // canvas -> bool\n\n  function validateSupport (glOrCanvas) {\n    if (!isTestingSupport && !isSupported(glOrCanvas)) {\n      throw new Error('WebGL generation not supported')\n    }\n  }\n\n  function generate$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( glOrCanvas === void 0 ) glOrCanvas = null;\n\n    if (!glOrCanvas) {\n      glOrCanvas = implicitContext;\n      if (!glOrCanvas) {\n        var canvas = typeof OffscreenCanvas === 'function'\n          ? new OffscreenCanvas(1, 1)\n          : typeof document !== 'undefined'\n            ? document.createElement('canvas')\n            : null;\n        if (!canvas) {\n          throw new Error('OffscreenCanvas or DOM canvas not supported')\n        }\n        glOrCanvas = implicitContext = canvas.getContext('webgl', { depth: false });\n      }\n    }\n\n    validateSupport(glOrCanvas);\n\n    var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari\n\n    // Render into a background texture framebuffer\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n\n      withTexture('readable', function (texture, textureUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        withTextureFramebuffer(texture, textureUnit, function (framebuffer) {\n          generateIntoFramebuffer(\n            sdfWidth,\n            sdfHeight,\n            path,\n            viewBox,\n            maxDistance,\n            sdfExponent,\n            gl,\n            framebuffer,\n            0,\n            0,\n            0 // red channel\n          );\n          gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n        });\n      });\n    });\n\n    // Throw away all but the red channel\n    var data = new Uint8Array(sdfWidth * sdfHeight);\n    for (var i = 0, j = 0; i < rgbaData.length; i += 4) {\n      data[j++] = rgbaData[i];\n    }\n\n    return data\n  }\n\n  function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    // Verify support\n    validateSupport(glOrCanvas);\n\n    // Compute path segments\n    var lineSegmentCoords = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      lineSegmentCoords.push(x1, y1, x2, y2);\n    });\n    lineSegmentCoords = new Float32Array(lineSegmentCoords);\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var isWebGL2 = ref.isWebGL2;\n      var getExtension = ref.getExtension;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n      var handleContextLoss = ref.handleContextLoss;\n\n      withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {\n        if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {\n          gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA,\n            intermediateTexture._lastWidth = sdfWidth,\n            intermediateTexture._lastHeight = sdfHeight,\n            0, gl.RGBA, gl.UNSIGNED_BYTE, null\n          );\n        }\n\n        // Unsigned distance pass\n        withProgram('main', mainVertex, mainFragment, function (ref) {\n          var setAttribute = ref.setAttribute;\n          var setUniform = ref.setUniform;\n\n          // Init extensions\n          var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');\n          var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');\n\n          // Init/update attributes\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);\n\n          // Init/update uniforms\n          setUniform.apply(void 0, [ '4f', 'uGlyphBounds' ].concat( viewBox ));\n          setUniform('1f', 'uMaxDistance', maxDistance);\n          setUniform('1f', 'uExponent', sdfExponent);\n\n          // Render initial unsigned distance / winding number info to a texture\n          withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {\n            gl.enable(gl.BLEND);\n            gl.colorMask(true, true, true, true);\n            gl.viewport(0, 0, sdfWidth, sdfHeight);\n            gl.scissor(0, 0, sdfWidth, sdfHeight);\n            gl.blendFunc(gl.ONE, gl.ONE);\n            // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".\n            // Alpha holds the closest (MAX) unsigned distance.\n            gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            if (isWebGL2) {\n              gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            } else {\n              instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            }\n            // Debug\n            // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)\n            // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)\n            // console.log('intermediate texture data: ', debug)\n          });\n        });\n\n        // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.\n        withProgram('post', viewportQuadVertex, postFragment, function (program) {\n          program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          program.setUniform('1i', 'tex', intermediateTextureUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n          gl.viewport(x, y, sdfWidth, sdfHeight);\n          gl.scissor(x, y, sdfWidth, sdfHeight);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n\n      // Handle context loss occurring during any of the above calls\n      if (gl.isContextLost()) {\n        handleContextLoss();\n        throw new Error('webgl context lost')\n      }\n    });\n  }\n\n  function isSupported (glOrCanvas) {\n    var key = (!glOrCanvas || glOrCanvas === implicitContext) ? NULL_OBJECT : (glOrCanvas.canvas || glOrCanvas);\n    var supported = supportByCanvas.get(key);\n    if (supported === undefined) {\n      isTestingSupport = true;\n      var failReason = null;\n      try {\n        // Since we can't detect all failure modes up front, let's just do a trial run of a\n        // simple path and compare what we get back to the correct expected result. This will\n        // also serve to prime the shader compilation.\n        var expectedResult = [\n          97, 106, 97, 61,\n          99, 137, 118, 80,\n          80, 118, 137, 99,\n          61, 97, 106, 97\n        ];\n        var testResult = generate$1(\n          4,\n          4,\n          'M8,8L16,8L24,24L16,24Z',\n          [0, 0, 32, 32],\n          24,\n          1,\n          glOrCanvas\n        );\n        supported = testResult && expectedResult.length === testResult.length &&\n          testResult.every(function (val, i) { return val === expectedResult[i]; });\n        if (!supported) {\n          failReason = 'bad trial run results';\n          console.info(expectedResult, testResult);\n        }\n      } catch (err) {\n        // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?\n        supported = false;\n        failReason = err.message;\n      }\n      if (failReason) {\n        console.warn('WebGL SDF generation not supported:', failReason);\n      }\n      isTestingSupport = false;\n      supportByCanvas.set(key, supported);\n    }\n    return supported\n  }\n\n  var webgl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$1,\n    generateIntoCanvas: generateIntoCanvas$1,\n    generateIntoFramebuffer: generateIntoFramebuffer,\n    isSupported: isSupported\n  });\n\n  /**\n   * Generate an SDF texture image for a 2D path.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @return {Uint8Array}\n   */\n  function generate(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    try {\n      return generate$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generate$2.apply(javascript, arguments)\n    }\n  }\n\n  /**\n   * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position\n   * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels\n   * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.\n   *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results\n   *        due to shared GL context state, this canvas should be dedicated to use by this library alone.\n   * @param {number} x - the x position at which to render the SDF.\n   * @param {number} y - the y position at which to render the SDF.\n   * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.\n   * @return {Uint8Array}\n   */\n  function generateIntoCanvas(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent,\n    canvas,\n    x,\n    y,\n    channel\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    try {\n      return generateIntoCanvas$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generateIntoCanvas$2.apply(javascript, arguments)\n    }\n  }\n\n  exports.forEachPathCommand = forEachPathCommand;\n  exports.generate = generate;\n  exports.generateIntoCanvas = generateIntoCanvas;\n  exports.javascript = javascript;\n  exports.pathToLineSegments = pathToLineSegments;\n  exports.webgl = webgl;\n  exports.webglUtils = webglUtils;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn exports\n}\n\nexport { SDFGenerator as default };\n"]},"metadata":{},"sourceType":"module"}
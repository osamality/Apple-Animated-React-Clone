{"ast":null,"code":"import * as THREE from 'three';\nimport * as React from 'react';\nimport { applyProps } from '@react-three/fiber'; // and @0beqz https://gist.github.com/0beqz/8d51b4ae16d68021a09fb504af708fca\n\nconst worldposReplace =\n/* glsl */\n`\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n  vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n  #ifdef BOX_PROJECTED_ENV_MAP\n    vWorldPosition = worldPosition.xyz;\n  #endif\n#endif\n`;\nconst boxProjectDefinitions =\n/*glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n  uniform vec3 envMapSize;\n  uniform vec3 envMapPosition;\n  varying vec3 vWorldPosition;\n    \n  vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {\n    vec3 nDir = normalize( v );\n    vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n    vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n    vec3 rbminmax;\n    rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;\n    rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;\n    rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;\n    float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );\n    vec3 boxIntersection = vWorldPosition + nDir * correction;    \n    return boxIntersection - cubePos;\n  }\n#endif\n`; // will be inserted after \"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\"\n\nconst getIBLIrradiance_patch =\n/* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n  worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );\n#endif\n`; // will be inserted after \"reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\"\n\nconst getIBLRadiance_patch =\n/* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n  reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );\n#endif\n`;\n\nfunction boxProjectedEnvMap(shader, envMapPosition, envMapSize) {\n  shader.defines.BOX_PROJECTED_ENV_MAP = true; // uniforms\n\n  shader.uniforms.envMapPosition = {\n    value: envMapPosition\n  };\n  shader.uniforms.envMapSize = {\n    value: envMapSize\n  }; // vertex shader\n\n  shader.vertexShader = `\n  varying vec3 vWorldPosition;\n  ${shader.vertexShader.replace('#include <worldpos_vertex>', worldposReplace)}`; // fragment shader\n\n  shader.fragmentShader = `\n    ${boxProjectDefinitions}\n    ${shader.fragmentShader.replace('#include <envmap_physical_pars_fragment>', THREE.ShaderChunk.envmap_physical_pars_fragment).replace('vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );', `vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n         ${getIBLIrradiance_patch}\n         `).replace('reflectVec = inverseTransformDirection( reflectVec, viewMatrix );', `reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n         ${getIBLRadiance_patch}\n        `)}`;\n}\n\nfunction useBoxProjectedEnv(position = new THREE.Vector3(), size = new THREE.Vector3()) {\n  const [config] = React.useState(() => ({\n    position: new THREE.Vector3(),\n    size: new THREE.Vector3()\n  }));\n  applyProps(config, {\n    position,\n    size\n  });\n  const ref = React.useRef(null);\n  const spread = React.useMemo(() => ({\n    ref,\n    onBeforeCompile: shader => boxProjectedEnvMap(shader, config.position, config.size),\n    customProgramCacheKey: () => JSON.stringify(config.position.toArray()) + JSON.stringify(config.size.toArray())\n  }), [...config.position.toArray(), ...config.size.toArray()]);\n  React.useLayoutEffect(() => void (ref.current.needsUpdate = true), [config]);\n  return spread;\n}\n\nexport { useBoxProjectedEnv };","map":{"version":3,"sources":["/Users/osamakhan/Desktop/Apple-Website-Clone-React-master/node_modules/@react-three/drei/core/useBoxProjectedEnv.js"],"names":["THREE","React","applyProps","worldposReplace","boxProjectDefinitions","getIBLIrradiance_patch","getIBLRadiance_patch","boxProjectedEnvMap","shader","envMapPosition","envMapSize","defines","BOX_PROJECTED_ENV_MAP","uniforms","value","vertexShader","replace","fragmentShader","ShaderChunk","envmap_physical_pars_fragment","useBoxProjectedEnv","position","Vector3","size","config","useState","ref","useRef","spread","useMemo","onBeforeCompile","customProgramCacheKey","JSON","stringify","toArray","useLayoutEffect","current","needsUpdate"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,UAAT,QAA2B,oBAA3B,C,CAEA;;AAEA,MAAMC,eAAe;AACrB;AACC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CATA;AAUA,MAAMC,qBAAqB;AAC3B;AACC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CArBA,C,CAqBG;;AAEH,MAAMC,sBAAsB;AAC5B;AACC;AACD;AACA;AACA;AACA,CANA,C,CAMG;;AAEH,MAAMC,oBAAoB;AAC1B;AACC;AACD;AACA;AACA;AACA,CANA;;AAQA,SAASC,kBAAT,CAA4BC,MAA5B,EAAoCC,cAApC,EAAoDC,UAApD,EAAgE;AAC9DF,EAAAA,MAAM,CAACG,OAAP,CAAeC,qBAAf,GAAuC,IAAvC,CAD8D,CACjB;;AAE7CJ,EAAAA,MAAM,CAACK,QAAP,CAAgBJ,cAAhB,GAAiC;AAC/BK,IAAAA,KAAK,EAAEL;AADwB,GAAjC;AAGAD,EAAAA,MAAM,CAACK,QAAP,CAAgBH,UAAhB,GAA6B;AAC3BI,IAAAA,KAAK,EAAEJ;AADoB,GAA7B,CAN8D,CAQ3D;;AAEHF,EAAAA,MAAM,CAACO,YAAP,GAAuB;AACzB;AACA,IAAIP,MAAM,CAACO,YAAP,CAAoBC,OAApB,CAA4B,4BAA5B,EAA0Db,eAA1D,CAA2E,EAF7E,CAV8D,CAYkB;;AAEhFK,EAAAA,MAAM,CAACS,cAAP,GAAyB;AAC3B,MAAMb,qBAAsB;AAC5B,MAAMI,MAAM,CAACS,cAAP,CAAsBD,OAAtB,CAA8B,0CAA9B,EAA0EhB,KAAK,CAACkB,WAAN,CAAkBC,6BAA5F,EAA2HH,OAA3H,CAAmI,qEAAnI,EAA2M;AACjN,WAAWX,sBAAuB;AAClC,UAFM,EAEMW,OAFN,CAEc,mEAFd,EAEoF;AAC1F,WAAWV,oBAAqB;AAChC,SAJM,CAIK,EANT;AAOD;;AAED,SAASc,kBAAT,CAA4BC,QAAQ,GAAG,IAAIrB,KAAK,CAACsB,OAAV,EAAvC,EAA4DC,IAAI,GAAG,IAAIvB,KAAK,CAACsB,OAAV,EAAnE,EAAwF;AACtF,QAAM,CAACE,MAAD,IAAWvB,KAAK,CAACwB,QAAN,CAAe,OAAO;AACrCJ,IAAAA,QAAQ,EAAE,IAAIrB,KAAK,CAACsB,OAAV,EAD2B;AAErCC,IAAAA,IAAI,EAAE,IAAIvB,KAAK,CAACsB,OAAV;AAF+B,GAAP,CAAf,CAAjB;AAIApB,EAAAA,UAAU,CAACsB,MAAD,EAAS;AACjBH,IAAAA,QADiB;AAEjBE,IAAAA;AAFiB,GAAT,CAAV;AAIA,QAAMG,GAAG,GAAGzB,KAAK,CAAC0B,MAAN,CAAa,IAAb,CAAZ;AACA,QAAMC,MAAM,GAAG3B,KAAK,CAAC4B,OAAN,CAAc,OAAO;AAClCH,IAAAA,GADkC;AAElCI,IAAAA,eAAe,EAAEtB,MAAM,IAAID,kBAAkB,CAACC,MAAD,EAASgB,MAAM,CAACH,QAAhB,EAA0BG,MAAM,CAACD,IAAjC,CAFX;AAGlCQ,IAAAA,qBAAqB,EAAE,MAAMC,IAAI,CAACC,SAAL,CAAeT,MAAM,CAACH,QAAP,CAAgBa,OAAhB,EAAf,IAA4CF,IAAI,CAACC,SAAL,CAAeT,MAAM,CAACD,IAAP,CAAYW,OAAZ,EAAf;AAHvC,GAAP,CAAd,EAIX,CAAC,GAAGV,MAAM,CAACH,QAAP,CAAgBa,OAAhB,EAAJ,EAA+B,GAAGV,MAAM,CAACD,IAAP,CAAYW,OAAZ,EAAlC,CAJW,CAAf;AAKAjC,EAAAA,KAAK,CAACkC,eAAN,CAAsB,MAAM,MAAMT,GAAG,CAACU,OAAJ,CAAYC,WAAZ,GAA0B,IAAhC,CAA5B,EAAmE,CAACb,MAAD,CAAnE;AACA,SAAOI,MAAP;AACD;;AAED,SAASR,kBAAT","sourcesContent":["import * as THREE from 'three';\nimport * as React from 'react';\nimport { applyProps } from '@react-three/fiber';\n\n// and @0beqz https://gist.github.com/0beqz/8d51b4ae16d68021a09fb504af708fca\n\nconst worldposReplace =\n/* glsl */\n`\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n  vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n  #ifdef BOX_PROJECTED_ENV_MAP\n    vWorldPosition = worldPosition.xyz;\n  #endif\n#endif\n`;\nconst boxProjectDefinitions =\n/*glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n  uniform vec3 envMapSize;\n  uniform vec3 envMapPosition;\n  varying vec3 vWorldPosition;\n    \n  vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {\n    vec3 nDir = normalize( v );\n    vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n    vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n    vec3 rbminmax;\n    rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;\n    rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;\n    rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;\n    float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );\n    vec3 boxIntersection = vWorldPosition + nDir * correction;    \n    return boxIntersection - cubePos;\n  }\n#endif\n`; // will be inserted after \"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\"\n\nconst getIBLIrradiance_patch =\n/* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n  worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );\n#endif\n`; // will be inserted after \"reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\"\n\nconst getIBLRadiance_patch =\n/* glsl */\n`\n#ifdef BOX_PROJECTED_ENV_MAP\n  reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );\n#endif\n`;\n\nfunction boxProjectedEnvMap(shader, envMapPosition, envMapSize) {\n  shader.defines.BOX_PROJECTED_ENV_MAP = true; // uniforms\n\n  shader.uniforms.envMapPosition = {\n    value: envMapPosition\n  };\n  shader.uniforms.envMapSize = {\n    value: envMapSize\n  }; // vertex shader\n\n  shader.vertexShader = `\n  varying vec3 vWorldPosition;\n  ${shader.vertexShader.replace('#include <worldpos_vertex>', worldposReplace)}`; // fragment shader\n\n  shader.fragmentShader = `\n    ${boxProjectDefinitions}\n    ${shader.fragmentShader.replace('#include <envmap_physical_pars_fragment>', THREE.ShaderChunk.envmap_physical_pars_fragment).replace('vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );', `vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n         ${getIBLIrradiance_patch}\n         `).replace('reflectVec = inverseTransformDirection( reflectVec, viewMatrix );', `reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n         ${getIBLRadiance_patch}\n        `)}`;\n}\n\nfunction useBoxProjectedEnv(position = new THREE.Vector3(), size = new THREE.Vector3()) {\n  const [config] = React.useState(() => ({\n    position: new THREE.Vector3(),\n    size: new THREE.Vector3()\n  }));\n  applyProps(config, {\n    position,\n    size\n  });\n  const ref = React.useRef(null);\n  const spread = React.useMemo(() => ({\n    ref,\n    onBeforeCompile: shader => boxProjectedEnvMap(shader, config.position, config.size),\n    customProgramCacheKey: () => JSON.stringify(config.position.toArray()) + JSON.stringify(config.size.toArray())\n  }), [...config.position.toArray(), ...config.size.toArray()]);\n  React.useLayoutEffect(() => void (ref.current.needsUpdate = true), [config]);\n  return spread;\n}\n\nexport { useBoxProjectedEnv };\n"]},"metadata":{},"sourceType":"module"}
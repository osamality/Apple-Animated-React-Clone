{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\nconst RenderTexture = /*#__PURE__*/React.forwardRef(({\n  children,\n  width,\n  height,\n  samples = 8,\n  renderPriority = 0,\n  eventPriority = 0,\n  frames = Infinity,\n  ...props\n}, forwardRef) => {\n  const {\n    size,\n    viewport\n  } = useThree();\n  const fbo = useFBO((width || size.width) * viewport.dpr, (height || size.height) * viewport.dpr, {\n    samples\n  });\n  const [vScene] = React.useState(() => new THREE.Scene());\n  const compute = React.useCallback((event, state, previous) => {\n    var _fbo$texture, _previous$previousRoo; // Since this is only a texture it does not have an easy way to obtain the parent, which we\n    // need to transform event coordinates to local coordinates. We use r3f internals to find the\n    // next Object3D.\n\n\n    let parent = (_fbo$texture = fbo.texture) == null ? void 0 : _fbo$texture.__r3f.parent;\n\n    while (parent && !(parent instanceof THREE.Object3D)) {\n      parent = parent.__r3f.parent;\n    }\n\n    if (!parent) return false; // First we call the previous state-onion-layers compute, this is what makes it possible to nest portals\n\n    if (!previous.raycaster.camera) previous.events.compute(event, previous, (_previous$previousRoo = previous.previousRoot) == null ? void 0 : _previous$previousRoo.getState()); // We run a quick check against the parent, if it isn't hit there's no need to raycast at all\n\n    const [intersection] = previous.raycaster.intersectObject(parent);\n    if (!intersection) return false; // We take that hits uv coords, set up this layers raycaster, et voilà, we have raycasting on arbitrary surfaces\n\n    const uv = intersection.uv;\n    if (!uv) return false;\n    state.raycaster.setFromCamera(state.pointer.set(uv.x * 2 - 1, uv.y * 2 - 1), state.camera);\n  }, []);\n  React.useImperativeHandle(forwardRef, () => fbo.texture, [fbo]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal( /*#__PURE__*/React.createElement(Container, {\n    renderPriority: renderPriority,\n    frames: frames,\n    fbo: fbo\n  }, children), vScene, {\n    events: {\n      compute,\n      priority: eventPriority\n    }\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: fbo.texture\n  }, props)));\n}); // The container component has to be separate, it can not be inlined because \"useFrame(state\" when run inside createPortal will return\n// the portals own state which includes user-land overrides (custom cameras etc), but if it is executed in <RenderTexture>'s render function\n// it would return the default state.\n\nfunction Container({\n  frames,\n  renderPriority,\n  children,\n  fbo\n}) {\n  let count = 0;\n  useFrame(state => {\n    if (frames === Infinity || count < frames) {\n      state.gl.setRenderTarget(fbo);\n      state.gl.render(state.scene, state.camera);\n      state.gl.setRenderTarget(null);\n      count++;\n    }\n  }, renderPriority);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\n\nexport { RenderTexture };","map":{"version":3,"sources":["/Users/osamakhan/Desktop/Apple-Website-Clone-React-master/node_modules/@react-three/drei/core/RenderTexture.js"],"names":["_extends","THREE","React","useThree","createPortal","useFrame","useFBO","RenderTexture","forwardRef","children","width","height","samples","renderPriority","eventPriority","frames","Infinity","props","size","viewport","fbo","dpr","vScene","useState","Scene","compute","useCallback","event","state","previous","_fbo$texture","_previous$previousRoo","parent","texture","__r3f","Object3D","raycaster","camera","events","previousRoot","getState","intersection","intersectObject","uv","setFromCamera","pointer","set","x","y","useImperativeHandle","createElement","Fragment","Container","priority","object","count","gl","setRenderTarget","render","scene"],"mappings":"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","sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\n\nconst RenderTexture = /*#__PURE__*/React.forwardRef(({\n  children,\n  width,\n  height,\n  samples = 8,\n  renderPriority = 0,\n  eventPriority = 0,\n  frames = Infinity,\n  ...props\n}, forwardRef) => {\n  const {\n    size,\n    viewport\n  } = useThree();\n  const fbo = useFBO((width || size.width) * viewport.dpr, (height || size.height) * viewport.dpr, {\n    samples\n  });\n  const [vScene] = React.useState(() => new THREE.Scene());\n  const compute = React.useCallback((event, state, previous) => {\n    var _fbo$texture, _previous$previousRoo;\n\n    // Since this is only a texture it does not have an easy way to obtain the parent, which we\n    // need to transform event coordinates to local coordinates. We use r3f internals to find the\n    // next Object3D.\n    let parent = (_fbo$texture = fbo.texture) == null ? void 0 : _fbo$texture.__r3f.parent;\n\n    while (parent && !(parent instanceof THREE.Object3D)) {\n      parent = parent.__r3f.parent;\n    }\n\n    if (!parent) return false; // First we call the previous state-onion-layers compute, this is what makes it possible to nest portals\n\n    if (!previous.raycaster.camera) previous.events.compute(event, previous, (_previous$previousRoo = previous.previousRoot) == null ? void 0 : _previous$previousRoo.getState()); // We run a quick check against the parent, if it isn't hit there's no need to raycast at all\n\n    const [intersection] = previous.raycaster.intersectObject(parent);\n    if (!intersection) return false; // We take that hits uv coords, set up this layers raycaster, et voilà, we have raycasting on arbitrary surfaces\n\n    const uv = intersection.uv;\n    if (!uv) return false;\n    state.raycaster.setFromCamera(state.pointer.set(uv.x * 2 - 1, uv.y * 2 - 1), state.camera);\n  }, []);\n  React.useImperativeHandle(forwardRef, () => fbo.texture, [fbo]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal( /*#__PURE__*/React.createElement(Container, {\n    renderPriority: renderPriority,\n    frames: frames,\n    fbo: fbo\n  }, children), vScene, {\n    events: {\n      compute,\n      priority: eventPriority\n    }\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: fbo.texture\n  }, props)));\n}); // The container component has to be separate, it can not be inlined because \"useFrame(state\" when run inside createPortal will return\n// the portals own state which includes user-land overrides (custom cameras etc), but if it is executed in <RenderTexture>'s render function\n// it would return the default state.\n\nfunction Container({\n  frames,\n  renderPriority,\n  children,\n  fbo\n}) {\n  let count = 0;\n  useFrame(state => {\n    if (frames === Infinity || count < frames) {\n      state.gl.setRenderTarget(fbo);\n      state.gl.render(state.scene, state.camera);\n      state.gl.setRenderTarget(null);\n      count++;\n    }\n  }, renderPriority);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\n\nexport { RenderTexture };\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Object3D, Matrix4, Vector3, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, Mesh, Line, Quaternion, BufferGeometry, BufferAttribute } from 'three';\n\nclass CCDIKHelper extends Object3D {\n  constructor(mesh, iks = [], sphereSize = 0.25) {\n    super();\n\n    _defineProperty(this, \"_m\", new Matrix4());\n\n    _defineProperty(this, \"_v\", new Vector3());\n\n    this.root = mesh;\n    this.iks = iks;\n    this.matrix.copy(mesh.matrixWorld);\n    this.matrixAutoUpdate = false;\n    this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8);\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0xff8888),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x88ff88),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x8888ff),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(0xff0000),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n\n    function createLineGeometry(ik) {\n      const geometry = new BufferGeometry();\n      const vertices = new Float32Array((2 + ik.links.length) * 3);\n      geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n      return geometry;\n    }\n\n    const scope = this;\n\n    function createTargetMesh() {\n      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n    }\n\n    function createEffectorMesh() {\n      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n    }\n\n    function createLinkMesh() {\n      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n    }\n\n    function createLine(ik) {\n      return new Line(createLineGeometry(ik), scope.lineMaterial);\n    }\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      this.add(createTargetMesh());\n      this.add(createEffectorMesh());\n\n      for (let j = 0, jl = ik.links.length; j < jl; j++) {\n        this.add(createLinkMesh());\n      }\n\n      this.add(createLine(ik));\n    }\n  }\n\n  _getPosition(bone, matrixWorldInv) {\n    return this._v.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n  }\n\n  _setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n    const v = this._getPosition(bone, matrixWorldInv);\n\n    array[index * 3 + 0] = v.x;\n    array[index * 3 + 1] = v.y;\n    array[index * 3 + 2] = v.z;\n  }\n\n  updateMatrixWorld(force) {\n    const mesh = this.root;\n\n    if (this.visible) {\n      let offset = 0;\n      const iks = this.iks;\n      const bones = mesh.skeleton.bones;\n\n      this._m.copy(mesh.matrixWorld).invert();\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const targetBone = bones[ik.target];\n        const effectorBone = bones[ik.effector];\n        const targetMesh = this.children[offset++];\n        const effectorMesh = this.children[offset++];\n        targetMesh.position.copy(this._getPosition(targetBone, this._m));\n        effectorMesh.position.copy(this._getPosition(effectorBone, this._m));\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n          const linkMesh = this.children[offset++];\n          linkMesh.position.copy(this._getPosition(linkBone, this._m));\n        }\n\n        const line = this.children[offset++];\n        const array = line.geometry.attributes.position.array;\n\n        this._setPositionOfBoneToAttributeArray(array, 0, targetBone, this._m);\n\n        this._setPositionOfBoneToAttributeArray(array, 1, effectorBone, this._m);\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n\n          this._setPositionOfBoneToAttributeArray(array, j + 2, linkBone, this._m);\n        }\n\n        line.geometry.attributes.position.needsUpdate = true;\n      }\n    }\n\n    this.matrix.copy(mesh.matrixWorld);\n    super.updateMatrixWorld(force);\n  }\n\n}\n/**\n * CCD Algorithm\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * // ik parameter example\n * //\n * // target, effector, index in links are bone index in skeleton.bones.\n * // the bones relation should be\n * // <-- parent                                  child -->\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n * iks = [ {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * } ];\n */\n\n\nclass CCDIKSolver {\n  constructor(mesh, iks) {\n    _defineProperty(this, \"q\", new Quaternion());\n\n    _defineProperty(this, \"targetPos\", new Vector3());\n\n    _defineProperty(this, \"targetVec\", new Vector3());\n\n    _defineProperty(this, \"effectorPos\", new Vector3());\n\n    _defineProperty(this, \"effectorVec\", new Vector3());\n\n    _defineProperty(this, \"linkPos\", new Vector3());\n\n    _defineProperty(this, \"invLinkQ\", new Quaternion());\n\n    _defineProperty(this, \"linkScale\", new Vector3());\n\n    _defineProperty(this, \"axis\", new Vector3());\n\n    _defineProperty(this, \"vector\", new Vector3());\n\n    this.mesh = mesh;\n    this.iks = iks;\n    const bones = this.mesh.skeleton.bones;\n\n    for (let i = 0, il = this.iks.length; i < il; i++) {\n      const ik = this.iks[i];\n      const effector = bones[ik.effector];\n      const links = ik.links;\n      let link0, link1;\n      link0 = effector;\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        link1 = bones[links[j].index];\n\n        if (link0.parent !== link1) {\n          console.warn(`THREE.CCDIKSolver: bone ${link0.name} is not the child of bone ${link1.name}`);\n        }\n\n        link0 = link1;\n      }\n    }\n  }\n\n  update() {\n    const bones = this.mesh.skeleton.bones;\n    const iks = this.iks; // for reference overhead reduction in loop\n\n    const math = Math;\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      const effector = bones[ik.effector];\n      const target = bones[ik.target]; // don't use getWorldPosition() here for the performance\n      // because it calls updateMatrixWorld( true ) inside.\n\n      this.targetPos.setFromMatrixPosition(target.matrixWorld);\n      const links = ik.links;\n      const iteration = ik.iteration !== undefined ? ik.iteration : 1;\n\n      for (let j = 0; j < iteration; j++) {\n        let rotated = false;\n\n        for (let k = 0, kl = links.length; k < kl; k++) {\n          const link = bones[links[k].index]; // skip this link and following links.\n          // this skip is used for MMD performance optimization.\n\n          if (links[k].enabled === false) break;\n          const limitation = links[k].limitation;\n          const rotationMin = links[k].rotationMin;\n          const rotationMax = links[k].rotationMax; // don't use getWorldPosition/Quaternion() here for the performance\n          // because they call updateMatrixWorld( true ) inside.\n\n          link.matrixWorld.decompose(this.linkPos, this.invLinkQ, this.linkScale);\n          this.invLinkQ.invert();\n          this.effectorPos.setFromMatrixPosition(effector.matrixWorld); // work in link world\n\n          this.effectorVec.subVectors(this.effectorPos, this.linkPos);\n          this.effectorVec.applyQuaternion(this.invLinkQ);\n          this.effectorVec.normalize();\n          this.targetVec.subVectors(this.targetPos, this.linkPos);\n          this.targetVec.applyQuaternion(this.invLinkQ);\n          this.targetVec.normalize();\n          let angle = this.targetVec.dot(this.effectorVec);\n\n          if (angle > 1.0) {\n            angle = 1.0;\n          } else if (angle < -1.0) {\n            angle = -1.0;\n          }\n\n          angle = math.acos(angle); // skip if changing angle is too small to prevent vibration of bone\n          // Refer to http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n\n          if (angle < 1e-5) continue;\n\n          if (ik.minAngle !== undefined && angle < ik.minAngle) {\n            angle = ik.minAngle;\n          }\n\n          if (ik.maxAngle !== undefined && angle > ik.maxAngle) {\n            angle = ik.maxAngle;\n          }\n\n          this.axis.crossVectors(this.effectorVec, this.targetVec);\n          this.axis.normalize();\n          this.q.setFromAxisAngle(this.axis, angle);\n          link.quaternion.multiply(this.q); // TODO: re-consider the limitation specification\n\n          if (limitation !== undefined) {\n            let c = link.quaternion.w;\n            if (c > 1.0) c = 1.0;\n            const c2 = math.sqrt(1 - c * c);\n            link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n          }\n\n          if (rotationMin !== undefined) {\n            link.rotation.setFromVector3(this.vector.setFromEuler(link.rotation).max(rotationMin));\n          }\n\n          if (rotationMax !== undefined) {\n            link.rotation.setFromVector3(this.vector.setFromEuler(link.rotation).min(rotationMax));\n          }\n\n          link.updateMatrixWorld(true);\n          rotated = true;\n        }\n\n        if (!rotated) break;\n      }\n    }\n\n    return this;\n  }\n\n  createHelper() {\n    return new CCDIKHelper(this.mesh, this.mesh.geometry.userData.MMD.iks);\n  }\n\n}\n\nexport { CCDIKHelper, CCDIKSolver };","map":{"version":3,"sources":["/Users/osamakhan/Desktop/dev/Apple-Animated-React-Clone/node_modules/three-stdlib/animation/CCDIKSolver.js"],"names":["_defineProperty","Object3D","Matrix4","Vector3","SphereGeometry","MeshBasicMaterial","Color","LineBasicMaterial","Mesh","Line","Quaternion","BufferGeometry","BufferAttribute","CCDIKHelper","constructor","mesh","iks","sphereSize","root","matrix","copy","matrixWorld","matrixAutoUpdate","sphereGeometry","targetSphereMaterial","color","depthTest","depthWrite","transparent","effectorSphereMaterial","linkSphereMaterial","lineMaterial","createLineGeometry","ik","geometry","vertices","Float32Array","links","length","setAttribute","scope","createTargetMesh","createEffectorMesh","createLinkMesh","createLine","i","il","add","j","jl","_getPosition","bone","matrixWorldInv","_v","setFromMatrixPosition","applyMatrix4","_setPositionOfBoneToAttributeArray","array","index","v","x","y","z","updateMatrixWorld","force","visible","offset","bones","skeleton","_m","invert","targetBone","target","effectorBone","effector","targetMesh","children","effectorMesh","position","link","linkBone","linkMesh","line","attributes","needsUpdate","CCDIKSolver","link0","link1","parent","console","warn","name","update","math","Math","targetPos","iteration","undefined","rotated","k","kl","enabled","limitation","rotationMin","rotationMax","decompose","linkPos","invLinkQ","linkScale","effectorPos","effectorVec","subVectors","applyQuaternion","normalize","targetVec","angle","dot","acos","minAngle","maxAngle","axis","crossVectors","q","setFromAxisAngle","quaternion","multiply","c","w","c2","sqrt","set","rotation","setFromVector3","vector","setFromEuler","max","min","createHelper","userData","MMD"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Object3D, Matrix4, Vector3, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, Mesh, Line, Quaternion, BufferGeometry, BufferAttribute } from 'three';\n\nclass CCDIKHelper extends Object3D {\n  constructor(mesh, iks = [], sphereSize = 0.25) {\n    super();\n\n    _defineProperty(this, \"_m\", new Matrix4());\n\n    _defineProperty(this, \"_v\", new Vector3());\n\n    this.root = mesh;\n    this.iks = iks;\n    this.matrix.copy(mesh.matrixWorld);\n    this.matrixAutoUpdate = false;\n    this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8);\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0xff8888),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x88ff88),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x8888ff),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(0xff0000),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n\n    function createLineGeometry(ik) {\n      const geometry = new BufferGeometry();\n      const vertices = new Float32Array((2 + ik.links.length) * 3);\n      geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n      return geometry;\n    }\n\n    const scope = this;\n\n    function createTargetMesh() {\n      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n    }\n\n    function createEffectorMesh() {\n      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n    }\n\n    function createLinkMesh() {\n      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n    }\n\n    function createLine(ik) {\n      return new Line(createLineGeometry(ik), scope.lineMaterial);\n    }\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      this.add(createTargetMesh());\n      this.add(createEffectorMesh());\n\n      for (let j = 0, jl = ik.links.length; j < jl; j++) {\n        this.add(createLinkMesh());\n      }\n\n      this.add(createLine(ik));\n    }\n  }\n\n  _getPosition(bone, matrixWorldInv) {\n    return this._v.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n  }\n\n  _setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n    const v = this._getPosition(bone, matrixWorldInv);\n\n    array[index * 3 + 0] = v.x;\n    array[index * 3 + 1] = v.y;\n    array[index * 3 + 2] = v.z;\n  }\n\n  updateMatrixWorld(force) {\n    const mesh = this.root;\n\n    if (this.visible) {\n      let offset = 0;\n      const iks = this.iks;\n      const bones = mesh.skeleton.bones;\n\n      this._m.copy(mesh.matrixWorld).invert();\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const targetBone = bones[ik.target];\n        const effectorBone = bones[ik.effector];\n        const targetMesh = this.children[offset++];\n        const effectorMesh = this.children[offset++];\n        targetMesh.position.copy(this._getPosition(targetBone, this._m));\n        effectorMesh.position.copy(this._getPosition(effectorBone, this._m));\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n          const linkMesh = this.children[offset++];\n          linkMesh.position.copy(this._getPosition(linkBone, this._m));\n        }\n\n        const line = this.children[offset++];\n        const array = line.geometry.attributes.position.array;\n\n        this._setPositionOfBoneToAttributeArray(array, 0, targetBone, this._m);\n\n        this._setPositionOfBoneToAttributeArray(array, 1, effectorBone, this._m);\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n\n          this._setPositionOfBoneToAttributeArray(array, j + 2, linkBone, this._m);\n        }\n\n        line.geometry.attributes.position.needsUpdate = true;\n      }\n    }\n\n    this.matrix.copy(mesh.matrixWorld);\n    super.updateMatrixWorld(force);\n  }\n\n}\n/**\n * CCD Algorithm\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * // ik parameter example\n * //\n * // target, effector, index in links are bone index in skeleton.bones.\n * // the bones relation should be\n * // <-- parent                                  child -->\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n * iks = [ {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * } ];\n */\n\n\nclass CCDIKSolver {\n  constructor(mesh, iks) {\n    _defineProperty(this, \"q\", new Quaternion());\n\n    _defineProperty(this, \"targetPos\", new Vector3());\n\n    _defineProperty(this, \"targetVec\", new Vector3());\n\n    _defineProperty(this, \"effectorPos\", new Vector3());\n\n    _defineProperty(this, \"effectorVec\", new Vector3());\n\n    _defineProperty(this, \"linkPos\", new Vector3());\n\n    _defineProperty(this, \"invLinkQ\", new Quaternion());\n\n    _defineProperty(this, \"linkScale\", new Vector3());\n\n    _defineProperty(this, \"axis\", new Vector3());\n\n    _defineProperty(this, \"vector\", new Vector3());\n\n    this.mesh = mesh;\n    this.iks = iks;\n    const bones = this.mesh.skeleton.bones;\n\n    for (let i = 0, il = this.iks.length; i < il; i++) {\n      const ik = this.iks[i];\n      const effector = bones[ik.effector];\n      const links = ik.links;\n      let link0, link1;\n      link0 = effector;\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        link1 = bones[links[j].index];\n\n        if (link0.parent !== link1) {\n          console.warn(`THREE.CCDIKSolver: bone ${link0.name} is not the child of bone ${link1.name}`);\n        }\n\n        link0 = link1;\n      }\n    }\n  }\n\n  update() {\n    const bones = this.mesh.skeleton.bones;\n    const iks = this.iks; // for reference overhead reduction in loop\n\n    const math = Math;\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      const effector = bones[ik.effector];\n      const target = bones[ik.target]; // don't use getWorldPosition() here for the performance\n      // because it calls updateMatrixWorld( true ) inside.\n\n      this.targetPos.setFromMatrixPosition(target.matrixWorld);\n      const links = ik.links;\n      const iteration = ik.iteration !== undefined ? ik.iteration : 1;\n\n      for (let j = 0; j < iteration; j++) {\n        let rotated = false;\n\n        for (let k = 0, kl = links.length; k < kl; k++) {\n          const link = bones[links[k].index]; // skip this link and following links.\n          // this skip is used for MMD performance optimization.\n\n          if (links[k].enabled === false) break;\n          const limitation = links[k].limitation;\n          const rotationMin = links[k].rotationMin;\n          const rotationMax = links[k].rotationMax; // don't use getWorldPosition/Quaternion() here for the performance\n          // because they call updateMatrixWorld( true ) inside.\n\n          link.matrixWorld.decompose(this.linkPos, this.invLinkQ, this.linkScale);\n          this.invLinkQ.invert();\n          this.effectorPos.setFromMatrixPosition(effector.matrixWorld); // work in link world\n\n          this.effectorVec.subVectors(this.effectorPos, this.linkPos);\n          this.effectorVec.applyQuaternion(this.invLinkQ);\n          this.effectorVec.normalize();\n          this.targetVec.subVectors(this.targetPos, this.linkPos);\n          this.targetVec.applyQuaternion(this.invLinkQ);\n          this.targetVec.normalize();\n          let angle = this.targetVec.dot(this.effectorVec);\n\n          if (angle > 1.0) {\n            angle = 1.0;\n          } else if (angle < -1.0) {\n            angle = -1.0;\n          }\n\n          angle = math.acos(angle); // skip if changing angle is too small to prevent vibration of bone\n          // Refer to http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n\n          if (angle < 1e-5) continue;\n\n          if (ik.minAngle !== undefined && angle < ik.minAngle) {\n            angle = ik.minAngle;\n          }\n\n          if (ik.maxAngle !== undefined && angle > ik.maxAngle) {\n            angle = ik.maxAngle;\n          }\n\n          this.axis.crossVectors(this.effectorVec, this.targetVec);\n          this.axis.normalize();\n          this.q.setFromAxisAngle(this.axis, angle);\n          link.quaternion.multiply(this.q); // TODO: re-consider the limitation specification\n\n          if (limitation !== undefined) {\n            let c = link.quaternion.w;\n            if (c > 1.0) c = 1.0;\n            const c2 = math.sqrt(1 - c * c);\n            link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n          }\n\n          if (rotationMin !== undefined) {\n            link.rotation.setFromVector3(this.vector.setFromEuler(link.rotation).max(rotationMin));\n          }\n\n          if (rotationMax !== undefined) {\n            link.rotation.setFromVector3(this.vector.setFromEuler(link.rotation).min(rotationMax));\n          }\n\n          link.updateMatrixWorld(true);\n          rotated = true;\n        }\n\n        if (!rotated) break;\n      }\n    }\n\n    return this;\n  }\n\n  createHelper() {\n    return new CCDIKHelper(this.mesh, this.mesh.geometry.userData.MMD.iks);\n  }\n\n}\n\nexport { CCDIKHelper, CCDIKSolver };\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { ShaderNode, exp2, mul, sub, add, cond, pow, saturate, div, negate, and, greaterThan, pow2, sqrt, max, EPSILON, normalize, positionViewDirection, dot, transformedNormalView, addTo, diffuseColor, specularColor, roughness } from '../ShaderNode.js';\nconst F_Schlick = new ShaderNode(inputs => {\n  const {\n    f0,\n    f90,\n    dotVH\n  } = inputs; // Original approximation by Christophe Schlick '94\n  // float fresnel = pow( 1.0 - dotVH, 5.0 );\n  // Optimized variant (presented by Epic at SIGGRAPH '13)\n  // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\n  const fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));\n  return add(mul(f0, sub(1.0, fresnel)), mul(f90, fresnel));\n}); // validated\n\nconst BRDF_Lambert = new ShaderNode(inputs => {\n  return mul(1 / Math.PI, inputs.diffuseColor); // punctual light\n}); // validated\n\nconst getDistanceAttenuation = new ShaderNode(inputs => {\n  const {\n    lightDistance,\n    cutoffDistance,\n    decayExponent\n  } = inputs;\n  return cond(and(greaterThan(cutoffDistance, 0), greaterThan(decayExponent, 0)), pow(saturate(add(div(negate(lightDistance), cutoffDistance), 1.0)), decayExponent), 1.0);\n}); // validated\n//\n// STANDARD\n//\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\nconst V_GGX_SmithCorrelated = new ShaderNode(inputs => {\n  const {\n    alpha,\n    dotNL,\n    dotNV\n  } = inputs;\n  const a2 = pow2(alpha);\n  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNV)))));\n  const gl = mul(dotNV, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNL)))));\n  return div(0.5, max(add(gv, gl), EPSILON));\n}); // validated\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneyâ€™s reparameterization\n\nconst D_GGX = new ShaderNode(inputs => {\n  const {\n    alpha,\n    dotNH\n  } = inputs;\n  const a2 = pow2(alpha);\n  const denom = add(mul(pow2(dotNH), sub(a2, 1.0)), 1.0); // avoid alpha = 0 with dotNH = 1\n\n  return mul(1 / Math.PI, div(a2, pow2(denom)));\n}); // validated\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\n\nconst BRDF_GGX = new ShaderNode(inputs => {\n  const {\n    lightDirection,\n    f0,\n    f90,\n    roughness\n  } = inputs;\n  const alpha = pow2(roughness); // UE4's roughness\n\n  const halfDir = normalize(add(lightDirection, positionViewDirection));\n  const dotNL = saturate(dot(transformedNormalView, lightDirection));\n  const dotNV = saturate(dot(transformedNormalView, positionViewDirection));\n  const dotNH = saturate(dot(transformedNormalView, halfDir));\n  const dotVH = saturate(dot(positionViewDirection, halfDir));\n  const F = F_Schlick({\n    f0,\n    f90,\n    dotVH\n  });\n  const V = V_GGX_SmithCorrelated({\n    alpha,\n    dotNL,\n    dotNV\n  });\n  const D = D_GGX({\n    alpha,\n    dotNH\n  });\n  return mul(F, mul(V, D));\n}); // validated\n\nconst RE_Direct_Physical = new ShaderNode(inputs => {\n  const {\n    lightDirection,\n    lightColor,\n    directDiffuse,\n    directSpecular\n  } = inputs;\n  const dotNL = saturate(dot(transformedNormalView, lightDirection));\n  let irradiance = mul(dotNL, lightColor);\n  irradiance = mul(irradiance, Math.PI); // punctual light\n\n  addTo(directDiffuse, mul(irradiance, BRDF_Lambert({\n    diffuseColor: diffuseColor.rgb\n  })));\n  addTo(directSpecular, mul(irradiance, BRDF_GGX({\n    lightDirection,\n    f0: specularColor,\n    f90: 1,\n    roughness\n  })));\n});\nconst PhysicalLightingModel = new ShaderNode((inputs\n/*, builder*/\n) => {\n  // PHYSICALLY_CORRECT_LIGHTS <-> builder.renderer.physicallyCorrectLights === true\n  RE_Direct_Physical(inputs);\n});\nexport { BRDF_GGX, BRDF_Lambert, D_GGX, F_Schlick, PhysicalLightingModel, RE_Direct_Physical, V_GGX_SmithCorrelated, getDistanceAttenuation };","map":{"version":3,"sources":["/Users/osamakhan/Desktop/Apple-Website-Clone-React-master/node_modules/three-stdlib/nodes/functions/BSDFs.js"],"names":["ShaderNode","exp2","mul","sub","add","cond","pow","saturate","div","negate","and","greaterThan","pow2","sqrt","max","EPSILON","normalize","positionViewDirection","dot","transformedNormalView","addTo","diffuseColor","specularColor","roughness","F_Schlick","inputs","f0","f90","dotVH","fresnel","BRDF_Lambert","Math","PI","getDistanceAttenuation","lightDistance","cutoffDistance","decayExponent","V_GGX_SmithCorrelated","alpha","dotNL","dotNV","a2","gv","gl","D_GGX","dotNH","denom","BRDF_GGX","lightDirection","halfDir","F","V","D","RE_Direct_Physical","lightColor","directDiffuse","directSpecular","irradiance","rgb","PhysicalLightingModel"],"mappings":"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","sourcesContent":["import { ShaderNode, exp2, mul, sub, add, cond, pow, saturate, div, negate, and, greaterThan, pow2, sqrt, max, EPSILON, normalize, positionViewDirection, dot, transformedNormalView, addTo, diffuseColor, specularColor, roughness } from '../ShaderNode.js';\n\nconst F_Schlick = new ShaderNode(inputs => {\n  const {\n    f0,\n    f90,\n    dotVH\n  } = inputs; // Original approximation by Christophe Schlick '94\n  // float fresnel = pow( 1.0 - dotVH, 5.0 );\n  // Optimized variant (presented by Epic at SIGGRAPH '13)\n  // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\n  const fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));\n  return add(mul(f0, sub(1.0, fresnel)), mul(f90, fresnel));\n}); // validated\n\nconst BRDF_Lambert = new ShaderNode(inputs => {\n  return mul(1 / Math.PI, inputs.diffuseColor); // punctual light\n}); // validated\n\nconst getDistanceAttenuation = new ShaderNode(inputs => {\n  const {\n    lightDistance,\n    cutoffDistance,\n    decayExponent\n  } = inputs;\n  return cond(and(greaterThan(cutoffDistance, 0), greaterThan(decayExponent, 0)), pow(saturate(add(div(negate(lightDistance), cutoffDistance), 1.0)), decayExponent), 1.0);\n}); // validated\n//\n// STANDARD\n//\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\nconst V_GGX_SmithCorrelated = new ShaderNode(inputs => {\n  const {\n    alpha,\n    dotNL,\n    dotNV\n  } = inputs;\n  const a2 = pow2(alpha);\n  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNV)))));\n  const gl = mul(dotNV, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNL)))));\n  return div(0.5, max(add(gv, gl), EPSILON));\n}); // validated\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneyâ€™s reparameterization\n\nconst D_GGX = new ShaderNode(inputs => {\n  const {\n    alpha,\n    dotNH\n  } = inputs;\n  const a2 = pow2(alpha);\n  const denom = add(mul(pow2(dotNH), sub(a2, 1.0)), 1.0); // avoid alpha = 0 with dotNH = 1\n\n  return mul(1 / Math.PI, div(a2, pow2(denom)));\n}); // validated\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\n\nconst BRDF_GGX = new ShaderNode(inputs => {\n  const {\n    lightDirection,\n    f0,\n    f90,\n    roughness\n  } = inputs;\n  const alpha = pow2(roughness); // UE4's roughness\n\n  const halfDir = normalize(add(lightDirection, positionViewDirection));\n  const dotNL = saturate(dot(transformedNormalView, lightDirection));\n  const dotNV = saturate(dot(transformedNormalView, positionViewDirection));\n  const dotNH = saturate(dot(transformedNormalView, halfDir));\n  const dotVH = saturate(dot(positionViewDirection, halfDir));\n  const F = F_Schlick({\n    f0,\n    f90,\n    dotVH\n  });\n  const V = V_GGX_SmithCorrelated({\n    alpha,\n    dotNL,\n    dotNV\n  });\n  const D = D_GGX({\n    alpha,\n    dotNH\n  });\n  return mul(F, mul(V, D));\n}); // validated\n\nconst RE_Direct_Physical = new ShaderNode(inputs => {\n  const {\n    lightDirection,\n    lightColor,\n    directDiffuse,\n    directSpecular\n  } = inputs;\n  const dotNL = saturate(dot(transformedNormalView, lightDirection));\n  let irradiance = mul(dotNL, lightColor);\n  irradiance = mul(irradiance, Math.PI); // punctual light\n\n  addTo(directDiffuse, mul(irradiance, BRDF_Lambert({\n    diffuseColor: diffuseColor.rgb\n  })));\n  addTo(directSpecular, mul(irradiance, BRDF_GGX({\n    lightDirection,\n    f0: specularColor,\n    f90: 1,\n    roughness\n  })));\n});\nconst PhysicalLightingModel = new ShaderNode((inputs\n/*, builder*/\n) => {\n  // PHYSICALLY_CORRECT_LIGHTS <-> builder.renderer.physicallyCorrectLights === true\n  RE_Direct_Physical(inputs);\n});\n\nexport { BRDF_GGX, BRDF_Lambert, D_GGX, F_Schlick, PhysicalLightingModel, RE_Direct_Physical, V_GGX_SmithCorrelated, getDistanceAttenuation };\n"]},"metadata":{},"sourceType":"module"}
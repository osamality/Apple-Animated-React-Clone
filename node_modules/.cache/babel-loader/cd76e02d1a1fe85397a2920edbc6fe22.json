{"ast":null,"code":"\"use strict\";\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LLkLookaheadStrategy = void 0;\n\nvar flatMap_1 = __importDefault(require(\"lodash/flatMap\"));\n\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\n\nvar errors_public_1 = require(\"../errors_public\");\n\nvar parser_1 = require(\"../parser/parser\");\n\nvar checks_1 = require(\"./checks\");\n\nvar lookahead_1 = require(\"./lookahead\");\n\nvar LLkLookaheadStrategy =\n/** @class */\nfunction () {\n  function LLkLookaheadStrategy(options) {\n    var _a;\n\n    this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n  }\n\n  LLkLookaheadStrategy.prototype.validate = function (options) {\n    var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n\n    if ((0, isEmpty_1.default)(leftRecursionErrors)) {\n      var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n      var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n      var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n\n      var allErrors = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], leftRecursionErrors, true), emptyAltErrors, true), ambiguousAltsErrors, true), emptyRepetitionErrors, true);\n\n      return allErrors;\n    }\n\n    return leftRecursionErrors;\n  };\n\n  LLkLookaheadStrategy.prototype.validateNoLeftRecursion = function (rules) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateNoLeftRecursion)(currTopRule, currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n\n  LLkLookaheadStrategy.prototype.validateEmptyOrAlternatives = function (rules) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateEmptyOrAlternative)(currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n\n  LLkLookaheadStrategy.prototype.validateAmbiguousAlternationAlternatives = function (rules, maxLookahead) {\n    return (0, flatMap_1.default)(rules, function (currTopRule) {\n      return (0, checks_1.validateAmbiguousAlternationAlternatives)(currTopRule, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);\n    });\n  };\n\n  LLkLookaheadStrategy.prototype.validateSomeNonEmptyLookaheadPath = function (rules, maxLookahead) {\n    return (0, checks_1.validateSomeNonEmptyLookaheadPath)(rules, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);\n  };\n\n  LLkLookaheadStrategy.prototype.buildLookaheadForAlternation = function (options) {\n    return (0, lookahead_1.buildLookaheadFuncForOr)(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, lookahead_1.buildAlternativesLookAheadFunc);\n  };\n\n  LLkLookaheadStrategy.prototype.buildLookaheadForOptional = function (options) {\n    return (0, lookahead_1.buildLookaheadFuncForOptionalProd)(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, (0, lookahead_1.getProdType)(options.prodType), lookahead_1.buildSingleAlternativeLookaheadFunction);\n  };\n\n  return LLkLookaheadStrategy;\n}();\n\nexports.LLkLookaheadStrategy = LLkLookaheadStrategy;","map":{"version":3,"sources":["../../../../src/parse/grammar/llk_lookahead.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LLkLookaheadStrategy = void 0;\nvar flatMap_1 = __importDefault(require(\"lodash/flatMap\"));\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar errors_public_1 = require(\"../errors_public\");\nvar parser_1 = require(\"../parser/parser\");\nvar checks_1 = require(\"./checks\");\nvar lookahead_1 = require(\"./lookahead\");\nvar LLkLookaheadStrategy = /** @class */ (function () {\n    function LLkLookaheadStrategy(options) {\n        var _a;\n        this.maxLookahead =\n            (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n    }\n    LLkLookaheadStrategy.prototype.validate = function (options) {\n        var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n        if ((0, isEmpty_1.default)(leftRecursionErrors)) {\n            var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n            var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n            var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n            var allErrors = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], leftRecursionErrors, true), emptyAltErrors, true), ambiguousAltsErrors, true), emptyRepetitionErrors, true);\n            return allErrors;\n        }\n        return leftRecursionErrors;\n    };\n    LLkLookaheadStrategy.prototype.validateNoLeftRecursion = function (rules) {\n        return (0, flatMap_1.default)(rules, function (currTopRule) {\n            return (0, checks_1.validateNoLeftRecursion)(currTopRule, currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);\n        });\n    };\n    LLkLookaheadStrategy.prototype.validateEmptyOrAlternatives = function (rules) {\n        return (0, flatMap_1.default)(rules, function (currTopRule) {\n            return (0, checks_1.validateEmptyOrAlternative)(currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);\n        });\n    };\n    LLkLookaheadStrategy.prototype.validateAmbiguousAlternationAlternatives = function (rules, maxLookahead) {\n        return (0, flatMap_1.default)(rules, function (currTopRule) {\n            return (0, checks_1.validateAmbiguousAlternationAlternatives)(currTopRule, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);\n        });\n    };\n    LLkLookaheadStrategy.prototype.validateSomeNonEmptyLookaheadPath = function (rules, maxLookahead) {\n        return (0, checks_1.validateSomeNonEmptyLookaheadPath)(rules, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);\n    };\n    LLkLookaheadStrategy.prototype.buildLookaheadForAlternation = function (options) {\n        return (0, lookahead_1.buildLookaheadFuncForOr)(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, lookahead_1.buildAlternativesLookAheadFunc);\n    };\n    LLkLookaheadStrategy.prototype.buildLookaheadForOptional = function (options) {\n        return (0, lookahead_1.buildLookaheadFuncForOptionalProd)(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, (0, lookahead_1.getProdType)(options.prodType), lookahead_1.buildSingleAlternativeLookaheadFunction);\n    };\n    return LLkLookaheadStrategy;\n}());\nexports.LLkLookaheadStrategy = LLkLookaheadStrategy;\n//# sourceMappingURL=llk_lookahead.js.map"]},"metadata":{},"sourceType":"script"}
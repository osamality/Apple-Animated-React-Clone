{"ast":null,"code":"import { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, sRGBEncoding, LinearFilter, Color } from 'three';\n\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom);\n    const geometry = new PlaneGeometry(texture.image.width * 0.001, texture.image.height * 0.001);\n    const material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    super(geometry, material);\n\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n\n    this.addEventListener('mousedown', onEvent);\n    this.addEventListener('mousemove', onEvent);\n    this.addEventListener('mouseup', onEvent);\n    this.addEventListener('click', onEvent);\n\n    this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener('mousedown', onEvent);\n      this.removeEventListener('mousemove', onEvent);\n      this.removeEventListener('mouseup', onEvent);\n      this.removeEventListener('click', onEvent);\n    };\n  }\n\n}\n\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom));\n    this.dom = dom;\n    this.anisotropy = 16;\n    this.encoding = sRGBEncoding;\n    this.minFilter = LinearFilter;\n    this.magFilter = LinearFilter; // Create an observer on the DOM, and run html2canvas update in the next loop\n\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        // ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n        this.scheduleUpdate = setTimeout(() => this.update(), 16);\n      }\n    });\n    const config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    this.observer = observer;\n  }\n\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y);\n    }\n  }\n\n  update() {\n    this.image = html2canvas(this.dom);\n    this.needsUpdate = true;\n    this.scheduleUpdate = null;\n  }\n\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n    super.dispose();\n  }\n\n} //\n\n\nconst canvases = new WeakMap();\n\nfunction html2canvas(element) {\n  const range = document.createRange();\n  const color = new Color();\n\n  function Clipper(context) {\n    const clips = [];\n    let isClipping = false;\n\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context.restore();\n      }\n\n      if (clips.length === 0) return;\n      let minX = -Infinity,\n          minY = -Infinity;\n      let maxX = Infinity,\n          maxY = Infinity;\n\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n\n      context.save();\n      context.beginPath();\n      context.rect(minX, minY, maxX - minX, maxY - minY);\n      context.clip();\n      isClipping = true;\n    }\n\n    return {\n      add: function (clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function () {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n\n  function drawText(style, x, y, string) {\n    if (string !== '') {\n      if (style.textTransform === 'uppercase') {\n        string = string.toUpperCase();\n      }\n\n      context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;\n      context.textBaseline = 'top';\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + 'Width'];\n    const borderStyle = style[which + 'Style'];\n    const borderColor = style[which + 'Color'];\n\n    if (borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)') {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n\n  function drawElement(element, style) {\n    let x = 0,\n        y = 0,\n        width = 0,\n        height = 0;\n\n    if (element.nodeType === Node.TEXT_NODE) {\n      // text\n      range.selectNode(element);\n      const rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element.nodeValue.trim());\n    } else if (element.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element instanceof HTMLCanvasElement) {\n      // Canvas element\n      if (element.style.display === 'none') return;\n      context.save();\n      const dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element, 0, 0);\n      context.restore();\n    } else {\n      if (element.style.display === 'none') return;\n      const rect = element.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      style = window.getComputedStyle(element); // Get the border of the element used for fill and border\n\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      const backgroundColor = style.backgroundColor;\n\n      if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      } // If all the borders match then stroke the round rectangle\n\n\n      const borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight'];\n      let match = true;\n      let prevBorder = null;\n\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match = style[border + 'Width'] === style[prevBorder + 'Width'] && style[border + 'Color'] === style[prevBorder + 'Color'] && style[border + 'Style'] === style[prevBorder + 'Style'];\n        }\n\n        if (match === false) break;\n        prevBorder = border;\n      }\n\n      if (match === true) {\n        // They all match so stroke the rectangle from before allows for border-radius\n        const width = parseFloat(style.borderTopWidth);\n\n        if (style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)') {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width;\n          context.stroke();\n        }\n      } else {\n        // Otherwise draw individual borders\n        drawBorder(style, 'borderTop', x, y, width, 0);\n        drawBorder(style, 'borderLeft', x, y, 0, height);\n        drawBorder(style, 'borderBottom', x, y + height, width, 0);\n        drawBorder(style, 'borderRight', x + width, y, 0, height);\n      }\n\n      if (element instanceof HTMLInputElement) {\n        let accentColor = style.accentColor;\n        if (accentColor === undefined || accentColor === 'auto') accentColor = style.color;\n        color.set(accentColor);\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);\n        const accentTextColor = luminance < 0.5 ? 'white' : '#111111';\n\n        if (element.type === 'radio') {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = 'white';\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n\n          if (element.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n\n        if (element.type === 'checkbox') {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element.checked ? accentColor : 'white';\n          context.strokeStyle = element.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n\n          if (element.checked) {\n            const currentTextAlign = context.textAlign;\n            context.textAlign = 'center';\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + 'px',\n              fontWeight: 'bold'\n            };\n            drawText(properties, x + width / 2, y, '✔');\n            context.textAlign = currentTextAlign;\n          }\n        }\n\n        if (element.type === 'range') {\n          const [min, max, value] = ['min', 'max', 'value'].map(property => parseFloat(element[property]));\n          const position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n\n        if (element.type === 'color' || element.type === 'text' || element.type === 'number') {\n          clipper.add({\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element.value);\n          clipper.remove();\n        }\n      }\n    }\n    /*\n    // debug\n    context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n    context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n    */\n\n\n    const isClipping = style.overflow === 'auto' || style.overflow === 'hidden';\n    if (isClipping) clipper.add({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    });\n\n    for (let i = 0; i < element.childNodes.length; i++) {\n      drawElement(element.childNodes[i], style);\n    }\n\n    if (isClipping) clipper.remove();\n  }\n\n  const offset = element.getBoundingClientRect();\n  let canvas = canvases.get(element);\n\n  if (canvas === undefined) {\n    canvas = document.createElement('canvas');\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n\n  const context = canvas.getContext('2d'\n  /*, { alpha: false }*/\n  );\n  const clipper = new Clipper(context); // console.time( 'drawElement' );\n\n  drawElement(element); // console.timeEnd( 'drawElement' );\n\n  return canvas;\n}\n\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  const rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n\n  function traverse(element) {\n    if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {\n      const rect = element.getBoundingClientRect();\n\n      if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {\n        element.dispatchEvent(new MouseEvent(event, mouseEventInit));\n\n        if (element instanceof HTMLInputElement && element.type === 'range' && (event === 'mousedown' || event === 'click')) {\n          const [min, max] = ['min', 'max'].map(property => parseFloat(element[property]));\n          const width = rect.width;\n          const offsetX = x - rect.x;\n          const proportion = offsetX / width;\n          element.value = min + (max - min) * proportion;\n          element.dispatchEvent(new InputEvent('input', {\n            bubbles: true\n          }));\n        }\n      }\n\n      for (let i = 0; i < element.childNodes.length; i++) {\n        traverse(element.childNodes[i]);\n      }\n    }\n  }\n\n  traverse(element);\n}\n\nexport { HTMLMesh };","map":{"version":3,"sources":["/Users/osamakhan/Desktop/dev/Apple-Animated-React-Clone/node_modules/three-stdlib/interactive/HTMLMesh.js"],"names":["Mesh","PlaneGeometry","MeshBasicMaterial","CanvasTexture","sRGBEncoding","LinearFilter","Color","HTMLMesh","constructor","dom","texture","HTMLTexture","geometry","image","width","height","material","map","toneMapped","transparent","onEvent","event","dispatchDOMEvent","addEventListener","dispose","canvases","delete","removeEventListener","html2canvas","anisotropy","encoding","minFilter","magFilter","observer","MutationObserver","scheduleUpdate","setTimeout","update","config","attributes","childList","subtree","characterData","observe","data","htmlevent","type","x","y","needsUpdate","disconnect","clearTimeout","WeakMap","element","range","document","createRange","color","Clipper","context","clips","isClipping","doClip","restore","length","minX","Infinity","minY","maxX","maxY","i","clip","Math","max","min","save","beginPath","rect","add","push","remove","pop","drawText","style","string","textTransform","toUpperCase","font","fontWeight","fontSize","fontFamily","textBaseline","fillStyle","fillText","parseFloat","buildRectPath","w","h","r","moveTo","arcTo","closePath","drawBorder","which","borderWidth","borderStyle","borderColor","strokeStyle","lineWidth","lineTo","stroke","drawElement","nodeType","Node","TEXT_NODE","selectNode","getBoundingClientRect","left","offset","top","nodeValue","trim","COMMENT_NODE","HTMLCanvasElement","display","dpr","window","devicePixelRatio","scale","drawImage","getComputedStyle","borderRadius","backgroundColor","fill","borders","match","prevBorder","border","borderTopWidth","borderTopStyle","borderTopColor","HTMLInputElement","accentColor","undefined","set","luminance","sqrt","g","b","accentTextColor","checked","currentTextAlign","textAlign","properties","value","property","position","clipper","parseInt","paddingLeft","paddingTop","overflow","childNodes","canvas","get","createElement","getContext","mouseEventInit","clientX","offsetWidth","offsetLeft","clientY","offsetHeight","offsetTop","view","ownerDocument","defaultView","dispatchEvent","MouseEvent","traverse","right","bottom","offsetX","proportion","InputEvent","bubbles"],"mappings":"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","sourcesContent":["import { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, sRGBEncoding, LinearFilter, Color } from 'three';\n\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom);\n    const geometry = new PlaneGeometry(texture.image.width * 0.001, texture.image.height * 0.001);\n    const material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    super(geometry, material);\n\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n\n    this.addEventListener('mousedown', onEvent);\n    this.addEventListener('mousemove', onEvent);\n    this.addEventListener('mouseup', onEvent);\n    this.addEventListener('click', onEvent);\n\n    this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener('mousedown', onEvent);\n      this.removeEventListener('mousemove', onEvent);\n      this.removeEventListener('mouseup', onEvent);\n      this.removeEventListener('click', onEvent);\n    };\n  }\n\n}\n\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom));\n    this.dom = dom;\n    this.anisotropy = 16;\n    this.encoding = sRGBEncoding;\n    this.minFilter = LinearFilter;\n    this.magFilter = LinearFilter; // Create an observer on the DOM, and run html2canvas update in the next loop\n\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        // ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n        this.scheduleUpdate = setTimeout(() => this.update(), 16);\n      }\n    });\n    const config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    this.observer = observer;\n  }\n\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y);\n    }\n  }\n\n  update() {\n    this.image = html2canvas(this.dom);\n    this.needsUpdate = true;\n    this.scheduleUpdate = null;\n  }\n\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n    super.dispose();\n  }\n\n} //\n\n\nconst canvases = new WeakMap();\n\nfunction html2canvas(element) {\n  const range = document.createRange();\n  const color = new Color();\n\n  function Clipper(context) {\n    const clips = [];\n    let isClipping = false;\n\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context.restore();\n      }\n\n      if (clips.length === 0) return;\n      let minX = -Infinity,\n          minY = -Infinity;\n      let maxX = Infinity,\n          maxY = Infinity;\n\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n\n      context.save();\n      context.beginPath();\n      context.rect(minX, minY, maxX - minX, maxY - minY);\n      context.clip();\n      isClipping = true;\n    }\n\n    return {\n      add: function (clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function () {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n\n  function drawText(style, x, y, string) {\n    if (string !== '') {\n      if (style.textTransform === 'uppercase') {\n        string = string.toUpperCase();\n      }\n\n      context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily;\n      context.textBaseline = 'top';\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + 'Width'];\n    const borderStyle = style[which + 'Style'];\n    const borderColor = style[which + 'Color'];\n\n    if (borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)') {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n\n  function drawElement(element, style) {\n    let x = 0,\n        y = 0,\n        width = 0,\n        height = 0;\n\n    if (element.nodeType === Node.TEXT_NODE) {\n      // text\n      range.selectNode(element);\n      const rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element.nodeValue.trim());\n    } else if (element.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element instanceof HTMLCanvasElement) {\n      // Canvas element\n      if (element.style.display === 'none') return;\n      context.save();\n      const dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element, 0, 0);\n      context.restore();\n    } else {\n      if (element.style.display === 'none') return;\n      const rect = element.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      style = window.getComputedStyle(element); // Get the border of the element used for fill and border\n\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      const backgroundColor = style.backgroundColor;\n\n      if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      } // If all the borders match then stroke the round rectangle\n\n\n      const borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight'];\n      let match = true;\n      let prevBorder = null;\n\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match = style[border + 'Width'] === style[prevBorder + 'Width'] && style[border + 'Color'] === style[prevBorder + 'Color'] && style[border + 'Style'] === style[prevBorder + 'Style'];\n        }\n\n        if (match === false) break;\n        prevBorder = border;\n      }\n\n      if (match === true) {\n        // They all match so stroke the rectangle from before allows for border-radius\n        const width = parseFloat(style.borderTopWidth);\n\n        if (style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)') {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width;\n          context.stroke();\n        }\n      } else {\n        // Otherwise draw individual borders\n        drawBorder(style, 'borderTop', x, y, width, 0);\n        drawBorder(style, 'borderLeft', x, y, 0, height);\n        drawBorder(style, 'borderBottom', x, y + height, width, 0);\n        drawBorder(style, 'borderRight', x + width, y, 0, height);\n      }\n\n      if (element instanceof HTMLInputElement) {\n        let accentColor = style.accentColor;\n        if (accentColor === undefined || accentColor === 'auto') accentColor = style.color;\n        color.set(accentColor);\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2);\n        const accentTextColor = luminance < 0.5 ? 'white' : '#111111';\n\n        if (element.type === 'radio') {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = 'white';\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n\n          if (element.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n\n        if (element.type === 'checkbox') {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element.checked ? accentColor : 'white';\n          context.strokeStyle = element.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n\n          if (element.checked) {\n            const currentTextAlign = context.textAlign;\n            context.textAlign = 'center';\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + 'px',\n              fontWeight: 'bold'\n            };\n            drawText(properties, x + width / 2, y, '✔');\n            context.textAlign = currentTextAlign;\n          }\n        }\n\n        if (element.type === 'range') {\n          const [min, max, value] = ['min', 'max', 'value'].map(property => parseFloat(element[property]));\n          const position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n\n        if (element.type === 'color' || element.type === 'text' || element.type === 'number') {\n          clipper.add({\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element.value);\n          clipper.remove();\n        }\n      }\n    }\n    /*\n    // debug\n    context.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n    context.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n    */\n\n\n    const isClipping = style.overflow === 'auto' || style.overflow === 'hidden';\n    if (isClipping) clipper.add({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    });\n\n    for (let i = 0; i < element.childNodes.length; i++) {\n      drawElement(element.childNodes[i], style);\n    }\n\n    if (isClipping) clipper.remove();\n  }\n\n  const offset = element.getBoundingClientRect();\n  let canvas = canvases.get(element);\n\n  if (canvas === undefined) {\n    canvas = document.createElement('canvas');\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n\n  const context = canvas.getContext('2d'\n  /*, { alpha: false }*/\n  );\n  const clipper = new Clipper(context); // console.time( 'drawElement' );\n\n  drawElement(element); // console.timeEnd( 'drawElement' );\n\n  return canvas;\n}\n\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  const rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n\n  function traverse(element) {\n    if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {\n      const rect = element.getBoundingClientRect();\n\n      if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {\n        element.dispatchEvent(new MouseEvent(event, mouseEventInit));\n\n        if (element instanceof HTMLInputElement && element.type === 'range' && (event === 'mousedown' || event === 'click')) {\n          const [min, max] = ['min', 'max'].map(property => parseFloat(element[property]));\n          const width = rect.width;\n          const offsetX = x - rect.x;\n          const proportion = offsetX / width;\n          element.value = min + (max - min) * proportion;\n          element.dispatchEvent(new InputEvent('input', {\n            bubbles: true\n          }));\n        }\n      }\n\n      for (let i = 0; i < element.childNodes.length; i++) {\n        traverse(element.childNodes[i]);\n      }\n    }\n  }\n\n  traverse(element);\n}\n\nexport { HTMLMesh };\n"]},"metadata":{},"sourceType":"module"}
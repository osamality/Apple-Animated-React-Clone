{"ast":null,"code":"import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\nconst shaderStages = ['fragment', 'vertex'];\nconst vector = ['x', 'y', 'z', 'w'];\n\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\n\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n\n  addStack(node) {\n    /*\n    if ( this.stack.indexOf( node ) !== - 1 ) {\n    console.warn( 'Recursive node: ', node );\n    }\n    */\n    this.stack.push(node);\n  }\n\n  removeStack(node) {\n    const lastStack = this.stack.pop();\n\n    if (lastStack !== node) {\n      throw new Error('NodeBuilder: Invalid node stack!');\n    }\n  }\n\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n\n  addNode(node) {\n    if (this.nodes.indexOf(node) === -1) {\n      const updateType = node.getUpdateType(this);\n\n      if (updateType !== NodeUpdateType.None) {\n        this.updateNodes.push(node);\n      }\n\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n\n  getMethod(method) {\n    return method;\n  }\n\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n\n  setContext(context) {\n    this.context = context;\n  }\n\n  getContext() {\n    return this.context;\n  }\n\n  getTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getTextureBias() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTextureBias() {\n    console.warn('Abstract function.');\n  } // @TODO: rename to .generateConst()\n\n\n  getConst(type, value) {\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n\n    if (type === 'color') {\n      return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    }\n\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n\n    const getConst = value => this.getConst(componentType, value);\n\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\n    }\n\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n\n  getType(type) {\n    return type;\n  }\n\n  generateMethod(method) {\n    return method;\n  }\n\n  getAttribute(name, type) {\n    const attributes = this.attributes; // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    } // create a new if no exist\n\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n\n  getPropertyName(node\n  /*, shaderStage*/\n  ) {\n    return node.name;\n  }\n\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler';\n  }\n\n  isShaderStage(shaderStage) {\n    return this.shaderStage === shaderStage;\n  }\n\n  getTextureEncodingFromMap(map) {\n    let encoding;\n\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n\n    return encoding;\n  }\n\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture') return 'vec4';\n    return type;\n  }\n\n  getTypeFromLength(type) {\n    if (type === 1) return 'float';\n    if (type === 2) return 'vec2';\n    if (type === 3) return 'vec3';\n    if (type === 4) return 'vec4';\n    return 0;\n  }\n\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    return 0;\n  }\n\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n\n  getDataFromNode(node, shaderStage = this.shaderStage) {\n    let nodeData = this.nodesData.get(node);\n\n    if (nodeData === undefined) {\n      nodeData = {\n        vertex: {},\n        fragment: {}\n      };\n      this.nodesData.set(node, nodeData);\n    }\n\n    return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n  }\n\n  getUniformFromNode(node, shaderStage, type) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeUniform = nodeData.uniform;\n\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n\n    return nodeUniform;\n  }\n\n  getVarFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage];\n      const index = vars.length;\n      nodeVar = new NodeVar('nodeVar' + index, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n\n    return nodeVar;\n  }\n\n  getVaryFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node, null);\n    let nodeVary = nodeData.vary;\n\n    if (nodeVary === undefined) {\n      const varys = this.varys;\n      const index = varys.length;\n      nodeVary = new NodeVary('nodeVary' + index, type);\n      varys.push(nodeVary);\n      nodeData.vary = nodeVary;\n    }\n\n    return nodeVary;\n  }\n\n  getCodeFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage];\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n\n    return nodeCode;\n  }\n\n  addFlowCode(code) {\n    this.flow.code += code;\n  }\n\n  getFlowData(shaderStage, node) {\n    return this.flowsData.get(node);\n  }\n\n  flowNode(node) {\n    this.node = node;\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    this.node = null;\n    return flowData;\n  }\n\n  flowChildNode(node, output = null) {\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n\n  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n\n    if (propertyName !== null) {\n      flowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n    }\n\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n\n  getAttributes() {\n    console.warn('Abstract function.');\n  }\n\n  getVarys() {\n    console.warn('Abstract function.');\n  }\n\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n\n    for (let index = 0; index < vars.length; index++) {\n      const variable = vars[index];\n      snippet += `${variable.type} ${variable.name}; `;\n    }\n\n    return snippet;\n  }\n\n  getUniforms() {\n    console.warn('Abstract function.');\n  }\n\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n\n    for (const nodeCode of codes) {\n      code += nodeCode.code + '\\n';\n    }\n\n    return code;\n  }\n\n  getHash() {\n    return this.vertexShader + this.fragmentShader;\n  }\n\n  getShaderStage() {\n    return this.shaderStage;\n  }\n\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n\n  build() {\n    // stage 1: analyze nodes to possible optimization and validation\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        node.analyze(this);\n      }\n    } // stage 2: pre-build vertex code used in fragment shader\n\n\n    if (this.context.vertex && this.context.vertex.isNode) {\n      this.flowNodeFromShaderStage('vertex', this.context.vertex);\n    } // stage 3: generate shader\n\n\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        this.flowNode(node, shaderStage);\n      }\n    }\n\n    this.setShaderStage(null); // stage 4: build code for a specific output\n\n    this.buildCode();\n    return this;\n  }\n\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n\n    if (fromTypeLength === 0) {\n      // fromType is matrix-like\n      const vectorType = this.getVectorFromMatrix(fromType);\n      return this.format(`( ${snippet} * ${this.getType(vectorType)}( 1.0 ) )`, vectorType, toType);\n    }\n\n    if (toTypeLength === 0) {\n      // toType is matrix-like\n      // ignore for now\n      //return `${ this.getType( toType ) }( ${ snippet } )`;\n      return snippet;\n    }\n\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);\n    }\n\n    if (toTypeLength === 4) {\n      // toType is vec4-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n\n}\n\nexport default NodeBuilder;\nexport { shaderStages, vector };","map":{"version":3,"sources":["/Users/osamakhan/Desktop/Apple-Website-Clone-React-master/node_modules/three-stdlib/nodes/core/NodeBuilder.js"],"names":["NodeUniform","NodeAttribute","NodeVary","NodeVar","NodeCode","NodeKeywords","NodeUpdateType","REVISION","LinearEncoding","shaderStages","vector","toFloat","value","Number","NodeBuilder","constructor","object","renderer","parser","material","nodes","updateNodes","hashNodes","vertexShader","fragmentShader","flowNodes","vertex","fragment","flowCode","uniforms","index","codes","attributes","varys","vars","flow","code","stack","context","keywords","nodesData","WeakMap","flowsData","shaderStage","node","addStack","push","removeStack","lastStack","pop","Error","setHashNode","hash","addNode","indexOf","updateType","getUpdateType","None","getHash","getMethod","method","getNodeFromHash","addFlow","setContext","getContext","getTexture","console","warn","getTextureBias","getCubeTexture","getCubeTextureBias","getConst","type","Math","round","getType","r","g","b","typeLength","getTypeLength","componentType","getComponentType","x","y","z","w","generateMethod","getAttribute","name","attribute","getPropertyName","isVector","test","isMatrix","isReference","isShaderStage","getTextureEncodingFromMap","map","encoding","isTexture","isWebGLRenderTarget","texture","getVectorType","exec","getTypeFromLength","vecType","vecNum","getVectorFromMatrix","replace","getDataFromNode","nodeData","get","undefined","set","getUniformFromNode","nodeUniform","uniform","getVarFromNode","nodeVar","variable","length","getVaryFromNode","nodeVary","vary","getCodeFromNode","nodeCode","addFlowCode","getFlowData","flowNode","output","getNodeType","flowData","flowChildNode","previousFlow","result","build","flowNodeFromShaderStage","propertyName","previousShaderStage","setShaderStage","getAttributes","getVarys","getVars","snippet","getUniforms","getCodes","getShaderStage","buildCode","analyze","isNode","format","fromType","toType","fromTypeLength","toTypeLength","vectorType","slice","getSignature"],"mappings":"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","sourcesContent":["import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\n\nconst shaderStages = ['fragment', 'vertex'];\nconst vector = ['x', 'y', 'z', 'w'];\n\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\n\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n\n  addStack(node) {\n    /*\n    if ( this.stack.indexOf( node ) !== - 1 ) {\n    console.warn( 'Recursive node: ', node );\n    }\n    */\n    this.stack.push(node);\n  }\n\n  removeStack(node) {\n    const lastStack = this.stack.pop();\n\n    if (lastStack !== node) {\n      throw new Error('NodeBuilder: Invalid node stack!');\n    }\n  }\n\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n\n  addNode(node) {\n    if (this.nodes.indexOf(node) === -1) {\n      const updateType = node.getUpdateType(this);\n\n      if (updateType !== NodeUpdateType.None) {\n        this.updateNodes.push(node);\n      }\n\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n\n  getMethod(method) {\n    return method;\n  }\n\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n\n  setContext(context) {\n    this.context = context;\n  }\n\n  getContext() {\n    return this.context;\n  }\n\n  getTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getTextureBias() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTextureBias() {\n    console.warn('Abstract function.');\n  } // @TODO: rename to .generateConst()\n\n\n  getConst(type, value) {\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n\n    if (type === 'color') {\n      return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    }\n\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n\n    const getConst = value => this.getConst(componentType, value);\n\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\n    }\n\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n\n  getType(type) {\n    return type;\n  }\n\n  generateMethod(method) {\n    return method;\n  }\n\n  getAttribute(name, type) {\n    const attributes = this.attributes; // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    } // create a new if no exist\n\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n\n  getPropertyName(node\n  /*, shaderStage*/\n  ) {\n    return node.name;\n  }\n\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler';\n  }\n\n  isShaderStage(shaderStage) {\n    return this.shaderStage === shaderStage;\n  }\n\n  getTextureEncodingFromMap(map) {\n    let encoding;\n\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n\n    return encoding;\n  }\n\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture') return 'vec4';\n    return type;\n  }\n\n  getTypeFromLength(type) {\n    if (type === 1) return 'float';\n    if (type === 2) return 'vec2';\n    if (type === 3) return 'vec3';\n    if (type === 4) return 'vec4';\n    return 0;\n  }\n\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    return 0;\n  }\n\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n\n  getDataFromNode(node, shaderStage = this.shaderStage) {\n    let nodeData = this.nodesData.get(node);\n\n    if (nodeData === undefined) {\n      nodeData = {\n        vertex: {},\n        fragment: {}\n      };\n      this.nodesData.set(node, nodeData);\n    }\n\n    return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n  }\n\n  getUniformFromNode(node, shaderStage, type) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeUniform = nodeData.uniform;\n\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n\n    return nodeUniform;\n  }\n\n  getVarFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage];\n      const index = vars.length;\n      nodeVar = new NodeVar('nodeVar' + index, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n\n    return nodeVar;\n  }\n\n  getVaryFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node, null);\n    let nodeVary = nodeData.vary;\n\n    if (nodeVary === undefined) {\n      const varys = this.varys;\n      const index = varys.length;\n      nodeVary = new NodeVary('nodeVary' + index, type);\n      varys.push(nodeVary);\n      nodeData.vary = nodeVary;\n    }\n\n    return nodeVary;\n  }\n\n  getCodeFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage];\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n\n    return nodeCode;\n  }\n\n  addFlowCode(code) {\n    this.flow.code += code;\n  }\n\n  getFlowData(shaderStage, node) {\n    return this.flowsData.get(node);\n  }\n\n  flowNode(node) {\n    this.node = node;\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    this.node = null;\n    return flowData;\n  }\n\n  flowChildNode(node, output = null) {\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n\n  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n\n    if (propertyName !== null) {\n      flowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n    }\n\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n\n  getAttributes() {\n    console.warn('Abstract function.');\n  }\n\n  getVarys() {\n    console.warn('Abstract function.');\n  }\n\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n\n    for (let index = 0; index < vars.length; index++) {\n      const variable = vars[index];\n      snippet += `${variable.type} ${variable.name}; `;\n    }\n\n    return snippet;\n  }\n\n  getUniforms() {\n    console.warn('Abstract function.');\n  }\n\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n\n    for (const nodeCode of codes) {\n      code += nodeCode.code + '\\n';\n    }\n\n    return code;\n  }\n\n  getHash() {\n    return this.vertexShader + this.fragmentShader;\n  }\n\n  getShaderStage() {\n    return this.shaderStage;\n  }\n\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n\n  build() {\n    // stage 1: analyze nodes to possible optimization and validation\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        node.analyze(this);\n      }\n    } // stage 2: pre-build vertex code used in fragment shader\n\n\n    if (this.context.vertex && this.context.vertex.isNode) {\n      this.flowNodeFromShaderStage('vertex', this.context.vertex);\n    } // stage 3: generate shader\n\n\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        this.flowNode(node, shaderStage);\n      }\n    }\n\n    this.setShaderStage(null); // stage 4: build code for a specific output\n\n    this.buildCode();\n    return this;\n  }\n\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n\n    if (fromTypeLength === 0) {\n      // fromType is matrix-like\n      const vectorType = this.getVectorFromMatrix(fromType);\n      return this.format(`( ${snippet} * ${this.getType(vectorType)}( 1.0 ) )`, vectorType, toType);\n    }\n\n    if (toTypeLength === 0) {\n      // toType is matrix-like\n      // ignore for now\n      //return `${ this.getType( toType ) }( ${ snippet } )`;\n      return snippet;\n    }\n\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);\n    }\n\n    if (toTypeLength === 4) {\n      // toType is vec4-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n\n}\n\nexport default NodeBuilder;\nexport { shaderStages, vector };\n"]},"metadata":{},"sourceType":"module"}
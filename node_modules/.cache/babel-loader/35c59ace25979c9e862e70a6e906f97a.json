{"ast":null,"code":"import { Vector2, MeshNormalMaterial, ShaderMaterial, Vector4, WebGLRenderTarget, DepthTexture, NearestFilter, RGBAFormat } from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\n\nclass RenderPixelatedPass extends Pass {\n  constructor(resolution, pixelSize, scene, camera, options = {}) {\n    var _options$normalEdgeSt, _options$depthEdgeStr;\n\n    super();\n    this.pixelSize = pixelSize;\n    this.resolution = new Vector2();\n    this.renderResolution = new Vector2();\n    this.setSize(resolution.x, resolution.y);\n    this.fsQuad = new FullScreenQuad(this.material());\n    this.scene = scene;\n    this.camera = camera;\n    this.normalEdgeStrength = (_options$normalEdgeSt = options.normalEdgeStrength) != null ? _options$normalEdgeSt : 0.3;\n    this.depthEdgeStrength = (_options$depthEdgeStr = options.depthEdgeStrength) != null ? _options$depthEdgeStr : 0.4;\n    this.rgbRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, true);\n    this.normalRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, false);\n    this.normalMaterial = new MeshNormalMaterial();\n  }\n\n  dispose() {\n    this.rgbRenderTarget.dispose();\n    this.normalRenderTarget.dispose();\n    this.fsQuad.dispose();\n  }\n\n  setSize(width, height) {\n    var _this$rgbRenderTarget, _this$normalRenderTar, _this$fsQuad;\n\n    this.resolution.set(width, height);\n    this.renderResolution.set(width / this.pixelSize | 0, height / this.pixelSize | 0);\n    const {\n      x,\n      y\n    } = this.renderResolution;\n    (_this$rgbRenderTarget = this.rgbRenderTarget) === null || _this$rgbRenderTarget === void 0 ? void 0 : _this$rgbRenderTarget.setSize(x, y);\n    (_this$normalRenderTar = this.normalRenderTarget) === null || _this$normalRenderTar === void 0 ? void 0 : _this$normalRenderTar.setSize(x, y);\n    (_this$fsQuad = this.fsQuad) === null || _this$fsQuad === void 0 ? void 0 : _this$fsQuad.material.uniforms.resolution.value.set(x, y, 1 / x, 1 / y);\n  }\n\n  setPixelSize(pixelSize) {\n    this.pixelSize = pixelSize;\n    this.setSize(this.resolution.x, this.resolution.y);\n  }\n\n  render(renderer, writeBuffer) {\n    const uniforms = this.fsQuad.material.uniforms;\n    uniforms.normalEdgeStrength.value = this.normalEdgeStrength;\n    uniforms.depthEdgeStrength.value = this.depthEdgeStrength;\n    renderer.setRenderTarget(this.rgbRenderTarget);\n    renderer.render(this.scene, this.camera);\n    const overrideMaterial_old = this.scene.overrideMaterial;\n    renderer.setRenderTarget(this.normalRenderTarget);\n    this.scene.overrideMaterial = this.normalMaterial;\n    renderer.render(this.scene, this.camera);\n    this.scene.overrideMaterial = overrideMaterial_old;\n    uniforms.tDiffuse.value = this.rgbRenderTarget.texture;\n    uniforms.tDepth.value = this.rgbRenderTarget.depthTexture;\n    uniforms.tNormal.value = this.normalRenderTarget.texture;\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n    }\n\n    this.fsQuad.render(renderer);\n  }\n\n  material() {\n    return new ShaderMaterial({\n      uniforms: {\n        tDiffuse: {\n          value: null\n        },\n        tDepth: {\n          value: null\n        },\n        tNormal: {\n          value: null\n        },\n        resolution: {\n          value: new Vector4(this.renderResolution.x, this.renderResolution.y, 1 / this.renderResolution.x, 1 / this.renderResolution.y)\n        },\n        normalEdgeStrength: {\n          value: 0\n        },\n        depthEdgeStrength: {\n          value: 0\n        }\n      },\n      vertexShader: `\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t\t`,\n      fragmentShader: `\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tuniform sampler2D tDepth;\n\t\t\t\tuniform sampler2D tNormal;\n\t\t\t\tuniform vec4 resolution;\n\t\t\t\tuniform float normalEdgeStrength;\n\t\t\t\tuniform float depthEdgeStrength;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tfloat getDepth(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getNormal(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tfloat depthEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat diff = 0.0;\n\t\t\t\t\tdiff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);\n\t\t\t\t\treturn floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;\n\n\t\t\t\t}\n\n\t\t\t\tfloat neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {\n\n\t\t\t\t\tfloat depthDiff = getDepth(x, y) - depth;\n\t\t\t\t\tvec3 neighborNormal = getNormal(x, y);\n\t\t\t\t\t\n\t\t\t\t\t// Edge pixels should yield to faces who's normals are closer to the bias normal.\n\t\t\t\t\tvec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.\n\t\t\t\t\tfloat normalDiff = dot(normal - neighborNormal, normalEdgeBias);\n\t\t\t\t\tfloat normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);\n\t\t\t\t\t\n\t\t\t\t\t// Only the shallower pixel should detect the normal edge.\n\t\t\t\t\tfloat depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);\n\n\t\t\t\t\treturn (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;\n\n\t\t\t\t}\n\n\t\t\t\tfloat normalEdgeIndicator(float depth, vec3 normal) {\n\t\t\t\t\t\n\t\t\t\t\tfloat indicator = 0.0;\n\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, -1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, 1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(1, 0, depth, normal);\n\n\t\t\t\t\treturn step(0.1, indicator);\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\t\t\tfloat depth = 0.0;\n\t\t\t\t\tvec3 normal = vec3(0.0);\n\n\t\t\t\t\tif (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {\n\n\t\t\t\t\t\tdepth = getDepth(0, 0);\n\t\t\t\t\t\tnormal = getNormal(0, 0);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat dei = 0.0;\n\t\t\t\t\tif (depthEdgeStrength > 0.0) \n\t\t\t\t\t\tdei = depthEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat nei = 0.0; \n\t\t\t\t\tif (normalEdgeStrength > 0.0) \n\t\t\t\t\t\tnei = normalEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);\n\n\t\t\t\t\tgl_FragColor = texel * Strength;\n\n\t\t\t\t}\n\t\t\t\t`\n    });\n  }\n\n}\n\nfunction pixelRenderTarget(resolution, pixelFormat, useDepthTexture) {\n  const renderTarget = new WebGLRenderTarget(resolution.x, resolution.y, !useDepthTexture ? undefined : {\n    depthTexture: new DepthTexture(resolution.x, resolution.y),\n    depthBuffer: true\n  });\n  renderTarget.texture.format = pixelFormat;\n  renderTarget.texture.minFilter = NearestFilter;\n  renderTarget.texture.magFilter = NearestFilter;\n  renderTarget.texture.generateMipmaps = false;\n  renderTarget.stencilBuffer = false;\n  return renderTarget;\n}\n\nexport { RenderPixelatedPass };","map":{"version":3,"sources":["/Users/osamakhan/Desktop/Apple-Website-Clone-React-master/node_modules/three-stdlib/postprocessing/RenderPixelatedPass.js"],"names":["Vector2","MeshNormalMaterial","ShaderMaterial","Vector4","WebGLRenderTarget","DepthTexture","NearestFilter","RGBAFormat","Pass","FullScreenQuad","RenderPixelatedPass","constructor","resolution","pixelSize","scene","camera","options","_options$normalEdgeSt","_options$depthEdgeStr","renderResolution","setSize","x","y","fsQuad","material","normalEdgeStrength","depthEdgeStrength","rgbRenderTarget","pixelRenderTarget","normalRenderTarget","normalMaterial","dispose","width","height","_this$rgbRenderTarget","_this$normalRenderTar","_this$fsQuad","set","uniforms","value","setPixelSize","render","renderer","writeBuffer","setRenderTarget","overrideMaterial_old","overrideMaterial","tDiffuse","texture","tDepth","depthTexture","tNormal","renderToScreen","clear","vertexShader","fragmentShader","pixelFormat","useDepthTexture","renderTarget","undefined","depthBuffer","format","minFilter","magFilter","generateMipmaps","stencilBuffer"],"mappings":"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AAsBG,CAArH;AADG,SAVJ;AAaRG,QAAAA,kBAAkB,EAAE;AAClBc,UAAAA,KAAK,EAAE;AADW,SAbZ;AAgBRb,QAAAA,iBAAiB,EAAE;AACjBa,UAAAA,KAAK,EAAE;AADU;AAhBX,OADc;AAqBxBe,MAAAA,YAAY,EAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KA9B8B;AA+BxBC,MAAAA,cAAc,EAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxH8B,KAAnB,CAAP;AA0HD;;AAhMoC;;AAoMvC,SAAS3B,iBAAT,CAA2BhB,UAA3B,EAAuC4C,WAAvC,EAAoDC,eAApD,EAAqE;AACnE,QAAMC,YAAY,GAAG,IAAItD,iBAAJ,CAAsBQ,UAAU,CAACS,CAAjC,EAAoCT,UAAU,CAACU,CAA/C,EAAkD,CAACmC,eAAD,GAAmBE,SAAnB,GAA+B;AACpGT,IAAAA,YAAY,EAAE,IAAI7C,YAAJ,CAAiBO,UAAU,CAACS,CAA5B,EAA+BT,UAAU,CAACU,CAA1C,CADsF;AAEpGsC,IAAAA,WAAW,EAAE;AAFuF,GAAjF,CAArB;AAIAF,EAAAA,YAAY,CAACV,OAAb,CAAqBa,MAArB,GAA8BL,WAA9B;AACAE,EAAAA,YAAY,CAACV,OAAb,CAAqBc,SAArB,GAAiCxD,aAAjC;AACAoD,EAAAA,YAAY,CAACV,OAAb,CAAqBe,SAArB,GAAiCzD,aAAjC;AACAoD,EAAAA,YAAY,CAACV,OAAb,CAAqBgB,eAArB,GAAuC,KAAvC;AACAN,EAAAA,YAAY,CAACO,aAAb,GAA6B,KAA7B;AACA,SAAOP,YAAP;AACD;;AAED,SAAShD,mBAAT","sourcesContent":["import { Vector2, MeshNormalMaterial, ShaderMaterial, Vector4, WebGLRenderTarget, DepthTexture, NearestFilter, RGBAFormat } from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\n\nclass RenderPixelatedPass extends Pass {\n  constructor(resolution, pixelSize, scene, camera, options = {}) {\n    var _options$normalEdgeSt, _options$depthEdgeStr;\n\n    super();\n    this.pixelSize = pixelSize;\n    this.resolution = new Vector2();\n    this.renderResolution = new Vector2();\n    this.setSize(resolution.x, resolution.y);\n    this.fsQuad = new FullScreenQuad(this.material());\n    this.scene = scene;\n    this.camera = camera;\n    this.normalEdgeStrength = (_options$normalEdgeSt = options.normalEdgeStrength) != null ? _options$normalEdgeSt : 0.3;\n    this.depthEdgeStrength = (_options$depthEdgeStr = options.depthEdgeStrength) != null ? _options$depthEdgeStr : 0.4;\n    this.rgbRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, true);\n    this.normalRenderTarget = pixelRenderTarget(this.renderResolution, RGBAFormat, false);\n    this.normalMaterial = new MeshNormalMaterial();\n  }\n\n  dispose() {\n    this.rgbRenderTarget.dispose();\n    this.normalRenderTarget.dispose();\n    this.fsQuad.dispose();\n  }\n\n  setSize(width, height) {\n    var _this$rgbRenderTarget, _this$normalRenderTar, _this$fsQuad;\n\n    this.resolution.set(width, height);\n    this.renderResolution.set(width / this.pixelSize | 0, height / this.pixelSize | 0);\n    const {\n      x,\n      y\n    } = this.renderResolution;\n    (_this$rgbRenderTarget = this.rgbRenderTarget) === null || _this$rgbRenderTarget === void 0 ? void 0 : _this$rgbRenderTarget.setSize(x, y);\n    (_this$normalRenderTar = this.normalRenderTarget) === null || _this$normalRenderTar === void 0 ? void 0 : _this$normalRenderTar.setSize(x, y);\n    (_this$fsQuad = this.fsQuad) === null || _this$fsQuad === void 0 ? void 0 : _this$fsQuad.material.uniforms.resolution.value.set(x, y, 1 / x, 1 / y);\n  }\n\n  setPixelSize(pixelSize) {\n    this.pixelSize = pixelSize;\n    this.setSize(this.resolution.x, this.resolution.y);\n  }\n\n  render(renderer, writeBuffer) {\n    const uniforms = this.fsQuad.material.uniforms;\n    uniforms.normalEdgeStrength.value = this.normalEdgeStrength;\n    uniforms.depthEdgeStrength.value = this.depthEdgeStrength;\n    renderer.setRenderTarget(this.rgbRenderTarget);\n    renderer.render(this.scene, this.camera);\n    const overrideMaterial_old = this.scene.overrideMaterial;\n    renderer.setRenderTarget(this.normalRenderTarget);\n    this.scene.overrideMaterial = this.normalMaterial;\n    renderer.render(this.scene, this.camera);\n    this.scene.overrideMaterial = overrideMaterial_old;\n    uniforms.tDiffuse.value = this.rgbRenderTarget.texture;\n    uniforms.tDepth.value = this.rgbRenderTarget.depthTexture;\n    uniforms.tNormal.value = this.normalRenderTarget.texture;\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n    }\n\n    this.fsQuad.render(renderer);\n  }\n\n  material() {\n    return new ShaderMaterial({\n      uniforms: {\n        tDiffuse: {\n          value: null\n        },\n        tDepth: {\n          value: null\n        },\n        tNormal: {\n          value: null\n        },\n        resolution: {\n          value: new Vector4(this.renderResolution.x, this.renderResolution.y, 1 / this.renderResolution.x, 1 / this.renderResolution.y)\n        },\n        normalEdgeStrength: {\n          value: 0\n        },\n        depthEdgeStrength: {\n          value: 0\n        }\n      },\n      vertexShader: `\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t\t`,\n      fragmentShader: `\n\t\t\t\tuniform sampler2D tDiffuse;\n\t\t\t\tuniform sampler2D tDepth;\n\t\t\t\tuniform sampler2D tNormal;\n\t\t\t\tuniform vec4 resolution;\n\t\t\t\tuniform float normalEdgeStrength;\n\t\t\t\tuniform float depthEdgeStrength;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tfloat getDepth(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getNormal(int x, int y) {\n\n\t\t\t\t\treturn texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tfloat depthEdgeIndicator(float depth, vec3 normal) {\n\n\t\t\t\t\tfloat diff = 0.0;\n\t\t\t\t\tdiff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);\n\t\t\t\t\tdiff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);\n\t\t\t\t\treturn floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;\n\n\t\t\t\t}\n\n\t\t\t\tfloat neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {\n\n\t\t\t\t\tfloat depthDiff = getDepth(x, y) - depth;\n\t\t\t\t\tvec3 neighborNormal = getNormal(x, y);\n\t\t\t\t\t\n\t\t\t\t\t// Edge pixels should yield to faces who's normals are closer to the bias normal.\n\t\t\t\t\tvec3 normalEdgeBias = vec3(1., 1., 1.); // This should probably be a parameter.\n\t\t\t\t\tfloat normalDiff = dot(normal - neighborNormal, normalEdgeBias);\n\t\t\t\t\tfloat normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);\n\t\t\t\t\t\n\t\t\t\t\t// Only the shallower pixel should detect the normal edge.\n\t\t\t\t\tfloat depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);\n\n\t\t\t\t\treturn (1.0 - dot(normal, neighborNormal)) * depthIndicator * normalIndicator;\n\n\t\t\t\t}\n\n\t\t\t\tfloat normalEdgeIndicator(float depth, vec3 normal) {\n\t\t\t\t\t\n\t\t\t\t\tfloat indicator = 0.0;\n\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, -1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(0, 1, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);\n\t\t\t\t\tindicator += neighborNormalEdgeIndicator(1, 0, depth, normal);\n\n\t\t\t\t\treturn step(0.1, indicator);\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\t\t\tfloat depth = 0.0;\n\t\t\t\t\tvec3 normal = vec3(0.0);\n\n\t\t\t\t\tif (depthEdgeStrength > 0.0 || normalEdgeStrength > 0.0) {\n\n\t\t\t\t\t\tdepth = getDepth(0, 0);\n\t\t\t\t\t\tnormal = getNormal(0, 0);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat dei = 0.0;\n\t\t\t\t\tif (depthEdgeStrength > 0.0) \n\t\t\t\t\t\tdei = depthEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat nei = 0.0; \n\t\t\t\t\tif (normalEdgeStrength > 0.0) \n\t\t\t\t\t\tnei = normalEdgeIndicator(depth, normal);\n\n\t\t\t\t\tfloat Strength = dei > 0.0 ? (1.0 - depthEdgeStrength * dei) : (1.0 + normalEdgeStrength * nei);\n\n\t\t\t\t\tgl_FragColor = texel * Strength;\n\n\t\t\t\t}\n\t\t\t\t`\n    });\n  }\n\n}\n\nfunction pixelRenderTarget(resolution, pixelFormat, useDepthTexture) {\n  const renderTarget = new WebGLRenderTarget(resolution.x, resolution.y, !useDepthTexture ? undefined : {\n    depthTexture: new DepthTexture(resolution.x, resolution.y),\n    depthBuffer: true\n  });\n  renderTarget.texture.format = pixelFormat;\n  renderTarget.texture.minFilter = NearestFilter;\n  renderTarget.texture.magFilter = NearestFilter;\n  renderTarget.texture.generateMipmaps = false;\n  renderTarget.stencilBuffer = false;\n  return renderTarget;\n}\n\nexport { RenderPixelatedPass };\n"]},"metadata":{},"sourceType":"module"}
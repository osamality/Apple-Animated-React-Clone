{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { DiscardMaterial } from '../materials/DiscardMaterial.js';\n\nfunction isLight(object) {\n  return object.isLight;\n}\n\nfunction isGeometry(object) {\n  return !!object.geometry;\n}\n\nconst accumulativeContext = /*#__PURE__*/React.createContext(null);\nconst SoftShadowMaterial = shaderMaterial({\n  color: new THREE.Color(),\n  blend: 2.0,\n  alphaTest: 0.75,\n  opacity: 0,\n  map: null\n}, `varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vUv = uv;\n   }`, `varying vec2 vUv;\n   uniform sampler2D map;\n   uniform vec3 color;\n   uniform float opacity;\n   uniform float alphaTest;\n   uniform float blend;\n   void main() {\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\n     #include <tonemapping_fragment>\n     #include <encodings_fragment>\n   }`);\nconst AccumulativeShadows = /*#__PURE__*/React.forwardRef(({\n  children,\n  temporal,\n  frames = 40,\n  limit = Infinity,\n  blend = 20,\n  scale = 10,\n  opacity = 1,\n  alphaTest = 0.75,\n  color = 'black',\n  colorBlend = 2,\n  resolution = 1024,\n  toneMapped = true,\n  ...props\n}, forwardRef) => {\n  extend({\n    SoftShadowMaterial\n  });\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configure(gPlane.current);\n  }, []);\n  const api = React.useMemo(() => ({\n    lights: new Map(),\n    temporal: !!temporal,\n    frames: Math.max(2, frames),\n    blend: Math.max(2, frames === Infinity ? blend : frames),\n    count: 0,\n    getMesh: () => gPlane.current,\n    reset: () => {\n      // Clear buffers, reset opacities, set frame count to 0\n      plm.clear();\n      const material = gPlane.current.material;\n      material.opacity = 0;\n      material.alphaTest = 0;\n      api.count = 0;\n    },\n    update: (frames = 1) => {\n      // Adapt the opacity-blend ratio to the number of frames\n      const material = gPlane.current.material;\n\n      if (!api.temporal) {\n        material.opacity = opacity;\n        material.alphaTest = alphaTest;\n      } else {\n        material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n        material.alphaTest = Math.min(alphaTest, material.alphaTest + alphaTest / api.blend);\n      } // Switch accumulative lights on\n\n\n      gLights.current.visible = true; // Collect scene lights and meshes\n\n      plm.prepare(); // Update the lightmap and the accumulative lights\n\n      for (let i = 0; i < frames; i++) {\n        api.lights.forEach(light => light.update());\n        plm.update(camera, api.blend);\n      } // Switch lights off\n\n\n      gLights.current.visible = false; // Restore lights and meshes\n\n      plm.finish();\n    }\n  }), [plm, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(() => {\n    // Reset internals, buffers, ...\n    api.reset(); // Update lightmap\n\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  }); // Expose api, allow children to set itself as the main light source\n\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  useFrame(() => {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"softShadowMaterial\", {\n    transparent: true,\n    depthWrite: false,\n    toneMapped: toneMapped,\n    color: color,\n    blend: colorBlend,\n    map: plm.progressiveLightMap2.texture\n  })));\n});\nconst RandomizedLight = /*#__PURE__*/React.forwardRef(({\n  castShadow = true,\n  bias = 0.001,\n  mapSize = 512,\n  size = 5,\n  near = 0.5,\n  far = 500,\n  frames = 1,\n  position = [0, 0, 0],\n  radius = 1,\n  amount = 8,\n  intensity = 1,\n  ambient = 0.5,\n  ...props\n}, forwardRef) => {\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length, ...position]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    const group = gLights.current;\n    if (parent) parent.lights.set(group.uuid, api);\n    return () => void parent.lights.delete(group.uuid);\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n}); // Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\n\nclass ProgressiveLightMap {\n  constructor(renderer, scene, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null;\n    this.clearColor = new THREE.Color();\n    this.clearAlpha = 0; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format,\n      encoding: renderer.outputEncoding\n    });\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format,\n      encoding: renderer.outputEncoding\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.discardMat = new DiscardMaterial();\n    this.targetMat = new THREE.MeshLambertMaterial({\n      fog: false\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n\n    this.targetMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + 'uniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\n      }`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = this.previousShadowMap;\n      shader.uniforms.averagingWindow = this.averagingWindow;\n    };\n  }\n\n  clear() {\n    this.renderer.getClearColor(this.clearColor);\n    this.clearAlpha = this.renderer.getClearAlpha();\n    this.renderer.setClearColor('black', 1);\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(null);\n    this.renderer.setClearColor(this.clearColor, this.clearAlpha);\n    this.lights = [];\n    this.meshes = [];\n    this.scene.traverse(object => {\n      if (isGeometry(object)) {\n        this.meshes.push({\n          object,\n          material: object.material\n        });\n      } else if (isLight(object)) {\n        this.lights.push({\n          object,\n          intensity: object.intensity\n        });\n      }\n    });\n  }\n\n  prepare() {\n    this.lights.forEach(light => light.object.intensity = 0);\n    this.meshes.forEach(mesh => mesh.object.material = this.discardMat);\n  }\n\n  finish() {\n    this.lights.forEach(light => light.object.intensity = light.intensity);\n    this.meshes.forEach(mesh => mesh.object.material = mesh.material);\n  }\n\n  configure(object) {\n    this.object = object;\n  }\n\n  update(camera, blendWindow = 100) {\n    if (!this.object) return; // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n    this.averagingWindow.value = blendWindow;\n    this.object.material = this.targetMat; // Ping-pong two surface buffers for reading/writing\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    const oldBg = this.scene.background;\n    this.scene.background = null;\n    this.renderer.setRenderTarget(activeMap);\n    this.previousShadowMap.value = inactiveMap.texture;\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.renderer.setRenderTarget(null);\n    this.scene.background = oldBg;\n  }\n\n}\n\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };","map":{"version":3,"sources":["/Users/osamakhan/Desktop/dev/Apple-Animated-React-Clone/node_modules/@react-three/drei/core/AccumulativeShadows.js"],"names":["_extends","THREE","React","extend","useThree","useFrame","shaderMaterial","DiscardMaterial","isLight","object","isGeometry","geometry","accumulativeContext","createContext","SoftShadowMaterial","color","Color","blend","alphaTest","opacity","map","AccumulativeShadows","forwardRef","children","temporal","frames","limit","Infinity","scale","colorBlend","resolution","toneMapped","props","gl","state","scene","camera","gPlane","useRef","gLights","plm","useState","ProgressiveLightMap","useLayoutEffect","configure","current","api","useMemo","lights","Map","Math","max","count","getMesh","reset","clear","material","update","min","visible","prepare","i","forEach","light","finish","useImperativeHandle","createElement","traverse","ref","Provider","value","receiveShadow","rotation","PI","transparent","depthWrite","progressiveLightMap2","texture","RandomizedLight","castShadow","bias","mapSize","size","near","far","position","radius","amount","intensity","ambient","length","Vector3","parent","useContext","useCallback","l","random","set","MathUtils","randFloatSpread","lambda","acos","phi","cos","abs","sin","group","uuid","delete","Array","from","_","index","key","attach","args","constructor","renderer","res","buffer1Active","meshes","clearColor","clearAlpha","format","test","navigator","userAgent","HalfFloatType","FloatType","progressiveLightMap1","WebGLRenderTarget","type","encoding","outputEncoding","discardMat","targetMat","MeshLambertMaterial","fog","previousShadowMap","averagingWindow","onBeforeCompile","shader","vertexShader","slice","bodyStart","fragmentShader","indexOf","uniforms","getClearColor","getClearAlpha","setClearColor","setRenderTarget","push","mesh","blendWindow","activeMap","inactiveMap","oldBg","background","render"],"mappings":"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","sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { DiscardMaterial } from '../materials/DiscardMaterial.js';\n\nfunction isLight(object) {\n  return object.isLight;\n}\n\nfunction isGeometry(object) {\n  return !!object.geometry;\n}\n\nconst accumulativeContext = /*#__PURE__*/React.createContext(null);\nconst SoftShadowMaterial = shaderMaterial({\n  color: new THREE.Color(),\n  blend: 2.0,\n  alphaTest: 0.75,\n  opacity: 0,\n  map: null\n}, `varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vUv = uv;\n   }`, `varying vec2 vUv;\n   uniform sampler2D map;\n   uniform vec3 color;\n   uniform float opacity;\n   uniform float alphaTest;\n   uniform float blend;\n   void main() {\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\n     #include <tonemapping_fragment>\n     #include <encodings_fragment>\n   }`);\nconst AccumulativeShadows = /*#__PURE__*/React.forwardRef(({\n  children,\n  temporal,\n  frames = 40,\n  limit = Infinity,\n  blend = 20,\n  scale = 10,\n  opacity = 1,\n  alphaTest = 0.75,\n  color = 'black',\n  colorBlend = 2,\n  resolution = 1024,\n  toneMapped = true,\n  ...props\n}, forwardRef) => {\n  extend({\n    SoftShadowMaterial\n  });\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const camera = useThree(state => state.camera);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configure(gPlane.current);\n  }, []);\n  const api = React.useMemo(() => ({\n    lights: new Map(),\n    temporal: !!temporal,\n    frames: Math.max(2, frames),\n    blend: Math.max(2, frames === Infinity ? blend : frames),\n    count: 0,\n    getMesh: () => gPlane.current,\n    reset: () => {\n      // Clear buffers, reset opacities, set frame count to 0\n      plm.clear();\n      const material = gPlane.current.material;\n      material.opacity = 0;\n      material.alphaTest = 0;\n      api.count = 0;\n    },\n    update: (frames = 1) => {\n      // Adapt the opacity-blend ratio to the number of frames\n      const material = gPlane.current.material;\n\n      if (!api.temporal) {\n        material.opacity = opacity;\n        material.alphaTest = alphaTest;\n      } else {\n        material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n        material.alphaTest = Math.min(alphaTest, material.alphaTest + alphaTest / api.blend);\n      } // Switch accumulative lights on\n\n\n      gLights.current.visible = true; // Collect scene lights and meshes\n\n      plm.prepare(); // Update the lightmap and the accumulative lights\n\n      for (let i = 0; i < frames; i++) {\n        api.lights.forEach(light => light.update());\n        plm.update(camera, api.blend);\n      } // Switch lights off\n\n\n      gLights.current.visible = false; // Restore lights and meshes\n\n      plm.finish();\n    }\n  }), [plm, camera, scene, temporal, frames, blend, opacity, alphaTest]);\n  React.useLayoutEffect(() => {\n    // Reset internals, buffers, ...\n    api.reset(); // Update lightmap\n\n    if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n  }); // Expose api, allow children to set itself as the main light source\n\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  useFrame(() => {\n    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n      api.update();\n      api.count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"softShadowMaterial\", {\n    transparent: true,\n    depthWrite: false,\n    toneMapped: toneMapped,\n    color: color,\n    blend: colorBlend,\n    map: plm.progressiveLightMap2.texture\n  })));\n});\nconst RandomizedLight = /*#__PURE__*/React.forwardRef(({\n  castShadow = true,\n  bias = 0.001,\n  mapSize = 512,\n  size = 5,\n  near = 0.5,\n  far = 500,\n  frames = 1,\n  position = [0, 0, 0],\n  radius = 1,\n  amount = 8,\n  intensity = 1,\n  ambient = 0.5,\n  ...props\n}, forwardRef) => {\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [radius, ambient, length, ...position]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    const group = gLights.current;\n    if (parent) parent.lights.set(group.uuid, api);\n    return () => void parent.lights.delete(group.uuid);\n  }, [parent, api]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n}); // Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\n\nclass ProgressiveLightMap {\n  constructor(renderer, scene, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.buffer1Active = false;\n    this.lights = [];\n    this.meshes = [];\n    this.object = null;\n    this.clearColor = new THREE.Color();\n    this.clearAlpha = 0; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format,\n      encoding: renderer.outputEncoding\n    });\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format,\n      encoding: renderer.outputEncoding\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.discardMat = new DiscardMaterial();\n    this.targetMat = new THREE.MeshLambertMaterial({\n      fog: false\n    });\n    this.previousShadowMap = {\n      value: this.progressiveLightMap1.texture\n    };\n    this.averagingWindow = {\n      value: 100\n    };\n\n    this.targetMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = 'varying vec2 vUv;\\n' + shader.vertexShader.slice(0, -1) + 'vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv;\\n' + shader.fragmentShader.slice(0, bodyStart) + 'uniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\n      }`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = this.previousShadowMap;\n      shader.uniforms.averagingWindow = this.averagingWindow;\n    };\n  }\n\n  clear() {\n    this.renderer.getClearColor(this.clearColor);\n    this.clearAlpha = this.renderer.getClearAlpha();\n    this.renderer.setClearColor('black', 1);\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(null);\n    this.renderer.setClearColor(this.clearColor, this.clearAlpha);\n    this.lights = [];\n    this.meshes = [];\n    this.scene.traverse(object => {\n      if (isGeometry(object)) {\n        this.meshes.push({\n          object,\n          material: object.material\n        });\n      } else if (isLight(object)) {\n        this.lights.push({\n          object,\n          intensity: object.intensity\n        });\n      }\n    });\n  }\n\n  prepare() {\n    this.lights.forEach(light => light.object.intensity = 0);\n    this.meshes.forEach(mesh => mesh.object.material = this.discardMat);\n  }\n\n  finish() {\n    this.lights.forEach(light => light.object.intensity = light.intensity);\n    this.meshes.forEach(mesh => mesh.object.material = mesh.material);\n  }\n\n  configure(object) {\n    this.object = object;\n  }\n\n  update(camera, blendWindow = 100) {\n    if (!this.object) return; // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n    this.averagingWindow.value = blendWindow;\n    this.object.material = this.targetMat; // Ping-pong two surface buffers for reading/writing\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    const oldBg = this.scene.background;\n    this.scene.background = null;\n    this.renderer.setRenderTarget(activeMap);\n    this.previousShadowMap.value = inactiveMap.texture;\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.renderer.setRenderTarget(null);\n    this.scene.background = oldBg;\n  }\n\n}\n\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };\n"]},"metadata":{},"sourceType":"module"}
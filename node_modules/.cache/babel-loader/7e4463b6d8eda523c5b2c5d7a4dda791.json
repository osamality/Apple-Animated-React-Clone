{"ast":null,"code":"import TempNode from '../core/TempNode.js';\n\nclass OperatorNode extends TempNode {\n  constructor(op, aNode, bNode, ...params) {\n    super();\n    this.op = op;\n\n    if (params.length > 0) {\n      let finalBNode = bNode;\n\n      for (let i = 0; i < params.length; i++) {\n        finalBNode = new OperatorNode(op, finalBNode, params[i]);\n      }\n\n      bNode = finalBNode;\n    }\n\n    this.aNode = aNode;\n    this.bNode = bNode;\n  }\n\n  getNodeType(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const typeA = aNode.getNodeType(builder);\n    const typeB = bNode.getNodeType(builder);\n\n    if (typeA === 'void' || typeB === 'void') {\n      return 'void';\n    } else if (op === '=' || op === '%') {\n      return typeA;\n    } else if (op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<') {\n      return 'int';\n    } else if (op === '==' || op === '&&' || op === '||' || op === '^^') {\n      return 'bool';\n    } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {\n      const typeLength = builder.getTypeLength(output);\n      return typeLength > 1 ? `bvec${typeLength}` : 'bool';\n    } else {\n      if (typeA === 'float' && builder.isMatrix(typeB)) {\n        return typeB;\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n        return builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n        return builder.getVectorFromMatrix(typeB);\n      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {\n        // anytype x anytype: use the greater length vector\n        return typeB;\n      }\n\n      return typeA;\n    }\n  }\n\n  generate(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const type = this.getNodeType(builder, output);\n    let typeA = null;\n    let typeB = null;\n\n    if (type !== 'void') {\n      typeA = aNode.getNodeType(builder);\n      typeB = bNode.getNodeType(builder);\n\n      if (op === '=') {\n        typeB = typeA;\n      } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {\n        if (builder.isVector(typeA)) {\n          typeB = typeA;\n        } else {\n          typeA = typeB = 'float';\n        }\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n        typeB = builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n        typeA = builder.getVectorFromMatrix(typeB);\n      } else {\n        // anytype x anytype\n        typeA = typeB = type;\n      }\n    } else {\n      typeA = typeB = type;\n    }\n\n    const a = aNode.build(builder, typeA);\n    const b = bNode.build(builder, typeB);\n    const outputLength = builder.getTypeLength(output);\n\n    if (output !== 'void') {\n      if (op === '=') {\n        builder.addFlowCode(`${a} ${this.op} ${b}`);\n        return a;\n      } else if (op === '>' && outputLength > 1) {\n        return builder.format(`${builder.getMethod('greaterThan')}( ${a}, ${b} )`, type, output);\n      } else if (op === '<=' && outputLength > 1) {\n        return builder.format(`${builder.getMethod('lessThanEqual')}( ${a}, ${b} )`, type, output);\n      } else {\n        return builder.format(`( ${a} ${this.op} ${b} )`, type, output);\n      }\n    } else if (typeA !== 'void') {\n      return builder.format(`${a} ${this.op} ${b}`, type, output);\n    }\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.op = this.op;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.op = data.op;\n  }\n\n}\n\nexport default OperatorNode;","map":{"version":3,"sources":["/Users/osamakhan/Desktop/Apple-Website-Clone-React-master/node_modules/three-stdlib/nodes/math/OperatorNode.js"],"names":["TempNode","OperatorNode","constructor","op","aNode","bNode","params","length","finalBNode","i","getNodeType","builder","output","typeA","typeB","typeLength","getTypeLength","isMatrix","isVector","getVectorFromMatrix","generate","type","a","build","b","outputLength","addFlowCode","format","getMethod","serialize","data","deserialize"],"mappings":"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","sourcesContent":["import TempNode from '../core/TempNode.js';\n\nclass OperatorNode extends TempNode {\n  constructor(op, aNode, bNode, ...params) {\n    super();\n    this.op = op;\n\n    if (params.length > 0) {\n      let finalBNode = bNode;\n\n      for (let i = 0; i < params.length; i++) {\n        finalBNode = new OperatorNode(op, finalBNode, params[i]);\n      }\n\n      bNode = finalBNode;\n    }\n\n    this.aNode = aNode;\n    this.bNode = bNode;\n  }\n\n  getNodeType(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const typeA = aNode.getNodeType(builder);\n    const typeB = bNode.getNodeType(builder);\n\n    if (typeA === 'void' || typeB === 'void') {\n      return 'void';\n    } else if (op === '=' || op === '%') {\n      return typeA;\n    } else if (op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<') {\n      return 'int';\n    } else if (op === '==' || op === '&&' || op === '||' || op === '^^') {\n      return 'bool';\n    } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {\n      const typeLength = builder.getTypeLength(output);\n      return typeLength > 1 ? `bvec${typeLength}` : 'bool';\n    } else {\n      if (typeA === 'float' && builder.isMatrix(typeB)) {\n        return typeB;\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n        return builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n        return builder.getVectorFromMatrix(typeB);\n      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {\n        // anytype x anytype: use the greater length vector\n        return typeB;\n      }\n\n      return typeA;\n    }\n  }\n\n  generate(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const type = this.getNodeType(builder, output);\n    let typeA = null;\n    let typeB = null;\n\n    if (type !== 'void') {\n      typeA = aNode.getNodeType(builder);\n      typeB = bNode.getNodeType(builder);\n\n      if (op === '=') {\n        typeB = typeA;\n      } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {\n        if (builder.isVector(typeA)) {\n          typeB = typeA;\n        } else {\n          typeA = typeB = 'float';\n        }\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n        typeB = builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n        typeA = builder.getVectorFromMatrix(typeB);\n      } else {\n        // anytype x anytype\n        typeA = typeB = type;\n      }\n    } else {\n      typeA = typeB = type;\n    }\n\n    const a = aNode.build(builder, typeA);\n    const b = bNode.build(builder, typeB);\n    const outputLength = builder.getTypeLength(output);\n\n    if (output !== 'void') {\n      if (op === '=') {\n        builder.addFlowCode(`${a} ${this.op} ${b}`);\n        return a;\n      } else if (op === '>' && outputLength > 1) {\n        return builder.format(`${builder.getMethod('greaterThan')}( ${a}, ${b} )`, type, output);\n      } else if (op === '<=' && outputLength > 1) {\n        return builder.format(`${builder.getMethod('lessThanEqual')}( ${a}, ${b} )`, type, output);\n      } else {\n        return builder.format(`( ${a} ${this.op} ${b} )`, type, output);\n      }\n    } else if (typeA !== 'void') {\n      return builder.format(`${a} ${this.op} ${b}`, type, output);\n    }\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.op = this.op;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.op = data.op;\n  }\n\n}\n\nexport default OperatorNode;\n"]},"metadata":{},"sourceType":"module"}